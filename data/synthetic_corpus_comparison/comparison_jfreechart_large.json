[
    {
        "oracle": "method org.jfree.chart.plot.PlotState::draw2(Graphics2D, Rectangle2D, Point2D, PlotState, PlotRenderingInfo):void need move org.jfree.chart.plot.dial.DialPlot",
        "class_name": "org.jfree.chart.plot.PlotState",
        "telemetry": {
            "id": "ff82b9f8-71f1-4c79-bea2-718f43d583f0",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 112,
                "lineStart": 56,
                "lineEnd": 167,
                "bodyLineStart": 56,
                "language": "java",
                "sourceCode": "/**\n * Records information about the state of a plot during the drawing process.\n */\npublic class PlotState {\n\n    /** The shared axis states. */\n    private Map sharedAxisStates;\n\n    /**\n     * Creates a new state object.\n     */\n    public PlotState() {\n        this.sharedAxisStates = new HashMap();\n    }\n\n    /**\n     * Returns a map containing the shared axis states.\n     *\n     * @return A map.\n     */\n    public Map getSharedAxisStates() {\n        return this.sharedAxisStates;\n    }\n\n\t/**\n\t * Draws the plot.  This method is usually called by the {@link JFreeChart}\n\t * instance that manages the plot.\n\t *\n\t * @param g2  the graphics target.\n\t * @param area  the area in which the plot should be drawn.\n\t * @param anchor  the anchor point (typically the last point that the\n\t *     mouse clicked on, <code>null</code> is permitted).\n\t * @param dialPlot TODO\n\t * @param info  used to collect plot rendering info (<code>null</code>\n\t *     permitted).\n\t */\n\tpublic void draw2(Graphics2D g2, Rectangle2D area, Point2D anchor, DialPlot dialPlot, PlotRenderingInfo info) {\n\t\n\t    Shape origClip = g2.getClip();\n\t    g2.setClip(area);\n\t\n\t    // first, expand the viewing area into a drawing frame\n\t    Rectangle2D frame = dialPlot.viewToFrame(area);\n\t\n\t    // draw the background if there is one...\n\t    if (dialPlot.background != null && dialPlot.background.isVisible()) {\n\t        if (dialPlot.background.isClippedToWindow()) {\n\t            Shape savedClip = g2.getClip();\n\t            g2.clip(dialPlot.dialFrame.getWindow(frame));\n\t            dialPlot.background.draw(g2, dialPlot, frame, area);\n\t            g2.setClip(savedClip);\n\t        }\n\t        else {\n\t            dialPlot.background.draw(g2, dialPlot, frame, area);\n\t        }\n\t    }\n\t\n\t    Iterator iterator = dialPlot.layers.iterator();\n\t    while (iterator.hasNext()) {\n\t        DialLayer current = (DialLayer) iterator.next();\n\t        if (current.isVisible()) {\n\t            if (current.isClippedToWindow()) {\n\t                Shape savedClip = g2.getClip();\n\t                g2.clip(dialPlot.dialFrame.getWindow(frame));\n\t                current.draw(g2, dialPlot, frame, area);\n\t                g2.setClip(savedClip);\n\t            }\n\t            else {\n\t                current.draw(g2, dialPlot, frame, area);\n\t            }\n\t        }\n\t    }\n\t\n\t    // draw the pointers\n\t    iterator = dialPlot.pointers.iterator();\n\t    while (iterator.hasNext()) {\n\t        DialPointer current = (DialPointer) iterator.next();\n\t        if (current.isVisible()) {\n\t            if (current.isClippedToWindow()) {\n\t                Shape savedClip = g2.getClip();\n\t                g2.clip(dialPlot.dialFrame.getWindow(frame));\n\t                current.draw(g2, dialPlot, frame, area);\n\t                g2.setClip(savedClip);\n\t            }\n\t            else {\n\t                current.draw(g2, dialPlot, frame, area);\n\t            }\n\t        }\n\t    }\n\t\n\t    // draw the cap if there is one...\n\t    if (dialPlot.cap != null && dialPlot.cap.isVisible()) {\n\t        if (dialPlot.cap.isClippedToWindow()) {\n\t            Shape savedClip = g2.getClip();\n\t            g2.clip(dialPlot.dialFrame.getWindow(frame));\n\t            dialPlot.cap.draw(g2, dialPlot, frame, area);\n\t            g2.setClip(savedClip);\n\t        }\n\t        else {\n\t            dialPlot.cap.draw(g2, dialPlot, frame, area);\n\t        }\n\t    }\n\t\n\t    if (dialPlot.dialFrame.isVisible()) {\n\t        dialPlot.dialFrame.draw(g2, dialPlot, frame, area);\n\t    }\n\t\n\t    g2.setClip(origClip);\n\t\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 79,
                        "lineEnd": 164,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.dial.DialPlot\nRationale: The draw2 method is primarily responsible for rendering the visual components of a dial plot, including layers, pointers, and the background. It directly interacts with properties and methods of the DialPlot class, making it more appropriate for this method to reside within the DialPlot class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5108
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "draw2",
                            "method_signature": "public void draw2(Graphics2D g2, Rectangle2D area, Point2D anchor, DialPlot dialPlot, PlotRenderingInfo info)",
                            "target_class": "DialPlot",
                            "rationale": "The draw2 method is heavily dependent on the DialPlot class and its properties. Moving it to the DialPlot class would encapsulate the drawing logic within the class that represents the plot, improving cohesion."
                        }
                    ],
                    "llm_response_time": 1686
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "draw2",
                            "method_signature": "public void draw2(Graphics2D g2, Rectangle2D area, Point2D anchor, DialPlot dialPlot, PlotRenderingInfo info)",
                            "target_class": "DialPlot",
                            "rationale": "The draw2 method is heavily dependent on the DialPlot class and its properties. Moving it to the DialPlot class would encapsulate the drawing logic within the class that represents the plot, improving cohesion."
                        }
                    ],
                    "llm_response_time": 1521
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "draw2",
                            "method_signature": "public void draw2(Graphics2D g2, Rectangle2D area, Point2D anchor, DialPlot dialPlot, PlotRenderingInfo info)",
                            "target_class": "DialPlot",
                            "rationale": "The draw2 method is primarily responsible for rendering the plot and interacts closely with the DialPlot class. Moving it to DialPlot would encapsulate the drawing logic within the class that represents the plot itself."
                        }
                    ],
                    "llm_response_time": 1427
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "draw2",
                            "method_signature": "public void draw2(Graphics2D g2, Rectangle2D area, Point2D anchor, DialPlot dialPlot, PlotRenderingInfo info)",
                            "target_class": "DialPlot",
                            "rationale": "The draw2 method is heavily dependent on the DialPlot class and its properties. Moving it to the DialPlot class would encapsulate the drawing logic within the class that represents the plot, improving cohesion."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "draw2"
                ],
                "llm_response_time": 371
            },
            "targetClassMap": {
                "draw2": {
                    "target_classes": [
                        {
                            "class_name": "DialPlot",
                            "similarity_score": 0.614664911044676
                        },
                        {
                            "class_name": "PlotRenderingInfo",
                            "similarity_score": 0.6058875814395964
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "DialPlot",
                        "PlotRenderingInfo"
                    ],
                    "llm_response_time": 1824,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.data.RangeType::autoAdjustRange2():void need move org.jfree.chart.axis.NumberAxis",
        "class_name": "org.jfree.data.RangeType",
        "telemetry": {
            "id": "bcfacb41-09ab-4e03-826f-dc646d6a2858",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 186,
                "lineStart": 50,
                "lineEnd": 235,
                "bodyLineStart": 50,
                "language": "java",
                "sourceCode": "/**\n * Used to indicate the type of range to display on an axis (full, positive or\n * negative).\n */\npublic final class RangeType implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -9073319010650549239L;\n\n    /** Full range (positive and negative). */\n    public static final RangeType FULL = new RangeType(\"RangeType.FULL\");\n\n    /** Positive range. */\n    public static final RangeType POSITIVE\n        = new RangeType(\"RangeType.POSITIVE\");\n\n    /** Negative range. */\n    public static final RangeType NEGATIVE\n        = new RangeType(\"RangeType.NEGATIVE\");\n\n    /** The name. */\n    private String name;\n\n    /**\n     * Private constructor.\n     *\n     * @param name  the name.\n     */\n    private RangeType(String name) {\n        this.name = name;\n    }\n\n    /**\n     * Returns a string representing the object.\n     *\n     * @return The string.\n     */\n    public String toString() {\n        return this.name;\n    }\n\n    /**\n     * Returns <code>true</code> if this object is equal to the specified\n     * object, and <code>false</code> otherwise.\n     *\n     * @param obj  the other object.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof RangeType)) {\n            return false;\n        }\n        RangeType that = (RangeType) obj;\n        if (!this.name.equals(that.toString())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        return this.name.hashCode();\n    }\n\n    /**\n     * Ensures that serialization returns the unique instances.\n     *\n     * @return The object.\n     *\n     * @throws ObjectStreamException if there is a problem.\n     */\n    private Object readResolve() throws ObjectStreamException {\n        if (this.equals(RangeType.FULL)) {\n            return RangeType.FULL;\n        }\n        else if (this.equals(RangeType.POSITIVE)) {\n            return RangeType.POSITIVE;\n        }\n        else if (this.equals(RangeType.NEGATIVE)) {\n            return RangeType.NEGATIVE;\n        }\n        return null;\n    }\n\n\t/**\n\t * Rescales the axis to ensure that all data is visible.\n\t * @param numberAxis TODO\n\t */\n\tpublic void autoAdjustRange2(NumberAxis numberAxis) {\n\t\n\t    Plot plot = numberAxis.getPlot();\n\t    if (plot == null) {\n\t        return;  // no plot, no data\n\t    }\n\t\n\t    if (plot instanceof ValueAxisPlot) {\n\t        ValueAxisPlot vap = (ValueAxisPlot) plot;\n\t\n\t        Range r = vap.getDataRange(numberAxis);\n\t        if (r == null) {\n\t            r = numberAxis.getDefaultAutoRange();\n\t        }\n\t\n\t        double upper = r.getUpperBound();\n\t        double lower = r.getLowerBound();\n\t        if (this == RangeType.POSITIVE) {\n\t            lower = Math.max(0.0, lower);\n\t            upper = Math.max(0.0, upper);\n\t        }\n\t        else if (this == RangeType.NEGATIVE) {\n\t            lower = Math.min(0.0, lower);\n\t            upper = Math.min(0.0, upper);\n\t        }\n\t\n\t        if (numberAxis.getAutoRangeIncludesZero()) {\n\t            lower = Math.min(lower, 0.0);\n\t            upper = Math.max(upper, 0.0);\n\t        }\n\t        double range = upper - lower;\n\t\n\t        // if fixed auto range, then derive lower bound...\n\t        double fixedAutoRange = numberAxis.getFixedAutoRange();\n\t        if (fixedAutoRange > 0.0) {\n\t            lower = upper - fixedAutoRange;\n\t        }\n\t        else {\n\t            // ensure the autorange is at least <minRange> in size...\n\t            double minRange = numberAxis.getAutoRangeMinimumSize();\n\t            if (range < minRange) {\n\t                double expand = (minRange - range) / 2;\n\t                upper = upper + expand;\n\t                lower = lower - expand;\n\t                if (lower == upper) { // see bug report 1549218\n\t                    double adjust = Math.abs(lower) / 10.0;\n\t                    lower = lower - adjust;\n\t                    upper = upper + adjust;\n\t                }\n\t                if (this == RangeType.POSITIVE) {\n\t                    if (lower < 0.0) {\n\t                        upper = upper - lower;\n\t                        lower = 0.0;\n\t                    }\n\t                }\n\t                else if (this == RangeType.NEGATIVE) {\n\t                    if (upper > 0.0) {\n\t                        lower = lower - upper;\n\t                        upper = 0.0;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (numberAxis.getAutoRangeStickyZero()) {\n\t                if (upper <= 0.0) {\n\t                    upper = Math.min(0.0, upper + numberAxis.getUpperMargin() * range);\n\t                }\n\t                else {\n\t                    upper = upper + numberAxis.getUpperMargin() * range;\n\t                }\n\t                if (lower >= 0.0) {\n\t                    lower = Math.max(0.0, lower - numberAxis.getLowerMargin() * range);\n\t                }\n\t                else {\n\t                    lower = lower - numberAxis.getLowerMargin() * range;\n\t                }\n\t            }\n\t            else {\n\t                upper = upper + numberAxis.getUpperMargin() * range;\n\t                lower = lower - numberAxis.getLowerMargin() * range;\n\t            }\n\t        }\n\t\n\t        numberAxis.setRange(new Range(lower, upper), false, false);\n\t    }\n\t\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 142,
                        "lineEnd": 232,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.axis.NumberAxis\nRationale: The method autoAdjustRange2 directly manipulates the properties and behavior of the NumberAxis instance, including its range and auto-range settings, making it most appropriate to reside within the NumberAxis class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 4908
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "autoAdjustRange2",
                            "method_signature": "public void autoAdjustRange2(NumberAxis numberAxis)",
                            "target_class": "NumberAxis",
                            "rationale": "The autoAdjustRange2 method directly manipulates the NumberAxis and its properties, making it more appropriate for it to reside within the NumberAxis class."
                        }
                    ],
                    "llm_response_time": 1522
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "autoAdjustRange2",
                            "method_signature": "public void autoAdjustRange2(NumberAxis numberAxis)",
                            "target_class": "NumberAxis",
                            "rationale": "The autoAdjustRange2 method is primarily concerned with adjusting the range of a NumberAxis based on its data. It would be more appropriate for this method to reside within the NumberAxis class, as it directly manipulates its properties and behavior."
                        }
                    ],
                    "llm_response_time": 1611
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "autoAdjustRange2",
                            "method_signature": "public void autoAdjustRange2(NumberAxis numberAxis)",
                            "target_class": "NumberAxis",
                            "rationale": "The autoAdjustRange2 method is primarily concerned with adjusting the range of a NumberAxis based on its data. It would be more appropriate for this method to reside within the NumberAxis class, as it directly manipulates its properties and behavior."
                        }
                    ],
                    "llm_response_time": 1309
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "autoAdjustRange2",
                            "method_signature": "public void autoAdjustRange2(NumberAxis numberAxis)",
                            "target_class": "NumberAxis",
                            "rationale": "The autoAdjustRange2 method directly manipulates the NumberAxis and its properties, making it more appropriate for it to reside within the NumberAxis class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "autoAdjustRange2"
                ],
                "llm_response_time": 367
            },
            "targetClassMap": {
                "autoAdjustRange2": {
                    "target_classes": [
                        {
                            "class_name": "NumberAxis",
                            "similarity_score": 0.4857740089627483
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "NumberAxis"
                    ],
                    "llm_response_time": 2714,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.ChartRenderingInfo::doSaveAs():void need move org.jfree.experimental.chart.swt.ChartComposite",
        "class_name": "org.jfree.chart.ChartRenderingInfo",
        "telemetry": {
            "id": "d9d9684b-bb45-48cc-b565-c9405cde694c",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 216,
                "lineStart": 69,
                "lineEnd": 284,
                "bodyLineStart": 69,
                "language": "java",
                "sourceCode": "/**\n * A structure for storing rendering information from one call to the\n * JFreeChart.draw() method.\n * <P>\n * An instance of the {@link JFreeChart} class can draw itself within an\n * arbitrary rectangle on any <code>Graphics2D</code>.  It is assumed that\n * client code will sometimes render the same chart in more than one view, so\n * the {@link JFreeChart} instance does not retain any information about its\n * rendered dimensions.  This information can be useful sometimes, so you have\n * the option to collect the information at each call to\n * <code>JFreeChart.draw()</code>, by passing an instance of this\n * <code>ChartRenderingInfo</code> class.\n */\npublic class ChartRenderingInfo implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 2751952018173406822L;\n\n    /** The area in which the chart is drawn. */\n    private transient Rectangle2D chartArea;\n\n    /** Rendering info for the chart's plot (and subplots, if any). */\n    private PlotRenderingInfo plotInfo;\n\n    /**\n     * Storage for the chart entities.  Since retaining entity information for\n     * charts with a large number of data points consumes a lot of memory, it\n     * is intended that you can set this to <code>null</code> to prevent the\n     * information being collected.\n     */\n    private EntityCollection entities;\n\n    /**\n     * Constructs a new ChartRenderingInfo structure that can be used to\n     * collect information about the dimensions of a rendered chart.\n     */\n    public ChartRenderingInfo() {\n        this(new StandardEntityCollection());\n    }\n\n    /**\n     * Constructs a new instance. If an entity collection is supplied, it will\n     * be populated with information about the entities in a chart.  If it is\n     * <code>null</code>, no entity information (including tool tips) will\n     * be collected.\n     *\n     * @param entities  an entity collection (<code>null</code> permitted).\n     */\n    public ChartRenderingInfo(EntityCollection entities) {\n        this.chartArea = new Rectangle2D.Double();\n        this.plotInfo = new PlotRenderingInfo(this);\n        this.entities = entities;\n    }\n\n    /**\n     * Returns the area in which the chart was drawn.\n     *\n     * @return The area in which the chart was drawn.\n     *\n     * @see #setChartArea(Rectangle2D)\n     */\n    public Rectangle2D getChartArea() {\n        return this.chartArea;\n    }\n\n    /**\n     * Sets the area in which the chart was drawn.\n     *\n     * @param area  the chart area.\n     *\n     * @see #getChartArea()\n     */\n    public void setChartArea(Rectangle2D area) {\n        this.chartArea.setRect(area);\n    }\n\n    /**\n     * Returns the collection of entities maintained by this instance.\n     *\n     * @return The entity collection (possibly <code>null</code>).\n     *\n     * @see #setEntityCollection(EntityCollection)\n     */\n    public EntityCollection getEntityCollection() {\n        return this.entities;\n    }\n\n    /**\n     * Sets the entity collection.\n     *\n     * @param entities  the entity collection (<code>null</code> permitted).\n     *\n     * @see #getEntityCollection()\n     */\n    public void setEntityCollection(EntityCollection entities) {\n        this.entities = entities;\n    }\n\n    /**\n     * Clears the information recorded by this object.\n     */\n    public void clear() {\n        this.chartArea.setRect(0.0, 0.0, 0.0, 0.0);\n        this.plotInfo = new PlotRenderingInfo(this);\n        if (this.entities != null) {\n            this.entities.clear();\n        }\n    }\n\n    /**\n     * Returns the rendering info for the chart's plot.\n     *\n     * @return The rendering info for the plot.\n     */\n    public PlotRenderingInfo getPlotInfo() {\n        return this.plotInfo;\n    }\n\n    /**\n     * Tests this object for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ChartRenderingInfo)) {\n            return false;\n        }\n        ChartRenderingInfo that = (ChartRenderingInfo) obj;\n        if (!ObjectUtilities.equal(this.chartArea, that.chartArea)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.plotInfo, that.plotInfo)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.entities, that.entities)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a clone of this object.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if the object cannot be cloned.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        ChartRenderingInfo clone = (ChartRenderingInfo) super.clone();\n        if (this.chartArea != null) {\n            clone.chartArea = (Rectangle2D) this.chartArea.clone();\n        }\n        if (this.entities instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) this.entities;\n            clone.entities = (EntityCollection) pc.clone();\n        }\n        return clone;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeShape(this.chartArea, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.chartArea = (Rectangle2D) SerialUtilities.readShape(stream);\n    }\n\n\t/**\n\t * Opens a file chooser and gives the user an opportunity to save the chart\n\t * in PNG format.\n\t *\n\t * @param chartComposite TODO\n\t * @throws IOException if there is an I/O error.\n\t */\n\tpublic void doSaveAs(ChartComposite chartComposite) throws IOException {\n\t    FileDialog fileDialog = new FileDialog(chartComposite.canvas.getShell(),\n\t            SWT.SAVE);\n\t    String[] extensions = {\"*.png\"};\n\t    fileDialog.setFilterExtensions(extensions);\n\t    String filename = fileDialog.open();\n\t    if (filename != null) {\n\t        if (chartComposite.isEnforceFileExtensions()) {\n\t            if (!filename.endsWith(\".png\")) {\n\t                filename = filename + \".png\";\n\t            }\n\t        }\n\t        //TODO replace getSize by getBounds ?\n\t        ChartUtilities.saveChartAsPNG(new File(filename), chartComposite.chart,\n\t                chartComposite.canvas.getSize().x, chartComposite.canvas.getSize().y);\n\t    }\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 258,
                        "lineEnd": 281,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.experimental.chart.swt.ChartComposite\nRationale: The doSaveAs method directly interacts with the ChartComposite instance, specifically accessing its canvas and chart properties. It is responsible for saving the chart as a PNG file, which is closely related to the functionality of the ChartComposite class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 4919
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "doSaveAs",
                            "method_signature": "public void doSaveAs(ChartComposite chartComposite) throws IOException",
                            "target_class": "ChartUtilities",
                            "rationale": "The doSaveAs method is responsible for saving the chart as a PNG file, which is more related to chart utilities rather than rendering information. Moving it to ChartUtilities would better align its functionality with the purpose of the class."
                        }
                    ],
                    "llm_response_time": 1458
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "doSaveAs",
                            "method_signature": "public void doSaveAs(ChartComposite chartComposite) throws IOException",
                            "target_class": "ChartUtilities",
                            "rationale": "The doSaveAs method is responsible for saving the chart as a PNG file, which is more related to chart utilities rather than rendering information. Moving it to ChartUtilities would better align its functionality with the purpose of the class."
                        }
                    ],
                    "llm_response_time": 1084
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "doSaveAs",
                            "method_signature": "public void doSaveAs(ChartComposite chartComposite) throws IOException",
                            "target_class": "ChartUtilities",
                            "rationale": "The doSaveAs method is responsible for saving the chart as a PNG file, which is more related to chart utilities rather than rendering information. Moving it to ChartUtilities would better align its functionality with the purpose of that class."
                        }
                    ],
                    "llm_response_time": 1594
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "doSaveAs",
                            "method_signature": "public void doSaveAs(ChartComposite chartComposite) throws IOException",
                            "target_class": "ChartUtilities",
                            "rationale": "The doSaveAs method is responsible for saving the chart as a PNG file, which is more related to chart utilities rather than rendering information. Moving it to ChartUtilities would better align its functionality with the purpose of the class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "doSaveAs"
                ],
                "llm_response_time": 711
            },
            "targetClassMap": {
                "doSaveAs": {
                    "target_classes": [
                        {
                            "class_name": "ChartComposite",
                            "similarity_score": 0.6955896171771783
                        },
                        {
                            "class_name": "PlotRenderingInfo",
                            "similarity_score": 0.6501782608425042
                        },
                        {
                            "class_name": "EntityCollection",
                            "similarity_score": 0.44769529635098976
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ChartComposite",
                        "PlotRenderingInfo",
                        "EntityCollection"
                    ],
                    "llm_response_time": 6275,
                    "similarity_computation_time": 10,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.axis.AxisLocation::draw2(Graphics2D, Rectangle2D, Object):Object need move org.jfree.chart.title.PaintScaleLegend",
        "class_name": "org.jfree.chart.axis.AxisLocation",
        "telemetry": {
            "id": "17f085c6-2c37-4a25-9a07-6c136c1d4339",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 270,
                "lineStart": 60,
                "lineEnd": 329,
                "bodyLineStart": 60,
                "language": "java",
                "sourceCode": "/**\n * Used to indicate the location of an axis on a 2D plot, prior to knowing the\n * orientation of the plot.\n */\npublic final class AxisLocation implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -3276922179323563410L;\n\n    /** Axis at the top or left. */\n    public static final AxisLocation TOP_OR_LEFT = new AxisLocation(\n            \"AxisLocation.TOP_OR_LEFT\");\n\n    /** Axis at the top or right. */\n    public static final AxisLocation TOP_OR_RIGHT = new AxisLocation(\n            \"AxisLocation.TOP_OR_RIGHT\");\n\n    /** Axis at the bottom or left. */\n    public static final AxisLocation BOTTOM_OR_LEFT = new AxisLocation(\n            \"AxisLocation.BOTTOM_OR_LEFT\");\n\n    /** Axis at the bottom or right. */\n    public static final AxisLocation BOTTOM_OR_RIGHT = new AxisLocation(\n            \"AxisLocation.BOTTOM_OR_RIGHT\");\n\n    /** The name. */\n    private String name;\n\n    /**\n     * Private constructor.\n     *\n     * @param name  the name.\n     */\n    private AxisLocation(String name) {\n        this.name = name;\n    }\n\n    /**\n     * Returns the location that is opposite to this location.\n     *\n     * @return The opposite location.\n     *\n     * @since 1.0.5\n     */\n    public AxisLocation getOpposite() {\n        return getOpposite(this);\n    }\n\n    /**\n     * Returns a string representing the object.\n     *\n     * @return The string.\n     */\n    public String toString() {\n        return this.name;\n    }\n\n    /**\n     * Returns <code>true</code> if this object is equal to the specified\n     * object, and <code>false</code> otherwise.\n     *\n     * @param obj  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof AxisLocation)) {\n            return false;\n        }\n        AxisLocation location = (AxisLocation) obj;\n        if (!this.name.equals(location.toString())) {\n            return false;\n        }\n        return true;\n\n    }\n\n    /**\n     * Returns the location that is opposite to the supplied location.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     *\n     * @return The opposite location.\n     */\n    public static AxisLocation getOpposite(AxisLocation location) {\n        if (location == null) {\n            throw new IllegalArgumentException(\"Null 'location' argument.\");\n        }\n        AxisLocation result = null;\n        if (location == AxisLocation.TOP_OR_LEFT) {\n            result = AxisLocation.BOTTOM_OR_RIGHT;\n        }\n        else if (location == AxisLocation.TOP_OR_RIGHT) {\n            result = AxisLocation.BOTTOM_OR_LEFT;\n        }\n        else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n            result = AxisLocation.TOP_OR_RIGHT;\n        }\n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n            result = AxisLocation.TOP_OR_LEFT;\n        }\n        else {\n            throw new IllegalStateException(\"AxisLocation not recognised.\");\n        }\n        return result;\n    }\n\n    /**\n     * Ensures that serialization returns the unique instances.\n     *\n     * @return The object.\n     *\n     * @throws ObjectStreamException if there is a problem.\n     */\n    private Object readResolve() throws ObjectStreamException {\n        if (this.equals(AxisLocation.TOP_OR_RIGHT)) {\n            return AxisLocation.TOP_OR_RIGHT;\n        }\n        else if (this.equals(AxisLocation.BOTTOM_OR_RIGHT)) {\n            return AxisLocation.BOTTOM_OR_RIGHT;\n        }\n        else if (this.equals(AxisLocation.TOP_OR_LEFT)) {\n            return AxisLocation.TOP_OR_LEFT;\n        }\n        else if (this.equals(AxisLocation.BOTTOM_OR_LEFT)) {\n            return AxisLocation.BOTTOM_OR_LEFT;\n        }\n        return null;\n    }\n\n\t/**\n\t * Draws the legend within the specified area.\n\t *\n\t * @param paintScaleLegend TODO\n\t * @param g2  the graphics target (<code>null</code> not permitted).\n\t * @param area  the drawing area (<code>null</code> not permitted).\n\t * @param params  drawing parameters (ignored here).\n\t * @return <code>null</code>.\n\t */\n\tpublic Object draw2(PaintScaleLegend paintScaleLegend, Graphics2D g2, Rectangle2D area, Object params) {\n\t\n\t    Rectangle2D target = (Rectangle2D) area.clone();\n\t    target = paintScaleLegend.trimMargin(target);\n\t    if (paintScaleLegend.backgroundPaint != null) {\n\t        g2.setPaint(paintScaleLegend.backgroundPaint);\n\t        g2.fill(target);\n\t    }\n\t    paintScaleLegend.getFrame().draw(g2, target);\n\t    paintScaleLegend.getFrame().getInsets().trim(target);\n\t    target = paintScaleLegend.trimPadding(target);\n\t    double base = paintScaleLegend.axis.getLowerBound();\n\t    double increment = paintScaleLegend.axis.getRange().getLength() / paintScaleLegend.subdivisions;\n\t    Rectangle2D r = new Double();\n\t\n\t    if (RectangleEdge.isTopOrBottom(paintScaleLegend.getPosition())) {\n\t        RectangleEdge axisEdge = Plot.resolveRangeAxisLocation(\n\t                this, PlotOrientation.HORIZONTAL);\n\t        if (axisEdge == RectangleEdge.TOP) {\n\t            for (int i = 0; i < paintScaleLegend.subdivisions; i++) {\n\t                double v = base + (i * increment);\n\t                Paint p = paintScaleLegend.scale.getPaint(v);\n\t                double vv0 = paintScaleLegend.axis.valueToJava2D(v, target,\n\t                        RectangleEdge.TOP);\n\t                double vv1 = paintScaleLegend.axis.valueToJava2D(v + increment, target,\n\t                        RectangleEdge.TOP);\n\t                double ww = Math.abs(vv1 - vv0) + 1.0;\n\t                r.setRect(Math.min(vv0, vv1), target.getMaxY()\n\t                        - paintScaleLegend.stripWidth, ww, paintScaleLegend.stripWidth);\n\t                g2.setPaint(p);\n\t                g2.fill(r);\n\t            }\n\t            if (paintScaleLegend.isStripOutlineVisible()) {\n\t                g2.setPaint(paintScaleLegend.stripOutlinePaint);\n\t                g2.setStroke(paintScaleLegend.stripOutlineStroke);\n\t                g2.draw(new Double(target.getMinX(),\n\t                        target.getMaxY() - paintScaleLegend.stripWidth,\n\t                        target.getWidth(), paintScaleLegend.stripWidth));\n\t            }\n\t            paintScaleLegend.axis.draw(g2, target.getMaxY() - paintScaleLegend.stripWidth\n\t                    - paintScaleLegend.axisOffset, target, target, RectangleEdge.TOP,\n\t                    null);\n\t        }\n\t        else if (axisEdge == RectangleEdge.BOTTOM) {\n\t            for (int i = 0; i < paintScaleLegend.subdivisions; i++) {\n\t                double v = base + (i * increment);\n\t                Paint p = paintScaleLegend.scale.getPaint(v);\n\t                double vv0 = paintScaleLegend.axis.valueToJava2D(v, target,\n\t                        RectangleEdge.BOTTOM);\n\t                double vv1 = paintScaleLegend.axis.valueToJava2D(v + increment, target,\n\t                        RectangleEdge.BOTTOM);\n\t                double ww = Math.abs(vv1 - vv0) + 1.0;\n\t                r.setRect(Math.min(vv0, vv1), target.getMinY(), ww,\n\t                        paintScaleLegend.stripWidth);\n\t                g2.setPaint(p);\n\t                g2.fill(r);\n\t            }\n\t            if (paintScaleLegend.isStripOutlineVisible()) {\n\t                g2.setPaint(paintScaleLegend.stripOutlinePaint);\n\t                g2.setStroke(paintScaleLegend.stripOutlineStroke);\n\t                g2.draw(new Double(target.getMinX(),\n\t                        target.getMinY(), target.getWidth(),\n\t                        paintScaleLegend.stripWidth));\n\t            }\n\t            paintScaleLegend.axis.draw(g2, target.getMinY() + paintScaleLegend.stripWidth\n\t                    + paintScaleLegend.axisOffset, target, target,\n\t                    RectangleEdge.BOTTOM, null);\n\t        }\n\t    }\n\t    else {\n\t        RectangleEdge axisEdge = Plot.resolveRangeAxisLocation(\n\t                this, PlotOrientation.VERTICAL);\n\t        if (axisEdge == RectangleEdge.LEFT) {\n\t            for (int i = 0; i < paintScaleLegend.subdivisions; i++) {\n\t                double v = base + (i * increment);\n\t                Paint p = paintScaleLegend.scale.getPaint(v);\n\t                double vv0 = paintScaleLegend.axis.valueToJava2D(v, target,\n\t                        RectangleEdge.LEFT);\n\t                double vv1 = paintScaleLegend.axis.valueToJava2D(v + increment, target,\n\t                        RectangleEdge.LEFT);\n\t                double hh = Math.abs(vv1 - vv0) + 1.0;\n\t                r.setRect(target.getMaxX() - paintScaleLegend.stripWidth,\n\t                        Math.min(vv0, vv1), paintScaleLegend.stripWidth, hh);\n\t                g2.setPaint(p);\n\t                g2.fill(r);\n\t            }\n\t            if (paintScaleLegend.isStripOutlineVisible()) {\n\t                g2.setPaint(paintScaleLegend.stripOutlinePaint);\n\t                g2.setStroke(paintScaleLegend.stripOutlineStroke);\n\t                g2.draw(new Double(target.getMaxX()\n\t                        - paintScaleLegend.stripWidth, target.getMinY(), paintScaleLegend.stripWidth,\n\t                        target.getHeight()));\n\t            }\n\t            paintScaleLegend.axis.draw(g2, target.getMaxX() - paintScaleLegend.stripWidth\n\t                    - paintScaleLegend.axisOffset, target, target, RectangleEdge.LEFT,\n\t                    null);\n\t        }\n\t        else if (axisEdge == RectangleEdge.RIGHT) {\n\t            for (int i = 0; i < paintScaleLegend.subdivisions; i++) {\n\t                double v = base + (i * increment);\n\t                Paint p = paintScaleLegend.scale.getPaint(v);\n\t                double vv0 = paintScaleLegend.axis.valueToJava2D(v, target,\n\t                        RectangleEdge.LEFT);\n\t                double vv1 = paintScaleLegend.axis.valueToJava2D(v + increment, target,\n\t                        RectangleEdge.LEFT);\n\t                double hh = Math.abs(vv1 - vv0) + 1.0;\n\t                r.setRect(target.getMinX(), Math.min(vv0, vv1),\n\t                        paintScaleLegend.stripWidth, hh);\n\t                g2.setPaint(p);\n\t                g2.fill(r);\n\t            }\n\t            if (paintScaleLegend.isStripOutlineVisible()) {\n\t                g2.setPaint(paintScaleLegend.stripOutlinePaint);\n\t                g2.setStroke(paintScaleLegend.stripOutlineStroke);\n\t                g2.draw(new Double(target.getMinX(),\n\t                        target.getMinY(), paintScaleLegend.stripWidth,\n\t                        target.getHeight()));\n\t            }\n\t            paintScaleLegend.axis.draw(g2, target.getMinX() + paintScaleLegend.stripWidth\n\t                    + paintScaleLegend.axisOffset, target, target, RectangleEdge.RIGHT,\n\t                    null);\n\t        }\n\t    }\n\t    return null;\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 193,
                        "lineEnd": 326,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.title.PaintScaleLegend\nRationale: The draw2 method is primarily responsible for rendering the legend associated with a PaintScaleLegend instance. It directly manipulates properties and methods of PaintScaleLegend, such as backgroundPaint, frame, axis, and scale, making it logical for this method to reside within the PaintScaleLegend class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 4315
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "draw2",
                            "method_signature": "public Object draw2(PaintScaleLegend paintScaleLegend, Graphics2D g2, Rectangle2D area, Object params)",
                            "target_class": "PaintScaleLegend",
                            "rationale": "The draw2 method is heavily dependent on the PaintScaleLegend class and its properties. Moving it to PaintScaleLegend would encapsulate the drawing logic related to the legend within the class that represents it."
                        }
                    ],
                    "llm_response_time": 1365
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "draw2",
                            "method_signature": "public Object draw2(PaintScaleLegend paintScaleLegend, Graphics2D g2, Rectangle2D area, Object params)",
                            "target_class": "PaintScaleLegend",
                            "rationale": "The draw2() method is heavily dependent on the PaintScaleLegend class and its properties. Moving it to PaintScaleLegend would encapsulate the drawing logic related to the legend within the class that represents it."
                        }
                    ],
                    "llm_response_time": 1163
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "draw2",
                            "method_signature": "public Object draw2(PaintScaleLegend paintScaleLegend, Graphics2D g2, Rectangle2D area, Object params)",
                            "target_class": "PaintScaleLegend",
                            "rationale": "The draw2() method is heavily dependent on the PaintScaleLegend class and its properties. It would be more appropriate for this method to reside within the PaintScaleLegend class, as it directly manipulates its attributes and behavior."
                        }
                    ],
                    "llm_response_time": 1311
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "draw2",
                            "method_signature": "public Object draw2(PaintScaleLegend paintScaleLegend, Graphics2D g2, Rectangle2D area, Object params)",
                            "target_class": "PaintScaleLegend",
                            "rationale": "The draw2 method is heavily dependent on the PaintScaleLegend class and its properties. Moving it to PaintScaleLegend would encapsulate the drawing logic related to the legend within the class that represents it."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "draw2"
                ],
                "llm_response_time": 415
            },
            "targetClassMap": {
                "draw2": {
                    "target_classes": [
                        {
                            "class_name": "PaintScaleLegend",
                            "similarity_score": 0.4331630267666192
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PaintScaleLegend"
                    ],
                    "llm_response_time": 931,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.LegendItemCollection::drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer):void need move org.jfree.chart.plot.XYPlot",
        "class_name": "org.jfree.chart.LegendItemCollection",
        "telemetry": {
            "id": "186232a3-bff5-4fc7-8f60-62be141be822",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 134,
                "lineStart": 62,
                "lineEnd": 195,
                "bodyLineStart": 62,
                "language": "java",
                "sourceCode": "/**\n * A collection of legend items.\n */\npublic class LegendItemCollection implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 1365215565589815953L;\n\n    /** Storage for the legend items. */\n    private List items;\n\n    /**\n     * Constructs a new legend item collection, initially empty.\n     */\n    public LegendItemCollection() {\n        this.items = new java.util.ArrayList();\n    }\n\n    /**\n     * Adds a legend item to the collection.\n     *\n     * @param item  the item to add.\n     */\n    public void add(LegendItem item) {\n        this.items.add(item);\n    }\n\n    /**\n     * Adds the legend items from another collection to this collection.\n     *\n     * @param collection  the other collection.\n     */\n    public void addAll(LegendItemCollection collection) {\n        this.items.addAll(collection.items);\n    }\n\n    /**\n     * Returns a legend item from the collection.\n     *\n     * @param index  the legend item index (zero-based).\n     *\n     * @return The legend item.\n     */\n    public LegendItem get(int index) {\n        return (LegendItem) this.items.get(index);\n    }\n\n    /**\n     * Returns the number of legend items in the collection.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.items.size();\n    }\n\n    /**\n     * Returns an iterator that provides access to all the legend items.\n     *\n     * @return An iterator.\n     */\n    public Iterator iterator() {\n        return this.items.iterator();\n    }\n\n    /**\n     * Tests this collection for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof LegendItemCollection)) {\n            return false;\n        }\n        LegendItemCollection that = (LegendItemCollection) obj;\n        if (!this.items.equals(that.items)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a clone of the collection.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if an item in the collection is not\n     *         cloneable.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        LegendItemCollection clone = (LegendItemCollection) super.clone();\n        clone.items = (List) ObjectUtilities.deepClone(this.items);\n        return clone;\n    }\n\n\t/**\n\t * Draws the domain markers (if any) for an axis and layer.  This method is\n\t * typically called from within the draw() method.\n\t *\n\t * @param xyPlot TODO\n\t * @param g2  the graphics device.\n\t * @param dataArea  the data area.\n\t * @param index  the renderer index.\n\t * @param layer  the layer (foreground or background).\n\t */\n\tpublic void drawDomainMarkers(XYPlot xyPlot, Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\n\t\n\t    XYItemRenderer r = xyPlot.getRenderer(index);\n\t    if (r == null) {\n\t        return;\n\t    }\n\t    // check that the renderer has a corresponding dataset (it doesn't\n\t    // matter if the dataset is null)\n\t    if (index >= xyPlot.getDatasetCount()) {\n\t        return;\n\t    }\n\t    Collection markers = xyPlot.getDomainMarkers(index, layer);\n\t    ValueAxis axis = xyPlot.getDomainAxisForDataset(index);\n\t    if (markers != null && axis != null) {\n\t        Iterator iterator = markers.iterator();\n\t        while (iterator.hasNext()) {\n\t            Marker marker = (Marker) iterator.next();\n\t            r.drawDomainMarker(g2, xyPlot, axis, marker, dataArea);\n\t        }\n\t    }\n\t\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 161,
                        "lineEnd": 192,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.XYPlot\nRationale: The method drawDomainMarkers is closely related to the functionality of the XYPlot class, as it deals with rendering domain markers specific to the plot's axes and layers.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5559
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawDomainMarkers",
                            "method_signature": "public void drawDomainMarkers(XYPlot xyPlot, Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
                            "target_class": "XYPlotRenderer",
                            "rationale": "The drawDomainMarkers method is responsible for rendering domain markers, which is a concern of the renderer rather than the collection of legend items. Moving it to a dedicated renderer class would adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 1601
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawDomainMarkers",
                            "method_signature": "public void drawDomainMarkers(XYPlot xyPlot, Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
                            "target_class": "XYPlot",
                            "rationale": "The drawDomainMarkers method is closely related to the rendering of domain markers in the context of an XYPlot. It would be more appropriate for this method to reside in the XYPlot class, as it directly interacts with its properties and methods."
                        }
                    ],
                    "llm_response_time": 1748
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawDomainMarkers",
                            "method_signature": "public void drawDomainMarkers(XYPlot xyPlot, Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
                            "target_class": "XYPlot",
                            "rationale": "The drawDomainMarkers method is closely related to the rendering of domain markers in the context of an XYPlot. It would be more appropriate for this method to reside in the XYPlot class, as it directly interacts with its properties and methods."
                        }
                    ],
                    "llm_response_time": 1626
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawDomainMarkers",
                            "method_signature": "public void drawDomainMarkers(XYPlot xyPlot, Graphics2D g2, Rectangle2D dataArea, int index, Layer layer)",
                            "target_class": "XYPlotRenderer",
                            "rationale": "The drawDomainMarkers method is responsible for rendering domain markers, which is a concern of the renderer rather than the collection of legend items. Moving it to a dedicated renderer class would adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "drawDomainMarkers"
                ],
                "llm_response_time": 515
            },
            "targetClassMap": {
                "drawDomainMarkers": {
                    "target_classes": [
                        {
                            "class_name": "XYPlot",
                            "similarity_score": 0.805423511720048
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "XYPlot"
                    ],
                    "llm_response_time": 917,
                    "similarity_computation_time": 11,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.block.RectangleConstraint::arrange2(Graphics2D, RectangleConstraint):Size2D need move org.jfree.chart.title.LegendGraphic",
        "class_name": "org.jfree.chart.block.RectangleConstraint",
        "telemetry": {
            "id": "ef175d23-355a-4d95-a7c0-741af613bed0",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 371,
                "lineStart": 53,
                "lineEnd": 423,
                "bodyLineStart": 53,
                "language": "java",
                "sourceCode": "/**\n * A description of a constraint for resizing a rectangle.  Constraints are\n * immutable.\n */\npublic class RectangleConstraint {\n\n    /**\n     * An instance representing no constraint.\n     */\n    public static final RectangleConstraint NONE = new RectangleConstraint(\n            0.0, null, LengthConstraintType.NONE,\n            0.0, null, LengthConstraintType.NONE);\n\n    /** The width. */\n    private double width;\n\n    /** The width range. */\n    private Range widthRange;\n\n    /** The width constraint type. */\n    private LengthConstraintType widthConstraintType;\n\n    /** The fixed or maximum height. */\n    private double height;\n\n    private Range heightRange;\n\n    /** The constraint type. */\n    private LengthConstraintType heightConstraintType;\n\n    /**\n     * Creates a new \"fixed width and height\" instance.\n     *\n     * @param w  the fixed width.\n     * @param h  the fixed height.\n     */\n    public RectangleConstraint(double w, double h) {\n        this(w, null, LengthConstraintType.FIXED,\n                h, null, LengthConstraintType.FIXED);\n    }\n\n    /**\n     * Creates a new \"range width and height\" instance.\n     *\n     * @param w  the width range.\n     * @param h  the height range.\n     */\n    public RectangleConstraint(Range w, Range h) {\n        this(0.0, w, LengthConstraintType.RANGE,\n                0.0, h, LengthConstraintType.RANGE);\n    }\n\n    /**\n     * Creates a new constraint with a range for the width and a\n     * fixed height.\n     *\n     * @param w  the width range.\n     * @param h  the fixed height.\n     */\n    public RectangleConstraint(Range w, double h) {\n        this(0.0, w, LengthConstraintType.RANGE,\n                h, null, LengthConstraintType.FIXED);\n    }\n\n    /**\n     * Creates a new constraint with a fixed width and a range for\n     * the height.\n     *\n     * @param w  the fixed width.\n     * @param h  the height range.\n     */\n    public RectangleConstraint(double w, Range h) {\n        this(w, null, LengthConstraintType.FIXED,\n                0.0, h, LengthConstraintType.RANGE);\n    }\n\n    /**\n     * Creates a new constraint.\n     *\n     * @param w  the fixed or maximum width.\n     * @param widthRange  the width range.\n     * @param widthConstraintType  the width type.\n     * @param h  the fixed or maximum height.\n     * @param heightRange  the height range.\n     * @param heightConstraintType  the height type.\n     */\n    public RectangleConstraint(double w, Range widthRange,\n                               LengthConstraintType widthConstraintType,\n                               double h, Range heightRange,\n                               LengthConstraintType heightConstraintType) {\n        if (widthConstraintType == null) {\n            throw new IllegalArgumentException(\"Null 'widthType' argument.\");\n        }\n        if (heightConstraintType == null) {\n            throw new IllegalArgumentException(\"Null 'heightType' argument.\");\n        }\n        this.width = w;\n        this.widthRange = widthRange;\n        this.widthConstraintType = widthConstraintType;\n        this.height = h;\n        this.heightRange = heightRange;\n        this.heightConstraintType = heightConstraintType;\n    }\n\n    /**\n     * Returns the fixed width.\n     *\n     * @return The width.\n     */\n    public double getWidth() {\n        return this.width;\n    }\n\n    /**\n     * Returns the width range.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public Range getWidthRange() {\n        return this.widthRange;\n    }\n\n    /**\n     * Returns the constraint type.\n     *\n     * @return The constraint type (never <code>null</code>).\n     */\n    public LengthConstraintType getWidthConstraintType() {\n        return this.widthConstraintType;\n    }\n\n    /**\n     * Returns the fixed height.\n     *\n     * @return The height.\n     */\n    public double getHeight() {\n        return this.height;\n    }\n\n    /**\n     * Returns the width range.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public Range getHeightRange() {\n        return this.heightRange;\n    }\n\n    /**\n     * Returns the constraint type.\n     *\n     * @return The constraint type (never <code>null</code>).\n     */\n    public LengthConstraintType getHeightConstraintType() {\n        return this.heightConstraintType;\n    }\n\n    /**\n     * Returns a constraint that matches this one on the height attributes,\n     * but has no width constraint.\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toUnconstrainedWidth() {\n        if (this.widthConstraintType == LengthConstraintType.NONE) {\n            return this;\n        }\n        else {\n            return new RectangleConstraint(this.width, this.widthRange,\n                    LengthConstraintType.NONE, this.height, this.heightRange,\n                    this.heightConstraintType);\n        }\n    }\n\n    /**\n     * Returns a constraint that matches this one on the width attributes,\n     * but has no height constraint.\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toUnconstrainedHeight() {\n        if (this.heightConstraintType == LengthConstraintType.NONE) {\n            return this;\n        }\n        else {\n            return new RectangleConstraint(this.width, this.widthRange,\n                    this.widthConstraintType, 0.0, this.heightRange,\n                    LengthConstraintType.NONE);\n        }\n    }\n\n    /**\n     * Returns a constraint that matches this one on the height attributes,\n     * but has a fixed width constraint.\n     *\n     * @param width  the fixed width.\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toFixedWidth(double width) {\n        return new RectangleConstraint(width, this.widthRange,\n                LengthConstraintType.FIXED, this.height, this.heightRange,\n                this.heightConstraintType);\n    }\n\n    /**\n     * Returns a constraint that matches this one on the width attributes,\n     * but has a fixed height constraint.\n     *\n     * @param height  the fixed height.\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toFixedHeight(double height) {\n        return new RectangleConstraint(this.width, this.widthRange,\n                this.widthConstraintType, height, this.heightRange,\n                LengthConstraintType.FIXED);\n    }\n\n    /**\n     * Returns a constraint that matches this one on the height attributes,\n     * but has a range width constraint.\n     *\n     * @param range  the width range (<code>null</code> not permitted).\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toRangeWidth(Range range) {\n        if (range == null) {\n            throw new IllegalArgumentException(\"Null 'range' argument.\");\n        }\n        return new RectangleConstraint(range.getUpperBound(), range,\n                LengthConstraintType.RANGE, this.height, this.heightRange,\n                this.heightConstraintType);\n    }\n\n    /**\n     * Returns a constraint that matches this one on the width attributes,\n     * but has a range height constraint.\n     *\n     * @param range  the height range (<code>null</code> not permitted).\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toRangeHeight(Range range) {\n        if (range == null) {\n            throw new IllegalArgumentException(\"Null 'range' argument.\");\n        }\n        return new RectangleConstraint(this.width, this.widthRange,\n                this.widthConstraintType, range.getUpperBound(), range,\n                LengthConstraintType.RANGE);\n    }\n\n    /**\n     * Returns a string representation of this instance, mostly used for\n     * debugging purposes.\n     *\n     * @return A string.\n     */\n    public String toString() {\n        return \"RectangleConstraint[\"\n                + this.widthConstraintType.toString() + \": width=\"\n                + this.width + \", height=\" + this.height + \"]\";\n    }\n\n    /**\n     * Returns the new size that reflects the constraints defined by this\n     * instance.\n     *\n     * @param base  the base size.\n     *\n     * @return The constrained size.\n     */\n    public Size2D calculateConstrainedSize(Size2D base) {\n        Size2D result = new Size2D();\n        if (this.widthConstraintType == LengthConstraintType.NONE) {\n            result.width = base.width;\n            if (this.heightConstraintType == LengthConstraintType.NONE) {\n               result.height = base.height;\n            }\n            else if (this.heightConstraintType == LengthConstraintType.RANGE) {\n               result.height = this.heightRange.constrain(base.height);\n            }\n            else if (this.heightConstraintType == LengthConstraintType.FIXED) {\n               result.height = this.height;\n            }\n        }\n        else if (this.widthConstraintType == LengthConstraintType.RANGE) {\n            result.width = this.widthRange.constrain(base.width);\n            if (this.heightConstraintType == LengthConstraintType.NONE) {\n                result.height = base.height;\n            }\n            else if (this.heightConstraintType == LengthConstraintType.RANGE) {\n                result.height = this.heightRange.constrain(base.height);\n            }\n            else if (this.heightConstraintType == LengthConstraintType.FIXED) {\n                result.height = this.height;\n            }\n        }\n        else if (this.widthConstraintType == LengthConstraintType.FIXED) {\n            result.width = this.width;\n            if (this.heightConstraintType == LengthConstraintType.NONE) {\n                result.height = base.height;\n            }\n            else if (this.heightConstraintType == LengthConstraintType.RANGE) {\n                result.height = this.heightRange.constrain(base.height);\n            }\n            else if (this.heightConstraintType == LengthConstraintType.FIXED) {\n                result.height = this.height;\n            }\n        }\n        return result;\n    }\n\n\t/**\n\t * Arranges the contents of the block, within the given constraints, and\n\t * returns the block size.\n\t *\n\t * @param g2  the graphics device.\n\t * @param legendGraphic TODO\n\t * @return The block size (in Java2D units, never <code>null</code>).\n\t */\n\tpublic Size2D arrange2(Graphics2D g2, LegendGraphic legendGraphic) {\n\t    RectangleConstraint contentConstraint = legendGraphic.toContentConstraint(this);\n\t    LengthConstraintType w = contentConstraint.getWidthConstraintType();\n\t    LengthConstraintType h = contentConstraint.getHeightConstraintType();\n\t    Size2D contentSize = null;\n\t    if (w == LengthConstraintType.NONE) {\n\t        if (h == LengthConstraintType.NONE) {\n\t            contentSize = legendGraphic.arrangeNN(g2);\n\t        }\n\t        else if (h == LengthConstraintType.RANGE) {\n\t            throw new RuntimeException(\"Not yet implemented.\");\n\t        }\n\t        else if (h == LengthConstraintType.FIXED) {\n\t            throw new RuntimeException(\"Not yet implemented.\");\n\t        }\n\t    }\n\t    else if (w == LengthConstraintType.RANGE) {\n\t        if (h == LengthConstraintType.NONE) {\n\t            throw new RuntimeException(\"Not yet implemented.\");\n\t        }\n\t        else if (h == LengthConstraintType.RANGE) {\n\t            throw new RuntimeException(\"Not yet implemented.\");\n\t        }\n\t        else if (h == LengthConstraintType.FIXED) {\n\t            throw new RuntimeException(\"Not yet implemented.\");\n\t        }\n\t    }\n\t    else if (w == LengthConstraintType.FIXED) {\n\t        if (h == LengthConstraintType.NONE) {\n\t            throw new RuntimeException(\"Not yet implemented.\");\n\t        }\n\t        else if (h == LengthConstraintType.RANGE) {\n\t            throw new RuntimeException(\"Not yet implemented.\");\n\t        }\n\t        else if (h == LengthConstraintType.FIXED) {\n\t            contentSize = new Size2D(\n\t                contentConstraint.getWidth(),\n\t                contentConstraint.getHeight()\n\t            );\n\t        }\n\t    }\n\t    return new Size2D(\n\t        legendGraphic.calculateTotalWidth(contentSize.getWidth()),\n\t        legendGraphic.calculateTotalHeight(contentSize.getHeight())\n\t    );\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 367,
                        "lineEnd": 420,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.title.LegendGraphic\nRationale: The method 'arrange2' heavily interacts with the 'LegendGraphic' class, utilizing its methods and properties to determine the arrangement and size of graphical elements. It is logical to move this method to 'LegendGraphic' as it directly pertains to the arrangement of its content.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 9174
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "arrange2",
                            "method_signature": "public Size2D arrange2(Graphics2D g2, LegendGraphic legendGraphic)",
                            "target_class": "LegendGraphic",
                            "rationale": "The arrange2 method is primarily concerned with arranging the contents of a LegendGraphic based on the constraints defined in RectangleConstraint. It would be more appropriate for this method to reside in the LegendGraphic class, as it directly manipulates and utilizes its properties."
                        },
                        {
                            "method_name": "calculateConstrainedSize",
                            "method_signature": "public Size2D calculateConstrainedSize(Size2D base)",
                            "target_class": "Size2D",
                            "rationale": "The calculateConstrainedSize method operates on the Size2D object and returns a Size2D object. It would be more cohesive to move this method to the Size2D class, as it deals with size calculations and constraints."
                        }
                    ],
                    "llm_response_time": 3498
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "arrange2",
                            "method_signature": "public Size2D arrange2(Graphics2D g2, LegendGraphic legendGraphic)",
                            "target_class": "LegendGraphic",
                            "rationale": "The arrange2 method is heavily dependent on the LegendGraphic class for its functionality. It would be more appropriate for this method to reside within the LegendGraphic class, as it directly manipulates and utilizes its properties and methods."
                        },
                        {
                            "method_name": "calculateConstrainedSize",
                            "method_signature": "public Size2D calculateConstrainedSize(Size2D base)",
                            "target_class": "Size2D",
                            "rationale": "The calculateConstrainedSize method is focused on calculating sizes based on constraints, which is a core responsibility of the Size2D class. Moving this method to Size2D would align its functionality with the class's purpose."
                        }
                    ],
                    "llm_response_time": 2180
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "arrange2",
                            "method_signature": "public Size2D arrange2(Graphics2D g2, LegendGraphic legendGraphic)",
                            "target_class": "LegendGraphic",
                            "rationale": "The arrange2 method is heavily dependent on the LegendGraphic class for its functionality. It would be more appropriate for this method to reside within the LegendGraphic class, as it directly manipulates and utilizes its properties and methods."
                        },
                        {
                            "method_name": "calculateConstrainedSize",
                            "method_signature": "public Size2D calculateConstrainedSize(Size2D base)",
                            "target_class": "Size2D",
                            "rationale": "The calculateConstrainedSize method is focused on determining the size based on constraints, which is closely related to the Size2D class. Moving this method to Size2D would enhance cohesion and encapsulate size-related logic within the Size2D class."
                        }
                    ],
                    "llm_response_time": 2747
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "arrange2",
                            "method_signature": "public Size2D arrange2(Graphics2D g2, LegendGraphic legendGraphic)",
                            "target_class": "LegendGraphic",
                            "rationale": "The arrange2 method is primarily concerned with arranging the contents of a LegendGraphic based on the constraints defined in RectangleConstraint. It would be more appropriate for this method to reside in the LegendGraphic class, as it directly manipulates and utilizes its properties."
                        },
                        {
                            "method_name": "calculateConstrainedSize",
                            "method_signature": "public Size2D calculateConstrainedSize(Size2D base)",
                            "target_class": "Size2D",
                            "rationale": "The calculateConstrainedSize method operates on the Size2D object and returns a Size2D object. It would be more cohesive to move this method to the Size2D class, as it deals with size calculations and constraints."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "calculateConstrainedSize",
                    "arrange2"
                ],
                "llm_response_time": 671
            },
            "targetClassMap": {
                "calculateConstrainedSize": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1324,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "arrange2": {
                    "target_classes": [
                        {
                            "class_name": "LegendGraphic",
                            "similarity_score": 0.44911424456247456
                        },
                        {
                            "class_name": "LengthConstraintType",
                            "similarity_score": 0.5157959580961531
                        },
                        {
                            "class_name": "LengthConstraintType",
                            "similarity_score": 0.5157959580961531
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "LegendGraphic",
                        "LengthConstraintType",
                        "LengthConstraintType"
                    ],
                    "llm_response_time": 1385,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.title.Title::drawTitle(Title, Graphics2D, Rectangle2D, boolean):EntityCollection need move org.jfree.chart.JFreeChart",
        "class_name": "org.jfree.chart.title.Title",
        "telemetry": {
            "id": "7f7400c4-05e4-4cf3-bba0-b64beb583f7e",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 477,
                "lineStart": 91,
                "lineEnd": 567,
                "bodyLineStart": 91,
                "language": "java",
                "sourceCode": "/**\n * The base class for all chart titles.  A chart can have multiple titles,\n * appearing at the top, bottom, left or right of the chart.\n * <P>\n * Concrete implementations of this class will render text and images, and\n * hence do the actual work of drawing titles.\n */\npublic abstract class Title extends AbstractBlock\n            implements Block, Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -6675162505277817221L;\n\n    /** The default title position. */\n    public static final RectangleEdge DEFAULT_POSITION = RectangleEdge.TOP;\n\n    /** The default horizontal alignment. */\n    public static final HorizontalAlignment\n            DEFAULT_HORIZONTAL_ALIGNMENT = HorizontalAlignment.CENTER;\n\n    /** The default vertical alignment. */\n    public static final VerticalAlignment\n            DEFAULT_VERTICAL_ALIGNMENT = VerticalAlignment.CENTER;\n\n    /** Default title padding. */\n    public static final RectangleInsets DEFAULT_PADDING = new RectangleInsets(\n            1, 1, 1, 1);\n\n    /**\n     * A flag that controls whether or not the title is visible.\n     *\n     * @since 1.0.11\n     */\n    public boolean visible;\n\n    /** The title position. */\n    private RectangleEdge position;\n\n    /** The horizontal alignment of the title content. */\n    private HorizontalAlignment horizontalAlignment;\n\n    /** The vertical alignment of the title content. */\n    private VerticalAlignment verticalAlignment;\n\n    /** Storage for registered change listeners. */\n    private transient EventListenerList listenerList;\n\n    /**\n     * A flag that can be used to temporarily disable the listener mechanism.\n     */\n    private boolean notify;\n\n    /**\n     * Creates a new title, using default attributes where necessary.\n     */\n    protected Title() {\n        this(Title.DEFAULT_POSITION,\n                Title.DEFAULT_HORIZONTAL_ALIGNMENT,\n                Title.DEFAULT_VERTICAL_ALIGNMENT, Title.DEFAULT_PADDING);\n    }\n\n    /**\n     * Creates a new title, using default attributes where necessary.\n     *\n     * @param position  the position of the title (<code>null</code> not\n     *                  permitted).\n     * @param horizontalAlignment  the horizontal alignment of the title\n     *                             (<code>null</code> not permitted).\n     * @param verticalAlignment  the vertical alignment of the title\n     *                           (<code>null</code> not permitted).\n     */\n    protected Title(RectangleEdge position,\n                    HorizontalAlignment horizontalAlignment,\n                    VerticalAlignment verticalAlignment) {\n\n        this(position, horizontalAlignment, verticalAlignment,\n                Title.DEFAULT_PADDING);\n\n    }\n\n    /**\n     * Creates a new title.\n     *\n     * @param position  the position of the title (<code>null</code> not\n     *                  permitted).\n     * @param horizontalAlignment  the horizontal alignment of the title (LEFT,\n     *                             CENTER or RIGHT, <code>null</code> not\n     *                             permitted).\n     * @param verticalAlignment  the vertical alignment of the title (TOP,\n     *                           MIDDLE or BOTTOM, <code>null</code> not\n     *                           permitted).\n     * @param padding  the amount of space to leave around the outside of the\n     *                 title (<code>null</code> not permitted).\n     */\n    protected Title(RectangleEdge position,\n                    HorizontalAlignment horizontalAlignment,\n                    VerticalAlignment verticalAlignment,\n                    RectangleInsets padding) {\n\n        // check arguments...\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");\n        }\n        if (horizontalAlignment == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'horizontalAlignment' argument.\");\n        }\n\n        if (verticalAlignment == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'verticalAlignment' argument.\");\n        }\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'spacer' argument.\");\n        }\n\n        this.visible = true;\n        this.position = position;\n        this.horizontalAlignment = horizontalAlignment;\n        this.verticalAlignment = verticalAlignment;\n        setPadding(padding);\n        this.listenerList = new EventListenerList();\n        this.notify = true;\n\n    }\n\n    /**\n     * Returns a flag that controls whether or not the title should be\n     * drawn.  The default value is <code>true</code>.\n     *\n     * @return A boolean.\n     *\n     * @see #setVisible(boolean)\n     *\n     * @since 1.0.11\n     */\n    public boolean isVisible() {\n        return this.visible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not the title should be drawn, and\n     * sends a {@link TitleChangeEvent} to all registered listeners.\n     *\n     * @param visible  the new flag value.\n     *\n     * @see #isVisible()\n     *\n     * @since 1.0.11\n     */\n    public void setVisible(boolean visible) {\n        this.visible = visible;\n        notifyListeners(new TitleChangeEvent(this));\n    }\n\n    /**\n     * Returns the position of the title.\n     *\n     * @return The title position (never <code>null</code>).\n     */\n    public RectangleEdge getPosition() {\n        return this.position;\n    }\n\n    /**\n     * Sets the position for the title and sends a {@link TitleChangeEvent} to\n     * all registered listeners.\n     *\n     * @param position  the position (<code>null</code> not permitted).\n     */\n    public void setPosition(RectangleEdge position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");\n        }\n        if (this.position != position) {\n            this.position = position;\n            notifyListeners(new TitleChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the horizontal alignment of the title.\n     *\n     * @return The horizontal alignment (never <code>null</code>).\n     */\n    public HorizontalAlignment getHorizontalAlignment() {\n        return this.horizontalAlignment;\n    }\n\n    /**\n     * Sets the horizontal alignment for the title and sends a\n     * {@link TitleChangeEvent} to all registered listeners.\n     *\n     * @param alignment  the horizontal alignment (<code>null</code> not\n     *                   permitted).\n     */\n    public void setHorizontalAlignment(HorizontalAlignment alignment) {\n        if (alignment == null) {\n            throw new IllegalArgumentException(\"Null 'alignment' argument.\");\n        }\n        if (this.horizontalAlignment != alignment) {\n            this.horizontalAlignment = alignment;\n            notifyListeners(new TitleChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the vertical alignment of the title.\n     *\n     * @return The vertical alignment (never <code>null</code>).\n     */\n    public VerticalAlignment getVerticalAlignment() {\n        return this.verticalAlignment;\n    }\n\n    /**\n     * Sets the vertical alignment for the title, and notifies any registered\n     * listeners of the change.\n     *\n     * @param alignment  the new vertical alignment (TOP, MIDDLE or BOTTOM,\n     *                   <code>null</code> not permitted).\n     */\n    public void setVerticalAlignment(VerticalAlignment alignment) {\n        if (alignment == null) {\n            throw new IllegalArgumentException(\"Null 'alignment' argument.\");\n        }\n        if (this.verticalAlignment != alignment) {\n            this.verticalAlignment = alignment;\n            notifyListeners(new TitleChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the flag that indicates whether or not the notification\n     * mechanism is enabled.\n     *\n     * @return The flag.\n     */\n    public boolean getNotify() {\n        return this.notify;\n    }\n\n    /**\n     * Sets the flag that indicates whether or not the notification mechanism\n     * is enabled.  There are certain situations (such as cloning) where you\n     * want to turn notification off temporarily.\n     *\n     * @param flag  the new value of the flag.\n     */\n    public void setNotify(boolean flag) {\n        this.notify = flag;\n        if (flag) {\n            notifyListeners(new TitleChangeEvent(this));\n        }\n    }\n\n    /**\n     * Draws the title on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device.\n     * @param area  the area allocated for the title (subclasses should not\n     *              draw outside this area).\n     */\n    public abstract void draw(Graphics2D g2, Rectangle2D area);\n\n    /**\n     * Returns a clone of the title.\n     * <P>\n     * One situation when this is useful is when editing the title properties -\n     * you can edit a clone, and then it is easier to cancel the changes if\n     * necessary.\n     *\n     * @return A clone of the title.\n     *\n     * @throws CloneNotSupportedException not thrown by this class, but it may\n     *         be thrown by subclasses.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Title duplicate = (Title) super.clone();\n        duplicate.listenerList = new EventListenerList();\n        // RectangleInsets is immutable => same reference in clone OK\n        return duplicate;\n    }\n\n    /**\n     * Registers an object for notification of changes to the title.\n     *\n     * @param listener  the object that is being registered.\n     */\n    public void addChangeListener(TitleChangeListener listener) {\n        this.listenerList.add(TitleChangeListener.class, listener);\n    }\n\n    /**\n     * Unregisters an object for notification of changes to the chart title.\n     *\n     * @param listener  the object that is being unregistered.\n     */\n    public void removeChangeListener(TitleChangeListener listener) {\n        this.listenerList.remove(TitleChangeListener.class, listener);\n    }\n\n    /**\n     * Notifies all registered listeners that the chart title has changed in\n     * some way.\n     *\n     * @param event  an object that contains information about the change to\n     *               the title.\n     */\n    protected void notifyListeners(TitleChangeEvent event) {\n        if (this.notify) {\n            Object[] listeners = this.listenerList.getListenerList();\n            for (int i = listeners.length - 2; i >= 0; i -= 2) {\n                if (listeners[i] == TitleChangeListener.class) {\n                    ((TitleChangeListener) listeners[i + 1]).titleChanged(\n                            event);\n                }\n            }\n        }\n    }\n\n    /**\n     * Tests an object for equality with this title.\n     *\n     * @param obj  the object (<code>null</code> not permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Title)) {\n            return false;\n        }\n        Title that = (Title) obj;\n        if (this.visible != that.visible) {\n            return false;\n        }\n        if (this.position != that.position) {\n            return false;\n        }\n        if (this.horizontalAlignment != that.horizontalAlignment) {\n            return false;\n        }\n        if (this.verticalAlignment != that.verticalAlignment) {\n            return false;\n        }\n        if (this.notify != that.notify) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hashcode for the title.\n     *\n     * @return The hashcode.\n     */\n    public int hashCode() {\n        int result = 193;\n        result = 37 * result + ObjectUtilities.hashCode(this.position);\n        result = 37 * result\n                + ObjectUtilities.hashCode(this.horizontalAlignment);\n        result = 37 * result + ObjectUtilities.hashCode(this.verticalAlignment);\n        return result;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.listenerList = new EventListenerList();\n    }\n\n\t/**\n\t * Draws a title.  The title should be drawn at the top, bottom, left or\n\t * right of the specified area, and the area should be updated to reflect\n\t * the amount of space used by the title.\n\t *\n\t * @param jFreeChart TODO\n\t * @param g2  the graphics device (<code>null</code> not permitted).\n\t * @param area  the chart area, excluding any existing titles\n\t *              (<code>null</code> not permitted).\n\t * @param entities  a flag that controls whether or not an entity\n\t *                  collection is returned for the title.\n\t * @return An entity collection for the title (possibly <code>null</code>).\n\t */\n\tpublic EntityCollection drawTitle(JFreeChart jFreeChart, Graphics2D g2, Rectangle2D area, boolean entities) {\n\t\n\t    if (this == null) {\n\t        throw new IllegalArgumentException(\"Null 't' argument.\");\n\t    }\n\t    if (area == null) {\n\t        throw new IllegalArgumentException(\"Null 'area' argument.\");\n\t    }\n\t    Rectangle2D titleArea = new Double();\n\t    RectangleEdge position = getPosition();\n\t    double ww = area.getWidth();\n\t    if (ww <= 0.0) {\n\t        return null;\n\t    }\n\t    double hh = area.getHeight();\n\t    if (hh <= 0.0) {\n\t        return null;\n\t    }\n\t    RectangleConstraint constraint = new RectangleConstraint(ww,\n\t            new Range(0.0, ww), LengthConstraintType.RANGE, hh,\n\t            new Range(0.0, hh), LengthConstraintType.RANGE);\n\t    Object retValue = null;\n\t    BlockParams p = new BlockParams();\n\t    p.setGenerateEntities(entities);\n\t    if (position == RectangleEdge.TOP) {\n\t        Size2D size = arrange(g2, constraint);\n\t        titleArea = jFreeChart.createAlignedRectangle2D(size, area,\n\t                getHorizontalAlignment(), VerticalAlignment.TOP);\n\t        retValue = draw(g2, titleArea, p);\n\t        area.setRect(area.getX(), Math.min(area.getY() + size.height,\n\t                area.getMaxY()), area.getWidth(), Math.max(area.getHeight()\n\t                - size.height, 0));\n\t    }\n\t    else if (position == RectangleEdge.BOTTOM) {\n\t        Size2D size = arrange(g2, constraint);\n\t        titleArea = jFreeChart.createAlignedRectangle2D(size, area,\n\t                getHorizontalAlignment(), VerticalAlignment.BOTTOM);\n\t        retValue = draw(g2, titleArea, p);\n\t        area.setRect(area.getX(), area.getY(), area.getWidth(),\n\t                area.getHeight() - size.height);\n\t    }\n\t    else if (position == RectangleEdge.RIGHT) {\n\t        Size2D size = arrange(g2, constraint);\n\t        titleArea = jFreeChart.createAlignedRectangle2D(size, area,\n\t                HorizontalAlignment.RIGHT, getVerticalAlignment());\n\t        retValue = draw(g2, titleArea, p);\n\t        area.setRect(area.getX(), area.getY(), area.getWidth()\n\t                - size.width, area.getHeight());\n\t    }\n\t\n\t    else if (position == RectangleEdge.LEFT) {\n\t        Size2D size = arrange(g2, constraint);\n\t        titleArea = jFreeChart.createAlignedRectangle2D(size, area,\n\t                HorizontalAlignment.LEFT, getVerticalAlignment());\n\t        retValue = draw(g2, titleArea, p);\n\t        area.setRect(area.getX() + size.width, area.getY(), area.getWidth()\n\t                - size.width, area.getHeight());\n\t    }\n\t    else {\n\t        throw new RuntimeException(\"Unrecognised title position.\");\n\t    }\n\t    EntityCollection result = null;\n\t    if (retValue instanceof EntityBlockResult) {\n\t        EntityBlockResult ebr = (EntityBlockResult) retValue;\n\t        result = ebr.getEntityCollection();\n\t    }\n\t    return result;\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 484,
                        "lineEnd": 564,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.JFreeChart\nRationale: The drawTitle method is responsible for rendering a title within a chart, which directly relates to the JFreeChart class as it manages the overall chart structure and presentation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5018
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawTitle",
                            "method_signature": "public EntityCollection drawTitle(JFreeChart jFreeChart, Graphics2D g2, Rectangle2D area, boolean entities)",
                            "target_class": "Chart",
                            "rationale": "The drawTitle method is responsible for rendering the title within the context of a chart. It would be more appropriate for this method to reside in a Chart class, which can manage the overall rendering of chart components, including titles."
                        }
                    ],
                    "llm_response_time": 1701
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawTitle",
                            "method_signature": "public EntityCollection drawTitle(JFreeChart jFreeChart, Graphics2D g2, Rectangle2D area, boolean entities)",
                            "target_class": "Chart",
                            "rationale": "The drawTitle method is responsible for rendering the title within the context of a chart. It would be more appropriate for this method to reside in a Chart class that manages the overall rendering of chart components, including titles."
                        }
                    ],
                    "llm_response_time": 1319
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawTitle",
                            "method_signature": "public EntityCollection drawTitle(JFreeChart jFreeChart, Graphics2D g2, Rectangle2D area, boolean entities)",
                            "target_class": "Chart",
                            "rationale": "The drawTitle method is responsible for rendering the title within the context of a chart. It would be more appropriate for this method to reside in a Chart class, which can manage the overall rendering of chart components, including titles."
                        }
                    ],
                    "llm_response_time": 1226
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawTitle",
                            "method_signature": "public EntityCollection drawTitle(JFreeChart jFreeChart, Graphics2D g2, Rectangle2D area, boolean entities)",
                            "target_class": "Chart",
                            "rationale": "The drawTitle method is responsible for rendering the title within the context of a chart. It would be more appropriate for this method to reside in a Chart class, which can manage the overall rendering of chart components, including titles."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "drawTitle"
                ],
                "llm_response_time": 697
            },
            "targetClassMap": {
                "drawTitle": {
                    "target_classes": [
                        {
                            "class_name": "JFreeChart",
                            "similarity_score": 0.6154636772477655
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JFreeChart"
                    ],
                    "llm_response_time": 2449,
                    "similarity_computation_time": 8,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.JFreeChart::testReplaceDataset():void need move org.jfree.chart.junit.StackedBarChartTests",
        "class_name": "org.jfree.chart.JFreeChart",
        "telemetry": {
            "id": "d066b86d-6fc3-427e-a8bb-3f95a2e4fe0c",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1461,
                "lineStart": 226,
                "lineEnd": 1686,
                "bodyLineStart": 226,
                "language": "java",
                "sourceCode": "/**\n * A chart class implemented using the Java 2D APIs.  The current version\n * supports bar charts, line charts, pie charts and xy plots (including time\n * series data).\n * <P>\n * JFreeChart coordinates several objects to achieve its aim of being able to\n * draw a chart on a Java 2D graphics device: a list of {@link Title} objects\n * (which often includes the chart's legend), a {@link Plot} and a\n * {@link org.jfree.data.general.Dataset} (the plot in turn manages a\n * domain axis and a range axis).\n * <P>\n * You should use a {@link ChartPanel} to display a chart in a GUI.\n * <P>\n * The {@link ChartFactory} class contains static methods for creating\n * 'ready-made' charts.\n *\n * @see ChartPanel\n * @see ChartFactory\n * @see Title\n * @see Plot\n */\npublic class JFreeChart implements Drawable,\n                                   TitleChangeListener,\n                                   PlotChangeListener,\n                                   Serializable,\n                                   Cloneable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -3470703747817429120L;\n\n    /** Information about the project. */\n    public static final ProjectInfo INFO = new JFreeChartInfo();\n\n    /** The default font for titles. */\n    public static final Font DEFAULT_TITLE_FONT\n            = new Font(\"SansSerif\", Font.BOLD, 18);\n\n    /** The default background color. */\n    public static final Paint DEFAULT_BACKGROUND_PAINT\n            = UIManager.getColor(\"Panel.background\");\n\n    /** The default background image. */\n    public static final Image DEFAULT_BACKGROUND_IMAGE = null;\n\n    /** The default background image alignment. */\n    public static final int DEFAULT_BACKGROUND_IMAGE_ALIGNMENT = Align.FIT;\n\n    /** The default background image alpha. */\n    public static final float DEFAULT_BACKGROUND_IMAGE_ALPHA = 0.5f;\n\n    /**\n     * Rendering hints that will be used for chart drawing.  This should never\n     * be <code>null</code>.\n     */\n    private transient RenderingHints renderingHints;\n\n    /** A flag that controls whether or not the chart border is drawn. */\n    private boolean borderVisible;\n\n    /** The stroke used to draw the chart border (if visible). */\n    private transient Stroke borderStroke;\n\n    /** The paint used to draw the chart border (if visible). */\n    private transient Paint borderPaint;\n\n    /** The padding between the chart border and the chart drawing area. */\n    private RectangleInsets padding;\n\n    /** The chart title (optional). */\n    private TextTitle title;\n\n    /**\n     * The chart subtitles (zero, one or many).  This field should never be\n     * <code>null</code>.\n     */\n    private List subtitles;\n\n    /** Draws the visual representation of the data. */\n    private Plot plot;\n\n    /** Paint used to draw the background of the chart. */\n    private transient Paint backgroundPaint;\n\n    /** An optional background image for the chart. */\n    private transient Image backgroundImage;  // todo: not serialized yet\n\n    /** The alignment for the background image. */\n    private int backgroundImageAlignment = Align.FIT;\n\n    /** The alpha transparency for the background image. */\n    private float backgroundImageAlpha = 0.5f;\n\n    /** Storage for registered change listeners. */\n    private transient EventListenerList changeListeners;\n\n    /** Storage for registered progress listeners. */\n    private transient EventListenerList progressListeners;\n\n    /**\n     * A flag that can be used to enable/disable notification of chart change\n     * events.\n     */\n    private boolean notify;\n\n    /**\n     * Creates a new chart based on the supplied plot.  The chart will have\n     * a legend added automatically, but no title (although you can easily add\n     * one later).\n     * <br><br>\n     * Note that the  {@link ChartFactory} class contains a range\n     * of static methods that will return ready-made charts, and often this\n     * is a more convenient way to create charts than using this constructor.\n     *\n     * @param plot  the plot (<code>null</code> not permitted).\n     */\n    public JFreeChart(Plot plot) {\n        this(null, null, plot, true);\n    }\n\n    /**\n     * Creates a new chart with the given title and plot.  A default font\n     * ({@link #DEFAULT_TITLE_FONT}) is used for the title, and the chart will\n     * have a legend added automatically.\n     * <br><br>\n     * Note that the {@link ChartFactory} class contains a range\n     * of static methods that will return ready-made charts, and often this\n     * is a more convenient way to create charts than using this constructor.\n     *\n     * @param title  the chart title (<code>null</code> permitted).\n     * @param plot  the plot (<code>null</code> not permitted).\n     */\n    public JFreeChart(String title, Plot plot) {\n        this(title, JFreeChart.DEFAULT_TITLE_FONT, plot, true);\n    }\n\n    /**\n     * Creates a new chart with the given title and plot.  The\n     * <code>createLegend</code> argument specifies whether or not a legend\n     * should be added to the chart.\n     * <br><br>\n     * Note that the  {@link ChartFactory} class contains a range\n     * of static methods that will return ready-made charts, and often this\n     * is a more convenient way to create charts than using this constructor.\n     *\n     * @param title  the chart title (<code>null</code> permitted).\n     * @param titleFont  the font for displaying the chart title\n     *                   (<code>null</code> permitted).\n     * @param plot  controller of the visual representation of the data\n     *              (<code>null</code> not permitted).\n     * @param createLegend  a flag indicating whether or not a legend should\n     *                      be created for the chart.\n     */\n    public JFreeChart(String title, Font titleFont, Plot plot,\n                      boolean createLegend) {\n\n        if (plot == null) {\n            throw new NullPointerException(\"Null 'plot' argument.\");\n        }\n\n        // create storage for listeners...\n        this.progressListeners = new EventListenerList();\n        this.changeListeners = new EventListenerList();\n        this.notify = true;  // default is to notify listeners when the\n                             // chart changes\n\n        this.renderingHints = new RenderingHints(\n                RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        this.borderVisible = false;\n        this.borderStroke = new BasicStroke(1.0f);\n        this.borderPaint = Color.black;\n\n        this.padding = RectangleInsets.ZERO_INSETS;\n\n        this.plot = plot;\n        plot.addChangeListener(this);\n\n        this.subtitles = new ArrayList();\n\n        // create a legend, if requested...\n        if (createLegend) {\n            LegendTitle legend = new LegendTitle(this.plot);\n            legend.setMargin(new RectangleInsets(1.0, 1.0, 1.0, 1.0));\n            legend.setFrame(new LineBorder());\n            legend.setBackgroundPaint(Color.white);\n            legend.setPosition(RectangleEdge.BOTTOM);\n            this.subtitles.add(legend);\n            legend.addChangeListener(this);\n        }\n\n        // add the chart title, if one has been specified...\n        if (title != null) {\n            if (titleFont == null) {\n                titleFont = DEFAULT_TITLE_FONT;\n            }\n            this.title = new TextTitle(title, titleFont);\n            this.title.addChangeListener(this);\n        }\n\n        this.backgroundPaint = DEFAULT_BACKGROUND_PAINT;\n\n        this.backgroundImage = DEFAULT_BACKGROUND_IMAGE;\n        this.backgroundImageAlignment = DEFAULT_BACKGROUND_IMAGE_ALIGNMENT;\n        this.backgroundImageAlpha = DEFAULT_BACKGROUND_IMAGE_ALPHA;\n\n    }\n\n    /**\n     * Returns the collection of rendering hints for the chart.\n     *\n     * @return The rendering hints for the chart (never <code>null</code>).\n     *\n     * @see #setRenderingHints(RenderingHints)\n     */\n    public RenderingHints getRenderingHints() {\n        return this.renderingHints;\n    }\n\n    /**\n     * Sets the rendering hints for the chart.  These will be added (using the\n     * Graphics2D.addRenderingHints() method) near the start of the\n     * JFreeChart.draw() method.\n     *\n     * @param renderingHints  the rendering hints (<code>null</code> not\n     *                        permitted).\n     *\n     * @see #getRenderingHints()\n     */\n    public void setRenderingHints(RenderingHints renderingHints) {\n        if (renderingHints == null) {\n            throw new NullPointerException(\"RenderingHints given are null\");\n        }\n        this.renderingHints = renderingHints;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a border is drawn around the\n     * outside of the chart.\n     *\n     * @return A boolean.\n     *\n     * @see #setBorderVisible(boolean)\n     */\n    public boolean isBorderVisible() {\n        return this.borderVisible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not a border is drawn around the\n     * outside of the chart.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isBorderVisible()\n     */\n    public void setBorderVisible(boolean visible) {\n        this.borderVisible = visible;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the stroke used to draw the chart border (if visible).\n     *\n     * @return The border stroke.\n     *\n     * @see #setBorderStroke(Stroke)\n     */\n    public Stroke getBorderStroke() {\n        return this.borderStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the chart border (if visible).\n     *\n     * @param stroke  the stroke.\n     *\n     * @see #getBorderStroke()\n     */\n    public void setBorderStroke(Stroke stroke) {\n        this.borderStroke = stroke;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the paint used to draw the chart border (if visible).\n     *\n     * @return The border paint.\n     *\n     * @see #setBorderPaint(Paint)\n     */\n    public Paint getBorderPaint() {\n        return this.borderPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the chart border (if visible).\n     *\n     * @param paint  the paint.\n     *\n     * @see #getBorderPaint()\n     */\n    public void setBorderPaint(Paint paint) {\n        this.borderPaint = paint;\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the padding between the chart border and the chart drawing area.\n     *\n     * @return The padding (never <code>null</code>).\n     *\n     * @see #setPadding(RectangleInsets)\n     */\n    public RectangleInsets getPadding() {\n        return this.padding;\n    }\n\n    /**\n     * Sets the padding between the chart border and the chart drawing area,\n     * and sends a {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @param padding  the padding (<code>null</code> not permitted).\n     *\n     * @see #getPadding()\n     */\n    public void setPadding(RectangleInsets padding) {\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'padding' argument.\");\n        }\n        this.padding = padding;\n        notifyListeners(new ChartChangeEvent(this));\n    }\n\n    /**\n     * Returns the main chart title.  Very often a chart will have just one\n     * title, so we make this case simple by providing accessor methods for\n     * the main title.  However, multiple titles are supported - see the\n     * {@link #addSubtitle(Title)} method.\n     *\n     * @return The chart title (possibly <code>null</code>).\n     *\n     * @see #setTitle(TextTitle)\n     */\n    public TextTitle getTitle() {\n        return this.title;\n    }\n\n    /**\n     * Sets the main title for the chart and sends a {@link ChartChangeEvent}\n     * to all registered listeners.  If you do not want a title for the\n     * chart, set it to <code>null</code>.  If you want more than one title on\n     * a chart, use the {@link #addSubtitle(Title)} method.\n     *\n     * @param title  the title (<code>null</code> permitted).\n     *\n     * @see #getTitle()\n     */\n    public void setTitle(TextTitle title) {\n        if (this.title != null) {\n            this.title.removeChangeListener(this);\n        }\n        this.title = title;\n        if (title != null) {\n            title.addChangeListener(this);\n        }\n        fireChartChanged();\n    }\n\n    /**\n     * Sets the chart title and sends a {@link ChartChangeEvent} to all\n     * registered listeners.  This is a convenience method that ends up calling\n     * the {@link #setTitle(TextTitle)} method.  If there is an existing title,\n     * its text is updated, otherwise a new title using the default font is\n     * added to the chart.  If <code>text</code> is <code>null</code> the chart\n     * title is set to <code>null</code>.\n     *\n     * @param text  the title text (<code>null</code> permitted).\n     *\n     * @see #getTitle()\n     */\n    public void setTitle(String text) {\n        if (text != null) {\n            if (this.title == null) {\n                setTitle(new TextTitle(text, JFreeChart.DEFAULT_TITLE_FONT));\n            }\n            else {\n                this.title.setText(text);\n            }\n        }\n        else {\n            setTitle((TextTitle) null);\n        }\n    }\n\n    /**\n     * Adds a legend to the plot and sends a {@link ChartChangeEvent} to all\n     * registered listeners.\n     *\n     * @param legend  the legend (<code>null</code> not permitted).\n     *\n     * @see #removeLegend()\n     */\n    public void addLegend(LegendTitle legend) {\n        addSubtitle(legend);\n    }\n\n    /**\n     * Returns the legend for the chart, if there is one.  Note that a chart\n     * can have more than one legend - this method returns the first.\n     *\n     * @return The legend (possibly <code>null</code>).\n     *\n     * @see #getLegend(int)\n     */\n    public LegendTitle getLegend() {\n        return getLegend(0);\n    }\n\n    /**\n     * Returns the nth legend for a chart, or <code>null</code>.\n     *\n     * @param index  the legend index (zero-based).\n     *\n     * @return The legend (possibly <code>null</code>).\n     *\n     * @see #addLegend(LegendTitle)\n     */\n    public LegendTitle getLegend(int index) {\n        int seen = 0;\n        Iterator iterator = this.subtitles.iterator();\n        while (iterator.hasNext()) {\n            Title subtitle = (Title) iterator.next();\n            if (subtitle instanceof LegendTitle) {\n                if (seen == index) {\n                    return (LegendTitle) subtitle;\n                }\n                else {\n                    seen++;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Removes the first legend in the chart and sends a\n     * {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @see #getLegend()\n     */\n    public void removeLegend() {\n        removeSubtitle(getLegend());\n    }\n\n    /**\n     * Returns the list of subtitles for the chart.\n     *\n     * @return The subtitle list (possibly empty, but never <code>null</code>).\n     *\n     * @see #setSubtitles(List)\n     */\n    public List getSubtitles() {\n        return new ArrayList(this.subtitles);\n    }\n\n    /**\n     * Sets the title list for the chart (completely replaces any existing\n     * titles) and sends a {@link ChartChangeEvent} to all registered\n     * listeners.\n     *\n     * @param subtitles  the new list of subtitles (<code>null</code> not\n     *                   permitted).\n     *\n     * @see #getSubtitles()\n     */\n    public void setSubtitles(List subtitles) {\n        if (subtitles == null) {\n            throw new NullPointerException(\"Null 'subtitles' argument.\");\n        }\n        setNotify(false);\n        clearSubtitles();\n        Iterator iterator = subtitles.iterator();\n        while (iterator.hasNext()) {\n            Title t = (Title) iterator.next();\n            if (t != null) {\n                addSubtitle(t);\n            }\n        }\n        setNotify(true);  // this fires a ChartChangeEvent\n    }\n\n    /**\n     * Returns the number of titles for the chart.\n     *\n     * @return The number of titles for the chart.\n     *\n     * @see #getSubtitles()\n     */\n    public int getSubtitleCount() {\n        return this.subtitles.size();\n    }\n\n    /**\n     * Returns a chart subtitle.\n     *\n     * @param index  the index of the chart subtitle (zero based).\n     *\n     * @return A chart subtitle.\n     *\n     * @see #addSubtitle(Title)\n     */\n    public Title getSubtitle(int index) {\n        if ((index < 0) || (index >= getSubtitleCount())) {\n            throw new IllegalArgumentException(\"Index out of range.\");\n        }\n        return (Title) this.subtitles.get(index);\n    }\n\n    /**\n     * Adds a chart subtitle, and notifies registered listeners that the chart\n     * has been modified.\n     *\n     * @param subtitle  the subtitle (<code>null</code> not permitted).\n     *\n     * @see #getSubtitle(int)\n     */\n    public void addSubtitle(Title subtitle) {\n        if (subtitle == null) {\n            throw new IllegalArgumentException(\"Null 'subtitle' argument.\");\n        }\n        this.subtitles.add(subtitle);\n        subtitle.addChangeListener(this);\n        fireChartChanged();\n    }\n\n    /**\n     * Adds a subtitle at a particular position in the subtitle list, and sends\n     * a {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @param index  the index (in the range 0 to {@link #getSubtitleCount()}).\n     * @param subtitle  the subtitle to add (<code>null</code> not permitted).\n     *\n     * @since 1.0.6\n     */\n    public void addSubtitle(int index, Title subtitle) {\n        if (index < 0 || index > getSubtitleCount()) {\n            throw new IllegalArgumentException(\n                    \"The 'index' argument is out of range.\");\n        }\n        if (subtitle == null) {\n            throw new IllegalArgumentException(\"Null 'subtitle' argument.\");\n        }\n        this.subtitles.add(index, subtitle);\n        subtitle.addChangeListener(this);\n        fireChartChanged();\n    }\n\n    /**\n     * Clears all subtitles from the chart and sends a {@link ChartChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #addSubtitle(Title)\n     */\n    public void clearSubtitles() {\n        Iterator iterator = this.subtitles.iterator();\n        while (iterator.hasNext()) {\n            Title t = (Title) iterator.next();\n            t.removeChangeListener(this);\n        }\n        this.subtitles.clear();\n        fireChartChanged();\n    }\n\n    /**\n     * Removes the specified subtitle and sends a {@link ChartChangeEvent} to\n     * all registered listeners.\n     *\n     * @param title  the title.\n     *\n     * @see #addSubtitle(Title)\n     */\n    public void removeSubtitle(Title title) {\n        this.subtitles.remove(title);\n        fireChartChanged();\n    }\n\n    /**\n     * Returns the plot for the chart.  The plot is a class responsible for\n     * coordinating the visual representation of the data, including the axes\n     * (if any).\n     *\n     * @return The plot.\n     */\n    public Plot getPlot() {\n        return this.plot;\n    }\n\n    /**\n     * Returns the plot cast as a {@link CategoryPlot}.\n     * <p>\n     * NOTE: if the plot is not an instance of {@link CategoryPlot}, then a\n     * <code>ClassCastException</code> is thrown.\n     *\n     * @return The plot.\n     *\n     * @see #getPlot()\n     */\n    public CategoryPlot getCategoryPlot() {\n        return (CategoryPlot) this.plot;\n    }\n\n    /**\n     * Returns the plot cast as an {@link XYPlot}.\n     * <p>\n     * NOTE: if the plot is not an instance of {@link XYPlot}, then a\n     * <code>ClassCastException</code> is thrown.\n     *\n     * @return The plot.\n     *\n     * @see #getPlot()\n     */\n    public XYPlot getXYPlot() {\n        return (XYPlot) this.plot;\n    }\n\n    /**\n     * Returns a flag that indicates whether or not anti-aliasing is used when\n     * the chart is drawn.\n     *\n     * @return The flag.\n     *\n     * @see #setAntiAlias(boolean)\n     */\n    public boolean getAntiAlias() {\n        Object val = this.renderingHints.get(RenderingHints.KEY_ANTIALIASING);\n        return RenderingHints.VALUE_ANTIALIAS_ON.equals(val);\n    }\n\n    /**\n     * Sets a flag that indicates whether or not anti-aliasing is used when the\n     * chart is drawn.\n     * <P>\n     * Anti-aliasing usually improves the appearance of charts, but is slower.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @see #getAntiAlias()\n     */\n    public void setAntiAlias(boolean flag) {\n\n        Object val = this.renderingHints.get(RenderingHints.KEY_ANTIALIASING);\n        if (val == null) {\n            val = RenderingHints.VALUE_ANTIALIAS_DEFAULT;\n        }\n        if (!flag && RenderingHints.VALUE_ANTIALIAS_OFF.equals(val)\n            || flag && RenderingHints.VALUE_ANTIALIAS_ON.equals(val)) {\n            // no change, do nothing\n            return;\n        }\n        if (flag) {\n            this.renderingHints.put(RenderingHints.KEY_ANTIALIASING,\n                                    RenderingHints.VALUE_ANTIALIAS_ON);\n        }\n        else {\n            this.renderingHints.put(RenderingHints.KEY_ANTIALIASING,\n                                    RenderingHints.VALUE_ANTIALIAS_OFF);\n        }\n        fireChartChanged();\n\n    }\n\n    /**\n     * Returns the current value stored in the rendering hints table for\n     * {@link RenderingHints#KEY_TEXT_ANTIALIASING}.\n     *\n     * @return The hint value (possibly <code>null</code>).\n     *\n     * @since 1.0.5\n     *\n     * @see #setTextAntiAlias(Object)\n     */\n    public Object getTextAntiAlias() {\n        return this.renderingHints.get(RenderingHints.KEY_TEXT_ANTIALIASING);\n    }\n\n    /**\n     * Sets the value in the rendering hints table for\n     * {@link RenderingHints#KEY_TEXT_ANTIALIASING} to either\n     * {@link RenderingHints#VALUE_TEXT_ANTIALIAS_ON} or\n     * {@link RenderingHints#VALUE_TEXT_ANTIALIAS_OFF}, then sends a\n     * {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @since 1.0.5\n     *\n     * @see #getTextAntiAlias()\n     * @see #setTextAntiAlias(Object)\n     */\n    public void setTextAntiAlias(boolean flag) {\n        if (flag) {\n            setTextAntiAlias(RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n        }\n        else {\n            setTextAntiAlias(RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);\n        }\n    }\n\n    /**\n     * Sets the value in the rendering hints table for\n     * {@link RenderingHints#KEY_TEXT_ANTIALIASING} and sends a\n     * {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @param val  the new value (<code>null</code> permitted).\n     *\n     * @since 1.0.5\n     *\n     * @see #getTextAntiAlias()\n     * @see #setTextAntiAlias(boolean)\n     */\n    public void setTextAntiAlias(Object val) {\n        this.renderingHints.put(RenderingHints.KEY_TEXT_ANTIALIASING, val);\n        notifyListeners(new ChartChangeEvent(this));\n    }\n\n    /**\n     * Returns the paint used for the chart background.\n     *\n     * @return The paint (possibly <code>null</code>).\n     *\n     * @see #setBackgroundPaint(Paint)\n     */\n    public Paint getBackgroundPaint() {\n        return this.backgroundPaint;\n    }\n\n    /**\n     * Sets the paint used to fill the chart background and sends a\n     * {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @see #getBackgroundPaint()\n     */\n    public void setBackgroundPaint(Paint paint) {\n\n        if (this.backgroundPaint != null) {\n            if (!this.backgroundPaint.equals(paint)) {\n                this.backgroundPaint = paint;\n                fireChartChanged();\n            }\n        }\n        else {\n            if (paint != null) {\n                this.backgroundPaint = paint;\n                fireChartChanged();\n            }\n        }\n\n    }\n\n    /**\n     * Returns the background image for the chart, or <code>null</code> if\n     * there is no image.\n     *\n     * @return The image (possibly <code>null</code>).\n     *\n     * @see #setBackgroundImage(Image)\n     */\n    public Image getBackgroundImage() {\n        return this.backgroundImage;\n    }\n\n    /**\n     * Sets the background image for the chart and sends a\n     * {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @param image  the image (<code>null</code> permitted).\n     *\n     * @see #getBackgroundImage()\n     */\n    public void setBackgroundImage(Image image) {\n\n        if (this.backgroundImage != null) {\n            if (!this.backgroundImage.equals(image)) {\n                this.backgroundImage = image;\n                fireChartChanged();\n            }\n        }\n        else {\n            if (image != null) {\n                this.backgroundImage = image;\n                fireChartChanged();\n            }\n        }\n\n    }\n\n    /**\n     * Returns the background image alignment. Alignment constants are defined\n     * in the <code>org.jfree.ui.Align</code> class in the JCommon class\n     * library.\n     *\n     * @return The alignment.\n     *\n     * @see #setBackgroundImageAlignment(int)\n     */\n    public int getBackgroundImageAlignment() {\n        return this.backgroundImageAlignment;\n    }\n\n    /**\n     * Sets the background alignment.  Alignment options are defined by the\n     * {@link org.jfree.ui.Align} class.\n     *\n     * @param alignment  the alignment.\n     *\n     * @see #getBackgroundImageAlignment()\n     */\n    public void setBackgroundImageAlignment(int alignment) {\n        if (this.backgroundImageAlignment != alignment) {\n            this.backgroundImageAlignment = alignment;\n            fireChartChanged();\n        }\n    }\n\n    /**\n     * Returns the alpha-transparency for the chart's background image.\n     *\n     * @return The alpha-transparency.\n     *\n     * @see #setBackgroundImageAlpha(float)\n     */\n    public float getBackgroundImageAlpha() {\n        return this.backgroundImageAlpha;\n    }\n\n    /**\n     * Sets the alpha-transparency for the chart's background image.\n     * Registered listeners are notified that the chart has been changed.\n     *\n     * @param alpha  the alpha value.\n     *\n     * @see #getBackgroundImageAlpha()\n     */\n    public void setBackgroundImageAlpha(float alpha) {\n\n        if (this.backgroundImageAlpha != alpha) {\n            this.backgroundImageAlpha = alpha;\n            fireChartChanged();\n        }\n\n    }\n\n    /**\n     * Returns a flag that controls whether or not change events are sent to\n     * registered listeners.\n     *\n     * @return A boolean.\n     *\n     * @see #setNotify(boolean)\n     */\n    public boolean isNotify() {\n        return this.notify;\n    }\n\n    /**\n     * Sets a flag that controls whether or not listeners receive\n     * {@link ChartChangeEvent} notifications.\n     *\n     * @param notify  a boolean.\n     *\n     * @see #isNotify()\n     */\n    public void setNotify(boolean notify) {\n        this.notify = notify;\n        // if the flag is being set to true, there may be queued up changes...\n        if (notify) {\n            notifyListeners(new ChartChangeEvent(this));\n        }\n    }\n\n    /**\n     * Draws the chart on a Java 2D graphics device (such as the screen or a\n     * printer).\n     * <P>\n     * This method is the focus of the entire JFreeChart library.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the chart should be drawn.\n     */\n    public void draw(Graphics2D g2, Rectangle2D area) {\n        draw(g2, area, null, null);\n    }\n\n    /**\n     * Draws the chart on a Java 2D graphics device (such as the screen or a\n     * printer).  This method is the focus of the entire JFreeChart library.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the chart should be drawn.\n     * @param info  records info about the drawing (null means collect no info).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, ChartRenderingInfo info) {\n        draw(g2, area, null, info);\n    }\n\n    /**\n     * Draws the chart on a Java 2D graphics device (such as the screen or a\n     * printer).\n     * <P>\n     * This method is the focus of the entire JFreeChart library.\n     *\n     * @param g2  the graphics device.\n     * @param chartArea  the area within which the chart should be drawn.\n     * @param anchor  the anchor point (in Java2D space) for the chart\n     *                (<code>null</code> permitted).\n     * @param info  records info about the drawing (null means collect no info).\n     */\n    public void draw(Graphics2D g2,\n                     Rectangle2D chartArea, Point2D anchor,\n                     ChartRenderingInfo info) {\n\n        notifyListeners(new ChartProgressEvent(this, this,\n                ChartProgressEvent.DRAWING_STARTED, 0));\n        \n        EntityCollection entities = null;\n        // record the chart area, if info is requested...\n        if (info != null) {\n            info.clear();\n            info.setChartArea(chartArea);\n            entities = info.getEntityCollection();\n        }\n        if (entities != null) {\n        \tentities.add(new JFreeChartEntity((Rectangle2D) chartArea.clone(),\n                    this));\n        }\n\n        // ensure no drawing occurs outside chart area...\n        Shape savedClip = g2.getClip();\n        g2.clip(chartArea);\n\n        g2.addRenderingHints(this.renderingHints);\n\n        // draw the chart background...\n        if (this.backgroundPaint != null) {\n            g2.setPaint(this.backgroundPaint);\n            g2.fill(chartArea);\n        }\n\n        if (this.backgroundImage != null) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    this.backgroundImageAlpha));\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0,\n                    this.backgroundImage.getWidth(null),\n                    this.backgroundImage.getHeight(null));\n            Align.align(dest, chartArea, this.backgroundImageAlignment);\n            g2.drawImage(this.backgroundImage, (int) dest.getX(),\n                    (int) dest.getY(), (int) dest.getWidth(),\n                    (int) dest.getHeight(), null);\n            g2.setComposite(originalComposite);\n        }\n\n        if (isBorderVisible()) {\n            Paint paint = getBorderPaint();\n            Stroke stroke = getBorderStroke();\n            if (paint != null && stroke != null) {\n                Rectangle2D borderArea = new Rectangle2D.Double(\n                        chartArea.getX(), chartArea.getY(),\n                        chartArea.getWidth() - 1.0, chartArea.getHeight()\n                        - 1.0);\n                g2.setPaint(paint);\n                g2.setStroke(stroke);\n                g2.draw(borderArea);\n            }\n        }\n\n        // draw the title and subtitles...\n        Rectangle2D nonTitleArea = new Rectangle2D.Double();\n        nonTitleArea.setRect(chartArea);\n        this.padding.trim(nonTitleArea);\n\n        if (this.title != null) {\n            EntityCollection e = this.title.drawTitle(this, g2, nonTitleArea,\n                    (entities != null));\n            if (e != null) {\n                entities.addAll(e);\n            }\n        }\n\n        Iterator iterator = this.subtitles.iterator();\n        while (iterator.hasNext()) {\n            Title currentTitle = (Title) iterator.next();\n            if (currentTitle.isVisible()) {\n                EntityCollection e = currentTitle.drawTitle(this, g2, nonTitleArea,\n                        (entities != null));\n                if (e != null) {\n                    entities.addAll(e);\n                }\n            }\n        }\n\n        Rectangle2D plotArea = nonTitleArea;\n\n        // draw the plot (axes and data visualisation)\n        PlotRenderingInfo plotInfo = null;\n        if (info != null) {\n            plotInfo = info.getPlotInfo();\n        }\n        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n\n        g2.setClip(savedClip);\n\n        notifyListeners(new ChartProgressEvent(this, this,\n                ChartProgressEvent.DRAWING_FINISHED, 100));\n    }\n\n    /**\n     * Creates a rectangle that is aligned to the frame.\n     *\n     * @param dimensions  the dimensions for the rectangle.\n     * @param frame  the frame to align to.\n     * @param hAlign  the horizontal alignment.\n     * @param vAlign  the vertical alignment.\n     *\n     * @return A rectangle.\n     */\n    public Rectangle2D createAlignedRectangle2D(Size2D dimensions,\n            Rectangle2D frame, HorizontalAlignment hAlign,\n            VerticalAlignment vAlign) {\n        double x = Double.NaN;\n        double y = Double.NaN;\n        if (hAlign == HorizontalAlignment.LEFT) {\n            x = frame.getX();\n        }\n        else if (hAlign == HorizontalAlignment.CENTER) {\n            x = frame.getCenterX() - (dimensions.width / 2.0);\n        }\n        else if (hAlign == HorizontalAlignment.RIGHT) {\n            x = frame.getMaxX() - dimensions.width;\n        }\n        if (vAlign == VerticalAlignment.TOP) {\n            y = frame.getY();\n        }\n        else if (vAlign == VerticalAlignment.CENTER) {\n            y = frame.getCenterY() - (dimensions.height / 2.0);\n        }\n        else if (vAlign == VerticalAlignment.BOTTOM) {\n            y = frame.getMaxY() - dimensions.height;\n        }\n\n        return new Rectangle2D.Double(x, y, dimensions.width,\n                dimensions.height);\n    }\n\n    /**\n     * Creates and returns a buffered image into which the chart has been drawn.\n     *\n     * @param width  the width.\n     * @param height  the height.\n     *\n     * @return A buffered image.\n     */\n    public BufferedImage createBufferedImage(int width, int height) {\n        return createBufferedImage(width, height, null);\n    }\n\n    /**\n     * Creates and returns a buffered image into which the chart has been drawn.\n     *\n     * @param width  the width.\n     * @param height  the height.\n     * @param info  carries back chart state information (<code>null</code>\n     *              permitted).\n     *\n     * @return A buffered image.\n     */\n    public BufferedImage createBufferedImage(int width, int height,\n                                             ChartRenderingInfo info) {\n        return createBufferedImage(width, height, BufferedImage.TYPE_INT_ARGB,\n                info);\n    }\n\n    /**\n     * Creates and returns a buffered image into which the chart has been drawn.\n     *\n     * @param width  the width.\n     * @param height  the height.\n     * @param imageType  the image type.\n     * @param info  carries back chart state information (<code>null</code>\n     *              permitted).\n     *\n     * @return A buffered image.\n     */\n    public BufferedImage createBufferedImage(int width, int height,\n                                             int imageType,\n                                             ChartRenderingInfo info) {\n        BufferedImage image = new BufferedImage(width, height, imageType);\n        Graphics2D g2 = image.createGraphics();\n        draw(g2, new Rectangle2D.Double(0, 0, width, height), null, info);\n        g2.dispose();\n        return image;\n    }\n\n    /**\n     * Creates and returns a buffered image into which the chart has been drawn.\n     *\n     * @param imageWidth  the image width.\n     * @param imageHeight  the image height.\n     * @param drawWidth  the width for drawing the chart (will be scaled to\n     *                   fit image).\n     * @param drawHeight  the height for drawing the chart (will be scaled to\n     *                    fit image).\n     * @param info  optional object for collection chart dimension and entity\n     *              information.\n     *\n     * @return A buffered image.\n     */\n    public BufferedImage createBufferedImage(int imageWidth,\n                                             int imageHeight,\n                                             double drawWidth,\n                                             double drawHeight,\n                                             ChartRenderingInfo info) {\n\n        BufferedImage image = new BufferedImage(imageWidth, imageHeight,\n                BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2 = image.createGraphics();\n        double scaleX = imageWidth / drawWidth;\n        double scaleY = imageHeight / drawHeight;\n        AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY);\n        g2.transform(st);\n        draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null,\n                info);\n        g2.dispose();\n        return image;\n\n    }\n\n    /**\n     * Handles a 'click' on the chart.  JFreeChart is not a UI component, so\n     * some other object (for example, {@link ChartPanel}) needs to capture\n     * the click event and pass it onto the JFreeChart object.\n     * If you are not using JFreeChart in a client application, then this\n     * method is not required.\n     *\n     * @param x  x-coordinate of the click (in Java2D space).\n     * @param y  y-coordinate of the click (in Java2D space).\n     * @param info  contains chart dimension and entity information\n     *              (<code>null</code> not permitted).\n     */\n    public void handleClick(int x, int y, ChartRenderingInfo info) {\n\n        // pass the click on to the plot...\n        // rely on the plot to post a plot change event and redraw the chart...\n        this.plot.handleClick(x, y, info.getPlotInfo());\n\n    }\n\n    /**\n     * Registers an object for notification of changes to the chart.\n     *\n     * @param listener  the listener (<code>null</code> not permitted).\n     *\n     * @see #removeChangeListener(ChartChangeListener)\n     */\n    public void addChangeListener(ChartChangeListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"Null 'listener' argument.\");\n        }\n        this.changeListeners.add(ChartChangeListener.class, listener);\n    }\n\n    /**\n     * Deregisters an object for notification of changes to the chart.\n     *\n     * @param listener  the listener (<code>null</code> not permitted)\n     *\n     * @see #addChangeListener(ChartChangeListener)\n     */\n    public void removeChangeListener(ChartChangeListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"Null 'listener' argument.\");\n        }\n        this.changeListeners.remove(ChartChangeListener.class, listener);\n    }\n\n    /**\n     * Sends a default {@link ChartChangeEvent} to all registered listeners.\n     * <P>\n     * This method is for convenience only.\n     */\n    public void fireChartChanged() {\n        ChartChangeEvent event = new ChartChangeEvent(this);\n        notifyListeners(event);\n    }\n\n    /**\n     * Sends a {@link ChartChangeEvent} to all registered listeners.\n     *\n     * @param event  information about the event that triggered the\n     *               notification.\n     */\n    protected void notifyListeners(ChartChangeEvent event) {\n        if (this.notify) {\n            Object[] listeners = this.changeListeners.getListenerList();\n            for (int i = listeners.length - 2; i >= 0; i -= 2) {\n                if (listeners[i] == ChartChangeListener.class) {\n                    ((ChartChangeListener) listeners[i + 1]).chartChanged(\n                            event);\n                }\n            }\n        }\n    }\n\n    /**\n     * Registers an object for notification of progress events relating to the\n     * chart.\n     *\n     * @param listener  the object being registered.\n     *\n     * @see #removeProgressListener(ChartProgressListener)\n     */\n    public void addProgressListener(ChartProgressListener listener) {\n        this.progressListeners.add(ChartProgressListener.class, listener);\n    }\n\n    /**\n     * Deregisters an object for notification of changes to the chart.\n     *\n     * @param listener  the object being deregistered.\n     *\n     * @see #addProgressListener(ChartProgressListener)\n     */\n    public void removeProgressListener(ChartProgressListener listener) {\n        this.progressListeners.remove(ChartProgressListener.class, listener);\n    }\n\n    /**\n     * Sends a {@link ChartProgressEvent} to all registered listeners.\n     *\n     * @param event  information about the event that triggered the\n     *               notification.\n     */\n    protected void notifyListeners(ChartProgressEvent event) {\n\n        Object[] listeners = this.progressListeners.getListenerList();\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == ChartProgressListener.class) {\n                ((ChartProgressListener) listeners[i + 1]).chartProgress(event);\n            }\n        }\n\n    }\n\n    /**\n     * Receives notification that a chart title has changed, and passes this\n     * on to registered listeners.\n     *\n     * @param event  information about the chart title change.\n     */\n    public void titleChanged(TitleChangeEvent event) {\n        event.setChart(this);\n        notifyListeners(event);\n    }\n\n    /**\n     * Receives notification that the plot has changed, and passes this on to\n     * registered listeners.\n     *\n     * @param event  information about the plot change.\n     */\n    public void plotChanged(PlotChangeEvent event) {\n        event.setChart(this);\n        notifyListeners(event);\n    }\n\n    /**\n     * Tests this chart for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof JFreeChart)) {\n            return false;\n        }\n        JFreeChart that = (JFreeChart) obj;\n        if (!this.renderingHints.equals(that.renderingHints)) {\n            return false;\n        }\n        if (this.borderVisible != that.borderVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.borderStroke, that.borderStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.borderPaint, that.borderPaint)) {\n            return false;\n        }\n        if (!this.padding.equals(that.padding)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.title, that.title)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.subtitles, that.subtitles)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.plot, that.plot)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(\n            this.backgroundPaint, that.backgroundPaint\n        )) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundImage,\n                that.backgroundImage)) {\n            return false;\n        }\n        if (this.backgroundImageAlignment != that.backgroundImageAlignment) {\n            return false;\n        }\n        if (this.backgroundImageAlpha != that.backgroundImageAlpha) {\n            return false;\n        }\n        if (this.notify != that.notify) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.borderStroke, stream);\n        SerialUtilities.writePaint(this.borderPaint, stream);\n        SerialUtilities.writePaint(this.backgroundPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.borderStroke = SerialUtilities.readStroke(stream);\n        this.borderPaint = SerialUtilities.readPaint(stream);\n        this.backgroundPaint = SerialUtilities.readPaint(stream);\n        this.progressListeners = new EventListenerList();\n        this.changeListeners = new EventListenerList();\n        this.renderingHints = new RenderingHints(\n                RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        // register as a listener with sub-components...\n        if (this.title != null) {\n            this.title.addChangeListener(this);\n        }\n\n        for (int i = 0; i < getSubtitleCount(); i++) {\n            getSubtitle(i).addChangeListener(this);\n        }\n        this.plot.addChangeListener(this);\n    }\n\n    /**\n     * Prints information about JFreeChart to standard output.\n     *\n     * @param args  no arguments are honored.\n     */\n    public static void main(String[] args) {\n        System.out.println(JFreeChart.INFO.toString());\n    }\n\n    /**\n     * Clones the object, and takes care of listeners.\n     * Note: caller shall register its own listeners on cloned graph.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if the chart is not cloneable.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        JFreeChart chart = (JFreeChart) super.clone();\n\n        chart.renderingHints = (RenderingHints) this.renderingHints.clone();\n        // private boolean borderVisible;\n        // private transient Stroke borderStroke;\n        // private transient Paint borderPaint;\n\n        if (this.title != null) {\n            chart.title = (TextTitle) this.title.clone();\n            chart.title.addChangeListener(chart);\n        }\n\n        chart.subtitles = new ArrayList();\n        for (int i = 0; i < getSubtitleCount(); i++) {\n            Title subtitle = (Title) getSubtitle(i).clone();\n            chart.subtitles.add(subtitle);\n            subtitle.addChangeListener(chart);\n        }\n\n        if (this.plot != null) {\n            chart.plot = (Plot) this.plot.clone();\n            chart.plot.addChangeListener(chart);\n        }\n\n        chart.progressListeners = new EventListenerList();\n        chart.changeListeners = new EventListenerList();\n        return chart;\n    }\n\n\t/**\n\t * Replaces the dataset and checks that it has changed as expected.\n\t * @param stackedBarChartTests TODO\n\t */\n\tpublic void testReplaceDataset(StackedBarChartTests stackedBarChartTests) {\n\t\n\t    // create a dataset...\n\t    Number[][] data = new Integer[][]\n\t        {{new Integer(-30), new Integer(-20)},\n\t         {new Integer(-10), new Integer(10)},\n\t         {new Integer(20), new Integer(30)}};\n\t\n\t    CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\",\n\t            \"C\", data);\n\t\n\t    LocalListener l = new LocalListener();\n\t    addChangeListener(l);\n\t    CategoryPlot plot = (CategoryPlot) getPlot();\n\t    plot.setDataset(newData);\n\t    Assert.assertEquals(true, l.flag);\n\t    ValueAxis axis = plot.getRangeAxis();\n\t    Range range = axis.getRange();\n\t    Assert.assertTrue(\"Expecting the lower bound of the range to be around -30: \"\n\t                + range.getLowerBound(), range.getLowerBound() <= -30);\n\t    Assert.assertTrue(\"Expecting the upper bound of the range to be around 30: \"\n\t               + range.getUpperBound(), range.getUpperBound() >= 30);\n\t\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 4,
                "candidates": [
                    {
                        "lineStart": 1332,
                        "lineEnd": 1364,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.Plot\nRationale: The createBufferedImage method is responsible for rendering a chart into a BufferedImage, which is closely related to the functionality of a Plot class that typically handles the drawing and rendering of charts.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1245,
                        "lineEnd": 1281,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.Plot\nRationale: The createAlignedRectangle2D method is related to positioning graphical elements, which is a core responsibility of the Plot class. It deals with alignment and dimensions, making it more suitable for the Plot class that likely handles rendering and layout of graphical components.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1366,
                        "lineEnd": 1384,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.Plot\nRationale: The handleClick method directly interacts with the plot to process click events, making it more appropriate for the Plot class, which is responsible for handling such interactions.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1656,
                        "lineEnd": 1683,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.Plot\nRationale: The method testReplaceDataset is primarily concerned with testing the behavior of a dataset within a plot, specifically a CategoryPlot. It manipulates the dataset and checks the plot's response to changes, making it more appropriate for the Plot class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 11743
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createAlignedRectangle2D",
                            "method_signature": "public Rectangle2D createAlignedRectangle2D(Size2D dimensions, Rectangle2D frame, HorizontalAlignment hAlign, VerticalAlignment vAlign)",
                            "target_class": "RectangleUtils",
                            "rationale": "The method createAlignedRectangle2D is responsible for creating aligned rectangles, which is a utility function that does not directly relate to the JFreeChart class's primary responsibility of chart rendering. Moving it to a utility class like RectangleUtils would improve separation of concerns."
                        },
                        {
                            "method_name": "createBufferedImage",
                            "method_signature": "public BufferedImage createBufferedImage(int width, int height)",
                            "target_class": "ImageUtils",
                            "rationale": "The createBufferedImage method is focused on image creation, which is a utility function that can be better placed in a dedicated utility class like ImageUtils, enhancing the clarity and maintainability of the JFreeChart class."
                        },
                        {
                            "method_name": "handleClick",
                            "method_signature": "public void handleClick(int x, int y, ChartRenderingInfo info)",
                            "target_class": "ChartInteractionHandler",
                            "rationale": "The handleClick method deals with user interaction, which is a separate concern from the chart rendering logic. Moving it to a ChartInteractionHandler class would help in organizing the code related to user interactions."
                        },
                        {
                            "method_name": "testReplaceDataset",
                            "method_signature": "public void testReplaceDataset(StackedBarChartTests stackedBarChartTests)",
                            "target_class": "ChartTests",
                            "rationale": "The testReplaceDataset method is a test case and should be moved to a dedicated test class like ChartTests to separate testing logic from the main chart functionality, improving code organization."
                        }
                    ],
                    "llm_response_time": 4914
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "createAlignedRectangle2D",
                            "method_signature": "public Rectangle2D createAlignedRectangle2D(Size2D dimensions, Rectangle2D frame, HorizontalAlignment hAlign, VerticalAlignment vAlign)",
                            "target_class": "RectangleUtils",
                            "rationale": "The method createAlignedRectangle2D is a utility function for creating aligned rectangles and does not directly relate to the charting functionality of JFreeChart. It would be more appropriate in a utility class dedicated to geometric operations."
                        },
                        {
                            "method_name": "testReplaceDataset",
                            "method_signature": "public void testReplaceDataset(StackedBarChartTests stackedBarChartTests)",
                            "target_class": "ChartTestSuite",
                            "rationale": "The testReplaceDataset method is a test case and should be moved to a dedicated test class. This separation will help maintain a clear distinction between production code and test code."
                        }
                    ],
                    "llm_response_time": 2759
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "createAlignedRectangle2D",
                            "method_signature": "public Rectangle2D createAlignedRectangle2D(Size2D dimensions, Rectangle2D frame, HorizontalAlignment hAlign, VerticalAlignment vAlign)",
                            "target_class": "RectangleUtils",
                            "rationale": "The method createAlignedRectangle2D is responsible for creating aligned rectangles based on given dimensions and alignment parameters. This functionality is more suited to a utility class focused on geometric calculations, such as RectangleUtils, rather than being part of the JFreeChart class."
                        },
                        {
                            "method_name": "testReplaceDataset",
                            "method_signature": "public void testReplaceDataset(StackedBarChartTests stackedBarChartTests)",
                            "target_class": "ChartTest",
                            "rationale": "The method testReplaceDataset is a test method that validates the behavior of the chart when the dataset is replaced. This method should be moved to a dedicated test class, such as ChartTest, to separate testing logic from the main chart implementation."
                        }
                    ],
                    "llm_response_time": 2974
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createAlignedRectangle2D",
                            "method_signature": "public Rectangle2D createAlignedRectangle2D(Size2D dimensions, Rectangle2D frame, HorizontalAlignment hAlign, VerticalAlignment vAlign)",
                            "target_class": "RectangleUtils",
                            "rationale": "The method createAlignedRectangle2D is responsible for creating aligned rectangles, which is a utility function that does not directly relate to the JFreeChart class's primary responsibility of chart rendering. Moving it to a utility class like RectangleUtils would improve separation of concerns."
                        },
                        {
                            "method_name": "createBufferedImage",
                            "method_signature": "public BufferedImage createBufferedImage(int width, int height)",
                            "target_class": "ImageUtils",
                            "rationale": "The createBufferedImage method is focused on image creation, which is a utility function that can be better placed in a dedicated utility class like ImageUtils, enhancing the clarity and maintainability of the JFreeChart class."
                        },
                        {
                            "method_name": "handleClick",
                            "method_signature": "public void handleClick(int x, int y, ChartRenderingInfo info)",
                            "target_class": "ChartInteractionHandler",
                            "rationale": "The handleClick method deals with user interaction, which is a separate concern from the chart rendering logic. Moving it to a ChartInteractionHandler class would help in organizing the code related to user interactions."
                        },
                        {
                            "method_name": "testReplaceDataset",
                            "method_signature": "public void testReplaceDataset(StackedBarChartTests stackedBarChartTests)",
                            "target_class": "ChartTests",
                            "rationale": "The testReplaceDataset method is a test case and should be moved to a dedicated test class like ChartTests to separate testing logic from the main chart functionality, improving code organization."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "createBufferedImage",
                    "createAlignedRectangle2D",
                    "handleClick",
                    "testReplaceDataset"
                ],
                "llm_response_time": 1008
            },
            "targetClassMap": {
                "createBufferedImage": {
                    "target_classes": [
                        {
                            "class_name": "ChartRenderingInfo",
                            "similarity_score": 0.6909103704265795
                        },
                        {
                            "class_name": "TextTitle",
                            "similarity_score": 0.6766883082345493
                        },
                        {
                            "class_name": "Plot",
                            "similarity_score": 0.7073586514729867
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Plot",
                        "ChartRenderingInfo",
                        "TextTitle"
                    ],
                    "llm_response_time": 1583,
                    "similarity_computation_time": 7,
                    "similarity_metric": "cosine"
                },
                "createAlignedRectangle2D": {
                    "target_classes": [
                        {
                            "class_name": "TextTitle",
                            "similarity_score": 0.7644916269613923
                        },
                        {
                            "class_name": "Plot",
                            "similarity_score": 0.6965578955522201
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Plot",
                        "TextTitle"
                    ],
                    "llm_response_time": 1726,
                    "similarity_computation_time": 7,
                    "similarity_metric": "cosine"
                },
                "handleClick": {
                    "target_classes": [
                        {
                            "class_name": "Plot",
                            "similarity_score": 0.711858729891551
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Plot"
                    ],
                    "llm_response_time": 842,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "testReplaceDataset": {
                    "target_classes": [
                        {
                            "class_name": "TextTitle",
                            "similarity_score": 0.48219281988889223
                        },
                        {
                            "class_name": "Plot",
                            "similarity_score": 0.448666002310252
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Plot",
                        "TextTitle"
                    ],
                    "llm_response_time": 1193,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.LegendItem::createLegendItemBlock(LegendItem):Block need move org.jfree.chart.title.LegendTitle",
        "class_name": "org.jfree.chart.LegendItem",
        "telemetry": {
            "id": "fd2d9709-9b37-48c3-983b-c56cf985c02a",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1016,
                "lineStart": 98,
                "lineEnd": 1113,
                "bodyLineStart": 98,
                "language": "java",
                "sourceCode": "/**\n * A temporary storage object for recording the properties of a legend item,\n * without any consideration for layout issues.\n */\npublic class LegendItem implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -797214582948827144L;\n\n    /**\n     * The dataset.\n     *\n     * @since 1.0.6\n     */\n    private Dataset dataset;\n\n    /**\n     * The series key.\n     *\n     * @since 1.0.6\n     */\n    private Comparable seriesKey;\n\n    /** The dataset index. */\n    private int datasetIndex;\n\n    /** The series index. */\n    private int series;\n\n    /** The label. */\n    private String label;\n\n    /**\n     * The label font (<code>null</code> is permitted).\n     *\n     * @since 1.0.11\n     */\n    private Font labelFont;\n\n    /**\n     * The label paint (<code>null</code> is permitted).\n     *\n     * @since 1.0.11\n     */\n    private transient Paint labelPaint;\n\n    /** The attributed label (if null, fall back to the regular label). */\n    private transient AttributedString attributedLabel;\n\n    /**\n     * The description (not currently used - could be displayed as a tool tip).\n     */\n    private String description;\n\n    /** The tool tip text. */\n    private String toolTipText;\n\n    /** The url text. */\n    private String urlText;\n\n    /** A flag that controls whether or not the shape is visible. */\n    private boolean shapeVisible;\n\n    /** The shape. */\n    private transient Shape shape;\n\n    /** A flag that controls whether or not the shape is filled. */\n    private boolean shapeFilled;\n\n    /** The paint. */\n    private transient Paint fillPaint;\n\n    /**\n     * A gradient paint transformer.\n     *\n     * @since 1.0.4\n     */\n    private GradientPaintTransformer fillPaintTransformer;\n\n    /** A flag that controls whether or not the shape outline is visible. */\n    private boolean shapeOutlineVisible;\n\n    /** The outline paint. */\n    private transient Paint outlinePaint;\n\n    /** The outline stroke. */\n    private transient Stroke outlineStroke;\n\n    /** A flag that controls whether or not the line is visible. */\n    private boolean lineVisible;\n\n    /** The line. */\n    private transient Shape line;\n\n    /** The stroke. */\n    private transient Stroke lineStroke;\n\n    /** The line paint. */\n    private transient Paint linePaint;\n\n    /**\n     * The shape must be non-null for a LegendItem - if no shape is required,\n     * use this.\n     */\n    private static final Shape UNUSED_SHAPE = new Line2D.Float();\n\n    /**\n     * The stroke must be non-null for a LegendItem - if no stroke is required,\n     * use this.\n     */\n    private static final Stroke UNUSED_STROKE = new BasicStroke(0.0f);\n\n    /**\n     * Creates a legend item with the specified label.  The remaining\n     * attributes take default values.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     *\n     * @since 1.0.10\n     */\n    public LegendItem(String label) {\n        this(label, Color.black);\n    }\n\n    /**\n     * Creates a legend item with the specified label and fill paint.  The\n     * remaining attributes take default values.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @since 1.0.12\n     */\n    public LegendItem(String label, Paint paint) {\n        this(label, null, null, null, new Rectangle2D.Double(-4.0, -4.0, 8.0,\n                8.0), paint);\n    }\n\n    /**\n     * Creates a legend item with a filled shape.  The shape is not outlined,\n     * and no line is visible.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     * @param description  the description (<code>null</code> permitted).\n     * @param toolTipText  the tool tip text (<code>null</code> permitted).\n     * @param urlText  the URL text (<code>null</code> permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param fillPaint  the paint used to fill the shape (<code>null</code>\n     *                   not permitted).\n     */\n    public LegendItem(String label, String description,\n                      String toolTipText, String urlText,\n                      Shape shape, Paint fillPaint) {\n\n        this(label, description, toolTipText, urlText,\n                /* shape visible = */ true, shape,\n                /* shape filled = */ true, fillPaint,\n                /* shape outlined */ false, Color.black, UNUSED_STROKE,\n                /* line visible */ false, UNUSED_SHAPE, UNUSED_STROKE,\n                Color.black);\n\n    }\n\n    /**\n     * Creates a legend item with a filled and outlined shape.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     * @param description  the description (<code>null</code> permitted).\n     * @param toolTipText  the tool tip text (<code>null</code> permitted).\n     * @param urlText  the URL text (<code>null</code> permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param fillPaint  the paint used to fill the shape (<code>null</code>\n     *                   not permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> not\n     *                       permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> not\n     *                      permitted).\n     */\n    public LegendItem(String label, String description,\n                      String toolTipText, String urlText,\n                      Shape shape, Paint fillPaint,\n                      Stroke outlineStroke, Paint outlinePaint) {\n\n        this(label, description, toolTipText, urlText,\n                /* shape visible = */ true, shape,\n                /* shape filled = */ true, fillPaint,\n                /* shape outlined = */ true, outlinePaint, outlineStroke,\n                /* line visible */ false, UNUSED_SHAPE, UNUSED_STROKE,\n                Color.black);\n\n    }\n\n    /**\n     * Creates a legend item using a line.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     * @param description  the description (<code>null</code> permitted).\n     * @param toolTipText  the tool tip text (<code>null</code> permitted).\n     * @param urlText  the URL text (<code>null</code> permitted).\n     * @param line  the line (<code>null</code> not permitted).\n     * @param lineStroke  the line stroke (<code>null</code> not permitted).\n     * @param linePaint  the line paint (<code>null</code> not permitted).\n     */\n    public LegendItem(String label, String description,\n                      String toolTipText, String urlText,\n                      Shape line, Stroke lineStroke, Paint linePaint) {\n\n        this(label, description, toolTipText, urlText,\n                /* shape visible = */ false, UNUSED_SHAPE,\n                /* shape filled = */ false, Color.black,\n                /* shape outlined = */ false, Color.black, UNUSED_STROKE,\n                /* line visible = */ true, line, lineStroke, linePaint);\n    }\n\n    /**\n     * Creates a new legend item.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     * @param description  the description (not currently used,\n     *        <code>null</code> permitted).\n     * @param toolTipText  the tool tip text (<code>null</code> permitted).\n     * @param urlText  the URL text (<code>null</code> permitted).\n     * @param shapeVisible  a flag that controls whether or not the shape is\n     *                      displayed.\n     * @param shape  the shape (<code>null</code> permitted).\n     * @param shapeFilled  a flag that controls whether or not the shape is\n     *                     filled.\n     * @param fillPaint  the fill paint (<code>null</code> not permitted).\n     * @param shapeOutlineVisible  a flag that controls whether or not the\n     *                             shape is outlined.\n     * @param outlinePaint  the outline paint (<code>null</code> not permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> not\n     *                       permitted).\n     * @param lineVisible  a flag that controls whether or not the line is\n     *                     visible.\n     * @param line  the line.\n     * @param lineStroke  the stroke (<code>null</code> not permitted).\n     * @param linePaint  the line paint (<code>null</code> not permitted).\n     */\n    public LegendItem(String label, String description,\n                      String toolTipText, String urlText,\n                      boolean shapeVisible, Shape shape,\n                      boolean shapeFilled, Paint fillPaint,\n                      boolean shapeOutlineVisible, Paint outlinePaint,\n                      Stroke outlineStroke,\n                      boolean lineVisible, Shape line,\n                      Stroke lineStroke, Paint linePaint) {\n\n        if (label == null) {\n            throw new IllegalArgumentException(\"Null 'label' argument.\");\n        }\n        if (fillPaint == null) {\n            throw new IllegalArgumentException(\"Null 'fillPaint' argument.\");\n        }\n        if (lineStroke == null) {\n            throw new IllegalArgumentException(\"Null 'lineStroke' argument.\");\n        }\n        if (outlinePaint == null) {\n            throw new IllegalArgumentException(\"Null 'outlinePaint' argument.\");\n        }\n        if (outlineStroke == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'outlineStroke' argument.\");\n        }\n        this.label = label;\n        this.labelPaint = null;\n        this.attributedLabel = null;\n        this.description = description;\n        this.shapeVisible = shapeVisible;\n        this.shape = shape;\n        this.shapeFilled = shapeFilled;\n        this.fillPaint = fillPaint;\n        this.fillPaintTransformer = new StandardGradientPaintTransformer();\n        this.shapeOutlineVisible = shapeOutlineVisible;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.lineVisible = lineVisible;\n        this.line = line;\n        this.lineStroke = lineStroke;\n        this.linePaint = linePaint;\n        this.toolTipText = toolTipText;\n        this.urlText = urlText;\n    }\n\n    /**\n     * Creates a legend item with a filled shape.  The shape is not outlined,\n     * and no line is visible.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     * @param description  the description (<code>null</code> permitted).\n     * @param toolTipText  the tool tip text (<code>null</code> permitted).\n     * @param urlText  the URL text (<code>null</code> permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param fillPaint  the paint used to fill the shape (<code>null</code>\n     *                   not permitted).\n     */\n    public LegendItem(AttributedString label, String description,\n                      String toolTipText, String urlText,\n                      Shape shape, Paint fillPaint) {\n\n        this(label, description, toolTipText, urlText,\n                /* shape visible = */ true, shape,\n                /* shape filled = */ true, fillPaint,\n                /* shape outlined = */ false, Color.black, UNUSED_STROKE,\n                /* line visible = */ false, UNUSED_SHAPE, UNUSED_STROKE,\n                Color.black);\n\n    }\n\n    /**\n     * Creates a legend item with a filled and outlined shape.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     * @param description  the description (<code>null</code> permitted).\n     * @param toolTipText  the tool tip text (<code>null</code> permitted).\n     * @param urlText  the URL text (<code>null</code> permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param fillPaint  the paint used to fill the shape (<code>null</code>\n     *                   not permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> not\n     *                       permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> not\n     *                      permitted).\n     */\n    public LegendItem(AttributedString label, String description,\n                      String toolTipText, String urlText,\n                      Shape shape, Paint fillPaint,\n                      Stroke outlineStroke, Paint outlinePaint) {\n\n        this(label, description, toolTipText, urlText,\n                /* shape visible = */ true, shape,\n                /* shape filled = */ true, fillPaint,\n                /* shape outlined = */ true, outlinePaint, outlineStroke,\n                /* line visible = */ false, UNUSED_SHAPE, UNUSED_STROKE,\n                Color.black);\n    }\n\n    /**\n     * Creates a legend item using a line.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     * @param description  the description (<code>null</code> permitted).\n     * @param toolTipText  the tool tip text (<code>null</code> permitted).\n     * @param urlText  the URL text (<code>null</code> permitted).\n     * @param line  the line (<code>null</code> not permitted).\n     * @param lineStroke  the line stroke (<code>null</code> not permitted).\n     * @param linePaint  the line paint (<code>null</code> not permitted).\n     */\n    public LegendItem(AttributedString label, String description,\n                      String toolTipText, String urlText,\n                      Shape line, Stroke lineStroke, Paint linePaint) {\n\n        this(label, description, toolTipText, urlText,\n                /* shape visible = */ false, UNUSED_SHAPE,\n                /* shape filled = */ false, Color.black,\n                /* shape outlined = */ false, Color.black, UNUSED_STROKE,\n                /* line visible = */ true, line, lineStroke, linePaint);\n    }\n\n    /**\n     * Creates a new legend item.\n     *\n     * @param label  the label (<code>null</code> not permitted).\n     * @param description  the description (not currently used,\n     *        <code>null</code> permitted).\n     * @param toolTipText  the tool tip text (<code>null</code> permitted).\n     * @param urlText  the URL text (<code>null</code> permitted).\n     * @param shapeVisible  a flag that controls whether or not the shape is\n     *                      displayed.\n     * @param shape  the shape (<code>null</code> permitted).\n     * @param shapeFilled  a flag that controls whether or not the shape is\n     *                     filled.\n     * @param fillPaint  the fill paint (<code>null</code> not permitted).\n     * @param shapeOutlineVisible  a flag that controls whether or not the\n     *                             shape is outlined.\n     * @param outlinePaint  the outline paint (<code>null</code> not permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> not\n     *                       permitted).\n     * @param lineVisible  a flag that controls whether or not the line is\n     *                     visible.\n     * @param line  the line (<code>null</code> not permitted).\n     * @param lineStroke  the stroke (<code>null</code> not permitted).\n     * @param linePaint  the line paint (<code>null</code> not permitted).\n     */\n    public LegendItem(AttributedString label, String description,\n                      String toolTipText, String urlText,\n                      boolean shapeVisible, Shape shape,\n                      boolean shapeFilled, Paint fillPaint,\n                      boolean shapeOutlineVisible, Paint outlinePaint,\n                      Stroke outlineStroke,\n                      boolean lineVisible, Shape line, Stroke lineStroke,\n                      Paint linePaint) {\n\n        if (label == null) {\n            throw new IllegalArgumentException(\"Null 'label' argument.\");\n        }\n        if (fillPaint == null) {\n            throw new IllegalArgumentException(\"Null 'fillPaint' argument.\");\n        }\n        if (lineStroke == null) {\n            throw new IllegalArgumentException(\"Null 'lineStroke' argument.\");\n        }\n        if (line == null) {\n            throw new IllegalArgumentException(\"Null 'line' argument.\");\n        }\n        if (linePaint == null) {\n            throw new IllegalArgumentException(\"Null 'linePaint' argument.\");\n        }\n        if (outlinePaint == null) {\n            throw new IllegalArgumentException(\"Null 'outlinePaint' argument.\");\n        }\n        if (outlineStroke == null) {\n            throw new IllegalArgumentException(\n                \"Null 'outlineStroke' argument.\");\n        }\n        this.label = characterIteratorToString(label.getIterator());\n        this.attributedLabel = label;\n        this.description = description;\n        this.shapeVisible = shapeVisible;\n        this.shape = shape;\n        this.shapeFilled = shapeFilled;\n        this.fillPaint = fillPaint;\n        this.fillPaintTransformer = new StandardGradientPaintTransformer();\n        this.shapeOutlineVisible = shapeOutlineVisible;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.lineVisible = lineVisible;\n        this.line = line;\n        this.lineStroke = lineStroke;\n        this.linePaint = linePaint;\n        this.toolTipText = toolTipText;\n        this.urlText = urlText;\n    }\n\n    /**\n     * Returns a string containing the characters from the given iterator.\n     *\n     * @param iterator  the iterator (<code>null</code> not permitted).\n     *\n     * @return A string.\n     */\n    private String characterIteratorToString(CharacterIterator iterator) {\n        int endIndex = iterator.getEndIndex();\n        int beginIndex = iterator.getBeginIndex();\n        int count = endIndex - beginIndex;\n        if (count <= 0) {\n            return \"\";\n        }\n        char[] chars = new char[count];\n        int i = 0;\n        char c = iterator.first();\n        while (c != CharacterIterator.DONE) {\n            chars[i] = c;\n            i++;\n            c = iterator.next();\n        }\n        return new String(chars);\n    }\n\n    /**\n     * Returns the dataset.\n     *\n     * @return The dataset.\n     *\n     * @since 1.0.6\n     *\n     * @see #setDatasetIndex(int)\n     */\n    public Dataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset.\n     *\n     * @param dataset  the dataset.\n     *\n     * @since 1.0.6\n     */\n    public void setDataset(Dataset dataset) {\n        this.dataset = dataset;\n    }\n\n    /**\n     * Returns the dataset index for this legend item.\n     *\n     * @return The dataset index.\n     *\n     * @since 1.0.2\n     *\n     * @see #setDatasetIndex(int)\n     * @see #getDataset()\n     */\n    public int getDatasetIndex() {\n        return this.datasetIndex;\n    }\n\n    /**\n     * Sets the dataset index for this legend item.\n     *\n     * @param index  the index.\n     *\n     * @since 1.0.2\n     *\n     * @see #getDatasetIndex()\n     */\n    public void setDatasetIndex(int index) {\n        this.datasetIndex = index;\n    }\n\n    /**\n     * Returns the series key.\n     *\n     * @return The series key.\n     *\n     * @since 1.0.6\n     *\n     * @see #setSeriesKey(Comparable)\n     */\n    public Comparable getSeriesKey() {\n        return this.seriesKey;\n    }\n\n    /**\n     * Sets the series key.\n     *\n     * @param key  the series key.\n     *\n     * @since 1.0.6\n     */\n    public void setSeriesKey(Comparable key) {\n        this.seriesKey = key;\n    }\n\n    /**\n     * Returns the series index for this legend item.\n     *\n     * @return The series index.\n     *\n     * @since 1.0.2\n     */\n    public int getSeriesIndex() {\n        return this.series;\n    }\n\n    /**\n     * Sets the series index for this legend item.\n     *\n     * @param index  the index.\n     *\n     * @since 1.0.2\n     */\n    public void setSeriesIndex(int index) {\n        this.series = index;\n    }\n\n    /**\n     * Returns the label.\n     *\n     * @return The label (never <code>null</code>).\n     */\n    public String getLabel() {\n        return this.label;\n    }\n\n    /**\n     * Returns the label font.\n     *\n     * @return The label font (possibly <code>null</code>).\n     *\n     * @since 1.0.11\n     */\n    public Font getLabelFont() {\n        return this.labelFont;\n    }\n\n    /**\n     * Sets the label font.\n     *\n     * @param font  the font (<code>null</code> permitted).\n     *\n     * @since 1.0.11\n     */\n    public void setLabelFont(Font font) {\n        this.labelFont = font;\n    }\n\n    /**\n     * Returns the paint used to draw the label.\n     *\n     * @return The paint (possibly <code>null</code>).\n     *\n     * @since 1.0.11\n     */\n    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the label.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @since 1.0.11\n     */\n    public void setLabelPaint(Paint paint) {\n        this.labelPaint = paint;\n    }\n\n    /**\n     * Returns the attributed label.\n     *\n     * @return The attributed label (possibly <code>null</code>).\n     */\n    public AttributedString getAttributedLabel() {\n        return this.attributedLabel;\n    }\n\n    /**\n     * Returns the description for the legend item.\n     *\n     * @return The description.\n     */\n    public String getDescription() {\n        return this.description;\n    }\n\n    /**\n     * Returns the tool tip text.\n     *\n     * @return The tool tip text (possibly <code>null</code>).\n     */\n    public String getToolTipText() {\n        return this.toolTipText;\n    }\n\n    /**\n     * Returns the URL text.\n     *\n     * @return The URL text (possibly <code>null</code>).\n     */\n    public String getURLText() {\n        return this.urlText;\n    }\n\n    /**\n     * Returns a flag that indicates whether or not the shape is visible.\n     *\n     * @return A boolean.\n     */\n    public boolean isShapeVisible() {\n        return this.shapeVisible;\n    }\n\n    /**\n     * Returns the shape used to label the series represented by this legend\n     * item.\n     *\n     * @return The shape (never <code>null</code>).\n     */\n    public Shape getShape() {\n        return this.shape;\n    }\n\n    /**\n     * Returns a flag that controls whether or not the shape is filled.\n     *\n     * @return A boolean.\n     */\n    public boolean isShapeFilled() {\n        return this.shapeFilled;\n    }\n\n    /**\n     * Returns the fill paint.\n     *\n     * @return The fill paint (never <code>null</code>).\n     */\n    public Paint getFillPaint() {\n        return this.fillPaint;\n    }\n\n    /**\n     * Sets the fill paint.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @since 1.0.11\n     */\n    public void setFillPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.fillPaint = paint;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the shape outline\n     * is visible.\n     *\n     * @return A boolean.\n     */\n    public boolean isShapeOutlineVisible() {\n        return this.shapeOutlineVisible;\n    }\n\n    /**\n     * Returns the line stroke for the series.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getLineStroke() {\n        return this.lineStroke;\n    }\n\n    /**\n     * Returns the paint used for lines.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getLinePaint() {\n        return this.linePaint;\n    }\n\n    /**\n     * Sets the line paint.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @since 1.0.11\n     */\n    public void setLinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.linePaint = paint;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (never <code>null</code>).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Sets the outline paint.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @since 1.0.11\n     */\n    public void setOutlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.outlinePaint = paint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (never <code>null</code>).\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Returns a flag that indicates whether or not the line is visible.\n     *\n     * @return A boolean.\n     */\n    public boolean isLineVisible() {\n        return this.lineVisible;\n    }\n\n    /**\n     * Returns the line.\n     *\n     * @return The line (never <code>null</code>).\n     */\n    public Shape getLine() {\n        return this.line;\n    }\n\n    /**\n     * Returns the transformer used when the fill paint is an instance of\n     * <code>GradientPaint</code>.\n     *\n     * @return The transformer (never <code>null</code>).\n     *\n     * @since 1.0.4\n     *\n     * @see #setFillPaintTransformer(GradientPaintTransformer)\n     */\n    public GradientPaintTransformer getFillPaintTransformer() {\n        return this.fillPaintTransformer;\n    }\n\n    /**\n     * Sets the transformer used when the fill paint is an instance of\n     * <code>GradientPaint</code>.\n     *\n     * @param transformer  the transformer (<code>null</code> not permitted).\n     *\n     * @since 1.0.4\n     *\n     * @see #getFillPaintTransformer()\n     */\n    public void setFillPaintTransformer(GradientPaintTransformer transformer) {\n        if (transformer == null) {\n            throw new IllegalArgumentException(\"Null 'transformer' attribute.\");\n        }\n        this.fillPaintTransformer = transformer;\n    }\n\n    /**\n     * Tests this item for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof LegendItem)) {\n                return false;\n        }\n        LegendItem that = (LegendItem) obj;\n        if (this.datasetIndex != that.datasetIndex) {\n            return false;\n        }\n        if (this.series != that.series) {\n            return false;\n        }\n        if (!this.label.equals(that.label)) {\n            return false;\n        }\n        if (!AttributedStringUtilities.equal(this.attributedLabel,\n                that.attributedLabel)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.description, that.description)) {\n            return false;\n        }\n        if (this.shapeVisible != that.shapeVisible) {\n            return false;\n        }\n        if (!ShapeUtilities.equal(this.shape, that.shape)) {\n            return false;\n        }\n        if (this.shapeFilled != that.shapeFilled) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.fillPaint, that.fillPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fillPaintTransformer,\n                that.fillPaintTransformer)) {\n            return false;\n        }\n        if (this.shapeOutlineVisible != that.shapeOutlineVisible) {\n            return false;\n        }\n        if (!this.outlineStroke.equals(that.outlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) {\n            return false;\n        }\n        if (!this.lineVisible == that.lineVisible) {\n            return false;\n        }\n        if (!ShapeUtilities.equal(this.line, that.line)) {\n            return false;\n        }\n        if (!this.lineStroke.equals(that.lineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.linePaint, that.linePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns an independent copy of this object (except that the clone will\n     * still reference the same dataset as the original\n     * <code>LegendItem</code>).\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if the legend item cannot be cloned.\n     *\n     * @since 1.0.10\n     */\n    public Object clone() throws CloneNotSupportedException {\n        LegendItem clone = (LegendItem) super.clone();\n        if (this.seriesKey instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) this.seriesKey;\n            clone.seriesKey = (Comparable) pc.clone();\n        }\n        // FIXME: Clone the attributed string if it is not null\n        clone.shape = ShapeUtilities.clone(this.shape);\n        if (this.fillPaintTransformer instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) this.fillPaintTransformer;\n            clone.fillPaintTransformer = (GradientPaintTransformer) pc.clone();\n\n        }\n        clone.line = ShapeUtilities.clone(this.line);\n        return clone;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream (<code>null</code> not permitted).\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeAttributedString(this.attributedLabel, stream);\n        SerialUtilities.writeShape(this.shape, stream);\n        SerialUtilities.writePaint(this.fillPaint, stream);\n        SerialUtilities.writeStroke(this.outlineStroke, stream);\n        SerialUtilities.writePaint(this.outlinePaint, stream);\n        SerialUtilities.writeShape(this.line, stream);\n        SerialUtilities.writeStroke(this.lineStroke, stream);\n        SerialUtilities.writePaint(this.linePaint, stream);\n        SerialUtilities.writePaint(this.labelPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream (<code>null</code> not permitted).\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.attributedLabel = SerialUtilities.readAttributedString(stream);\n        this.shape = SerialUtilities.readShape(stream);\n        this.fillPaint = SerialUtilities.readPaint(stream);\n        this.outlineStroke = SerialUtilities.readStroke(stream);\n        this.outlinePaint = SerialUtilities.readPaint(stream);\n        this.line = SerialUtilities.readShape(stream);\n        this.lineStroke = SerialUtilities.readStroke(stream);\n        this.linePaint = SerialUtilities.readPaint(stream);\n        this.labelPaint = SerialUtilities.readPaint(stream);\n    }\n\n\t/**\n\t * Creates a legend item block.\n\t *\n\t * @param legendTitle TODO\n\t * @return The block.\n\t */\n\tpublic Block createLegendItemBlock(LegendTitle legendTitle) {\n\t    BlockContainer result = null;\n\t    LegendGraphic lg = new LegendGraphic(getShape(),\n\t            getFillPaint());\n\t    lg.setFillPaintTransformer(getFillPaintTransformer());\n\t    lg.setShapeFilled(isShapeFilled());\n\t    lg.setLine(getLine());\n\t    lg.setLineStroke(getLineStroke());\n\t    lg.setLinePaint(getLinePaint());\n\t    lg.setLineVisible(isLineVisible());\n\t    lg.setShapeVisible(isShapeVisible());\n\t    lg.setShapeOutlineVisible(isShapeOutlineVisible());\n\t    lg.setOutlinePaint(getOutlinePaint());\n\t    lg.setOutlineStroke(getOutlineStroke());\n\t    lg.setPadding(legendTitle.legendItemGraphicPadding);\n\t\n\t    LegendItemBlockContainer legendItem = new LegendItemBlockContainer(\n\t            new BorderArrangement(), getDataset(),\n\t            getSeriesKey());\n\t    lg.setShapeAnchor(legendTitle.getLegendItemGraphicAnchor());\n\t    lg.setShapeLocation(legendTitle.getLegendItemGraphicLocation());\n\t    legendItem.add(lg, legendTitle.legendItemGraphicEdge);\n\t    Font textFont = getLabelFont();\n\t    if (textFont == null) {\n\t        textFont = legendTitle.itemFont;\n\t    }\n\t    Paint textPaint = getLabelPaint();\n\t    if (textPaint == null) {\n\t        textPaint = legendTitle.itemPaint;\n\t    }\n\t    LabelBlock labelBlock = new LabelBlock(getLabel(), textFont,\n\t            textPaint);\n\t    labelBlock.setPadding(legendTitle.itemLabelPadding);\n\t    legendItem.add(labelBlock);\n\t    legendItem.setToolTipText(getToolTipText());\n\t    legendItem.setURLText(getURLText());\n\t\n\t    result = new BlockContainer(new CenterArrangement());\n\t    result.add(legendItem);\n\t\n\t    return result;\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 1063,
                        "lineEnd": 1110,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.title.LegendTitle\nRationale: The method createLegendItemBlock() is primarily concerned with creating a legend item block that involves properties and configurations related to the LegendTitle, such as padding, graphic anchor, and graphic location. Therefore, it is more appropriate for this method to reside in the LegendTitle class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5469
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createLegendItemBlock",
                            "method_signature": "public Block createLegendItemBlock(LegendTitle legendTitle)",
                            "target_class": "LegendGraphic",
                            "rationale": "The method createLegendItemBlock() is responsible for creating a visual representation of a legend item, which is closely related to the functionality of the LegendGraphic class. Moving it there would enhance cohesion and maintainability."
                        }
                    ],
                    "llm_response_time": 1749
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "createLegendItemBlock",
                            "method_signature": "public Block createLegendItemBlock(LegendTitle legendTitle)",
                            "target_class": "LegendGraphic",
                            "rationale": "The createLegendItemBlock method is responsible for creating a LegendGraphic and configuring it, which is closely related to the responsibilities of the LegendGraphic class. Moving this method would help adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 1705
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "createLegendItemBlock",
                            "method_signature": "public Block createLegendItemBlock(LegendTitle legendTitle)",
                            "target_class": "LegendGraphic",
                            "rationale": "The createLegendItemBlock method is responsible for creating a LegendGraphic and configuring its properties. It would be more appropriate for this method to reside in the LegendGraphic class, which is more focused on rendering and managing legend graphics."
                        }
                    ],
                    "llm_response_time": 1462
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createLegendItemBlock",
                            "method_signature": "public Block createLegendItemBlock(LegendTitle legendTitle)",
                            "target_class": "LegendGraphic",
                            "rationale": "The method createLegendItemBlock() is responsible for creating a visual representation of a legend item, which is closely related to the functionality of the LegendGraphic class. Moving it there would enhance cohesion and maintainability."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "createLegendItemBlock"
                ],
                "llm_response_time": 483
            },
            "targetClassMap": {
                "createLegendItemBlock": {
                    "target_classes": [
                        {
                            "class_name": "LegendTitle",
                            "similarity_score": 0.5508028628635356
                        },
                        {
                            "class_name": "Dataset",
                            "similarity_score": 0.2558107025523563
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "LegendTitle",
                        "Dataset"
                    ],
                    "llm_response_time": 1224,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.renderer.xy.XYItemRendererState::drawPrimaryLine2(XYItemRendererState, Graphics2D, XYPlot, XYDataset, int, int, int, ValueAxis, ValueAxis, Rectangle2D):void need move org.jfree.experimental.chart.renderer.xy.XYSmoothLineAndShapeRenderer",
        "class_name": "org.jfree.chart.renderer.xy.XYItemRendererState",
        "telemetry": {
            "id": "0f5979c5-5d8d-43f5-8842-a6cdd6e86158",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 248,
                "lineStart": 65,
                "lineEnd": 312,
                "bodyLineStart": 65,
                "language": "java",
                "sourceCode": "/**\n * The state for an {@link XYItemRenderer}.\n */\npublic class XYItemRendererState extends RendererState {\n\n    /**\n     * The first item in the series that will be displayed.\n     *\n     * @since 1.0.11\n     */\n    private int firstItemIndex;\n\n    /**\n     * The last item in the current series that will be displayed.\n     *\n     * @since 1.0.11\n     */\n    private int lastItemIndex;\n\n    /**\n     * A line object that the renderer can reuse to save instantiating a lot\n     * of objects.\n     */\n    public Line2D workingLine;\n\n    /**\n     * A flag that controls whether the plot should pass ALL data items to the\n     * renderer, or just the items that will be visible.\n     *\n     * @since 1.0.6\n     */\n    private boolean processVisibleItemsOnly;\n\n    /**\n     * Creates a new state.\n     *\n     * @param info  the plot rendering info.\n     */\n    public XYItemRendererState(PlotRenderingInfo info) {\n        super(info);\n        this.workingLine = new Line2D.Double();\n        this.processVisibleItemsOnly = true;\n    }\n\n    /**\n     * Returns the flag that controls whether the plot passes all data\n     * items in each series to the renderer, or just the visible items.  The\n     * default value is <code>true</code>.\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.6\n     *\n     * @see #setProcessVisibleItemsOnly(boolean)\n     */\n    public boolean getProcessVisibleItemsOnly() {\n        return this.processVisibleItemsOnly;\n    }\n\n    /**\n     * Sets the flag that controls whether the plot passes all data\n     * items in each series to the renderer, or just the visible items.\n     *\n     * @param flag  the new flag value.\n     *\n     * @since 1.0.6\n     */\n    public void setProcessVisibleItemsOnly(boolean flag) {\n        this.processVisibleItemsOnly = flag;\n    }\n\n    /**\n     * Returns the first item index (this is updated with each call to\n     * {@link #startSeriesPass(XYDataset, int, int, int, int, int)}.\n     *\n     * @return The first item index.\n     *\n     * @since 1.0.11\n     */\n    public int getFirstItemIndex() {\n        return this.firstItemIndex;\n    }\n\n    /**\n     * Returns the last item index (this is updated with each call to\n     * {@link #startSeriesPass(XYDataset, int, int, int, int, int)}.\n     *\n     * @return The last item index.\n     *\n     * @since 1.0.11\n     */\n    public int getLastItemIndex() {\n        return this.lastItemIndex;\n    }\n\n    /**\n     * This method is called by the {@link XYPlot} when it starts a pass\n     * through the (visible) items in a series.  The default implementation\n     * records the first and last item indices - override this method to\n     * implement additional specialised behaviour.\n     *\n     * @param dataset  the dataset.\n     * @param series  the series index.\n     * @param firstItem  the index of the first item in the series.\n     * @param lastItem  the index of the last item in the series.\n     * @param pass  the pass index.\n     * @param passCount  the number of passes.\n     *\n     * @see #endSeriesPass(XYDataset, int, int, int, int, int)\n     *\n     * @since 1.0.11\n     */\n    public void startSeriesPass(XYDataset dataset, int series, int firstItem,\n            int lastItem, int pass, int passCount) {\n        this.firstItemIndex = firstItem;\n        this.lastItemIndex = lastItem;\n    }\n\n    /**\n     * This method is called by the {@link XYPlot} when it ends a pass\n     * through the (visible) items in a series.  The default implementation\n     * does nothing, but you can override this method to implement specialised\n     * behaviour.\n     *\n     * @param dataset  the dataset.\n     * @param series  the series index.\n     * @param firstItem  the index of the first item in the series.\n     * @param lastItem  the index of the last item in the series.\n     * @param pass  the pass index.\n     * @param passCount  the number of passes.\n     *\n     * @see #startSeriesPass(XYDataset, int, int, int, int, int)\n     *\n     * @since 1.0.11\n     */\n    public void endSeriesPass(XYDataset dataset, int series, int firstItem,\n            int lastItem, int pass, int passCount) {\n        // do nothing...this is just a hook for subclasses\n    }\n\n\t/**\n\t * Draws the item (first pass). This method draws the lines\n\t * connecting the items.\n\t *\n\t * @param xySmoothLineAndShapeRenderer TODO\n\t * @param g2  the graphics device.\n\t * @param plot  the plot (can be used to obtain standard color\n\t *              information etc).\n\t * @param dataset  the dataset.\n\t * @param pass  the pass.\n\t * @param series  the series index (zero-based).\n\t * @param item  the item index (zero-based).\n\t * @param domainAxis  the domain axis.\n\t * @param rangeAxis  the range axis.\n\t * @param dataArea  the area within which the data is being drawn.\n\t */\n\tpublic void drawPrimaryLine2(XYSmoothLineAndShapeRenderer xySmoothLineAndShapeRenderer, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea) {\n\t\n\t    if (item == 0) {\n\t        return;\n\t    }\n\t\n\t    // get the data point...\n\t    double x1 = dataset.getXValue(series, item);\n\t    double y1 = dataset.getYValue(series, item);\n\t    if (Double.isNaN(y1) || Double.isNaN(x1)) {\n\t        return;\n\t    }\n\t\n\t    double x0 = dataset.getXValue(series, item - 1);\n\t    double y0 = dataset.getYValue(series, item - 1);\n\t    if (Double.isNaN(y0) || Double.isNaN(x0)) {\n\t        return;\n\t    }\n\t\n\t    RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n\t    RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n\t\n\t    double transX0 = domainAxis.valueToJava2D(x0, dataArea, xAxisLocation);\n\t    double transY0 = rangeAxis.valueToJava2D(y0, dataArea, yAxisLocation);\n\t\n\t    double transX1 = domainAxis.valueToJava2D(x1, dataArea, xAxisLocation);\n\t    double transY1 = rangeAxis.valueToJava2D(y1, dataArea, yAxisLocation);\n\t\n\t    // only draw if we have good values\n\t    if (Double.isNaN(transX0) || Double.isNaN(transY0)\n\t            || Double.isNaN(transX1) || Double.isNaN(transY1)) {\n\t        return;\n\t    }\n\t\n\t    java.awt.geom.Point2D.Double point0 = new java.awt.geom.Point2D.Double();\n\t    java.awt.geom.Point2D.Double point1 = new java.awt.geom.Point2D.Double();\n\t    java.awt.geom.Point2D.Double point2 = new java.awt.geom.Point2D.Double();\n\t    java.awt.geom.Point2D.Double point3 = new java.awt.geom.Point2D.Double();\n\t\n\t    if (item == 1) {\n\t        point0 = null;\n\t    }\n\t    else {\n\t        point0.x = domainAxis.valueToJava2D(dataset.getXValue(series,\n\t                item - 2), dataArea, xAxisLocation);\n\t        point0.y = rangeAxis.valueToJava2D(dataset.getYValue(series,\n\t                item - 2), dataArea, yAxisLocation);\n\t    }\n\t\n\t    point1.x = transX0;\n\t    point1.y = transY0;\n\t\n\t    point2.x = transX1;\n\t    point2.y = transY1;\n\t\n\t    if ((item + 1) == dataset.getItemCount(series)) {\n\t        point3 = null;\n\t    }\n\t    else {\n\t        point3.x = domainAxis.valueToJava2D(dataset.getXValue(series,\n\t                item + 1), dataArea, xAxisLocation);\n\t        point3.y = rangeAxis.valueToJava2D(dataset.getYValue(series,\n\t                item + 1), dataArea, yAxisLocation);\n\t    }\n\t\n\t    int steps = ((int) ((point2.x - point1.x) / 0.2) < 30)\n\t            ? (int) ((point2.x - point1.x) / 0.2) : 30;\n\t\n\t    java.awt.geom.Point2D.Double[] points = XYSmoothLineAndShapeRenderer.getBezierCurve(point0, point1, point2,\n\t            point3, 1, steps);\n\t\n\t    for (int i = 1; i < points.length; i++) {\n\t        transX0 = points[i - 1].x;\n\t        transY0 = points[i - 1].y;\n\t        transX1 = points[i].x;\n\t        transY1 = points[i].y;\n\t\n\t        PlotOrientation orientation = plot.getOrientation();\n\t        if (orientation == PlotOrientation.HORIZONTAL) {\n\t            workingLine.setLine(transY0, transX0, transY1, transX1);\n\t        }\n\t        else if (orientation == PlotOrientation.VERTICAL) {\n\t            workingLine.setLine(transX0, transY0, transX1, transY1);\n\t        }\n\t\n\t        if (workingLine.intersects(dataArea)) {\n\t            xySmoothLineAndShapeRenderer.drawFirstPassShape(g2, pass, series, item, workingLine);\n\t        }\n\t    }\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 204,
                        "lineEnd": 309,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.experimental.chart.renderer.xy.XYSmoothLineAndShapeRenderer\nRationale: The method drawPrimaryLine2 is primarily concerned with drawing lines and shapes based on the dataset values, which aligns with the responsibilities of the XYSmoothLineAndShapeRenderer class. It utilizes methods from this class and is focused on rendering graphical elements.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 7157
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawPrimaryLine2",
                            "method_signature": "public void drawPrimaryLine2(XYSmoothLineAndShapeRenderer xySmoothLineAndShapeRenderer, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea)",
                            "target_class": "XYPlot",
                            "rationale": "The drawPrimaryLine2 method is responsible for rendering graphical elements based on the dataset and plot information. It would be more appropriate for this method to reside in the XYPlot class, which is responsible for rendering the plot itself."
                        }
                    ],
                    "llm_response_time": 2228
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawPrimaryLine2",
                            "method_signature": "public void drawPrimaryLine2(XYSmoothLineAndShapeRenderer xySmoothLineAndShapeRenderer, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea)",
                            "target_class": "XYPlot",
                            "rationale": "The drawPrimaryLine2 method is responsible for rendering graphical elements based on the dataset and plot information. It would be more appropriate for this method to reside in the XYPlot class, which is responsible for rendering the plot itself."
                        }
                    ],
                    "llm_response_time": 2225
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawPrimaryLine2",
                            "method_signature": "public void drawPrimaryLine2(XYSmoothLineAndShapeRenderer xySmoothLineAndShapeRenderer, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea)",
                            "target_class": "XYPlot",
                            "rationale": "The drawPrimaryLine2 method is responsible for rendering graphical elements, which is more aligned with the responsibilities of the XYPlot class. Moving it there would adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 1926
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "drawPrimaryLine2",
                            "method_signature": "public void drawPrimaryLine2(XYSmoothLineAndShapeRenderer xySmoothLineAndShapeRenderer, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea)",
                            "target_class": "XYPlot",
                            "rationale": "The drawPrimaryLine2 method is responsible for rendering graphical elements based on the dataset and plot information. It would be more appropriate for this method to reside in the XYPlot class, which is responsible for rendering the plot itself."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "drawPrimaryLine2"
                ],
                "llm_response_time": 710
            },
            "targetClassMap": {
                "drawPrimaryLine2": {
                    "target_classes": [
                        {
                            "class_name": "XYSmoothLineAndShapeRenderer",
                            "similarity_score": 0.6386870155402031
                        },
                        {
                            "class_name": "XYDataset",
                            "similarity_score": 0.44051355326389374
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "XYSmoothLineAndShapeRenderer",
                        "XYDataset"
                    ],
                    "llm_response_time": 1775,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    }
]