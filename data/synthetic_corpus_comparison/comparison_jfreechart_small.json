[
    {
        "oracle": "- method org.jfree.data.DefaultKeyedValues2D::removeRow(int):void need move org.jfree.data.category.DefaultCategoryDataset",
        "class_name": "org.jfree.data.DefaultKeyedValues2D",
        "telemetry": {
            "id": "cbf61355-2983-4cb1-8c1c-5f49d2a2178b",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 527,
                "lineStart": 70,
                "lineEnd": 596,
                "bodyLineStart": 70,
                "language": "java",
                "sourceCode": "/**\n * A data structure that stores zero, one or many values, where each value\n * is associated with two keys (a 'row' key and a 'column' key).  The keys\n * should be (a) instances of {@link Comparable} and (b) immutable.\n */\npublic class DefaultKeyedValues2D implements KeyedValues2D, PublicCloneable,\n        Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5514169970951994748L;\n\n    /** The row keys. */\n    private List rowKeys;\n\n    /** The column keys. */\n    private List columnKeys;\n\n    /** The row data. */\n    private List rows;\n\n    /** If the row keys should be sorted by their comparable order. */\n    private boolean sortRowKeys;\n\n    /**\n     * Creates a new instance (initially empty).\n     */\n    public DefaultKeyedValues2D() {\n        this(false);\n    }\n\n    /**\n     * Creates a new instance (initially empty).\n     *\n     * @param sortRowKeys  if the row keys should be sorted.\n     */\n    public DefaultKeyedValues2D(boolean sortRowKeys) {\n        this.rowKeys = new java.util.ArrayList();\n        this.columnKeys = new java.util.ArrayList();\n        this.rows = new java.util.ArrayList();\n        this.sortRowKeys = sortRowKeys;\n    }\n\n    /**\n     * Returns the row count.\n     *\n     * @return The row count.\n     *\n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.rowKeys.size();\n    }\n\n    /**\n     * Returns the column count.\n     *\n     * @return The column count.\n     *\n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.columnKeys.size();\n    }\n\n    /**\n     * Returns the value for a given row and column.\n     *\n     * @param row  the row index.\n     * @param column  the column index.\n     *\n     * @return The value.\n     *\n     * @see #getValue(Comparable, Comparable)\n     */\n    public Number getValue(int row, int column) {\n        Number result = null;\n        DefaultKeyedValues rowData = (DefaultKeyedValues) this.rows.get(row);\n        if (rowData != null) {\n            Comparable columnKey = (Comparable) this.columnKeys.get(column);\n            // the row may not have an entry for this key, in which case the\n            // return value is null\n            int index = rowData.getIndex(columnKey);\n            if (index >= 0) {\n                result = rowData.getValue(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the key for a given row.\n     *\n     * @param row  the row index (in the range 0 to {@link #getRowCount()} - 1).\n     *\n     * @return The row key.\n     *\n     * @see #getRowIndex(Comparable)\n     * @see #getColumnKey(int)\n     */\n    public Comparable getRowKey(int row) {\n        return (Comparable) this.rowKeys.get(row);\n    }\n\n    /**\n     * Returns the row index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The row index.\n     *\n     * @see #getRowKey(int)\n     * @see #getColumnIndex(Comparable)\n     */\n    public int getRowIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (this.sortRowKeys) {\n            return Collections.binarySearch(this.rowKeys, key);\n        }\n        else {\n            return this.rowKeys.indexOf(key);\n        }\n    }\n\n    /**\n     * Returns the row keys in an unmodifiable list.\n     *\n     * @return The row keys.\n     *\n     * @see #getColumnKeys()\n     */\n    public List getRowKeys() {\n        return Collections.unmodifiableList(this.rowKeys);\n    }\n\n    /**\n     * Returns the key for a given column.\n     *\n     * @param column  the column (in the range 0 to {@link #getColumnCount()}\n     *     - 1).\n     *\n     * @return The key.\n     *\n     * @see #getColumnIndex(Comparable)\n     * @see #getRowKey(int)\n     */\n    public Comparable getColumnKey(int column) {\n        return (Comparable) this.columnKeys.get(column);\n    }\n\n    /**\n     * Returns the column index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The column index.\n     *\n     * @see #getColumnKey(int)\n     * @see #getRowIndex(Comparable)\n     */\n    public int getColumnIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        return this.columnKeys.indexOf(key);\n    }\n\n    /**\n     * Returns the column keys in an unmodifiable list.\n     *\n     * @return The column keys.\n     *\n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        return Collections.unmodifiableList(this.columnKeys);\n    }\n\n    /**\n     * Returns the value for the given row and column keys.  This method will\n     * throw an {@link UnknownKeyException} if either key is not defined in the\n     * data structure.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     *\n     * @see #addValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public Number getValue(Comparable rowKey, Comparable columnKey) {\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n\n        // check that the column key is defined in the 2D structure\n        if (!(this.columnKeys.contains(columnKey))) {\n            throw new UnknownKeyException(\"Unrecognised columnKey: \"\n                    + columnKey);\n        }\n\n        // now fetch the row data - need to bear in mind that the row\n        // structure may not have an entry for the column key, but that we\n        // have already checked that the key is valid for the 2D structure\n        int row = getRowIndex(rowKey);\n        if (row >= 0) {\n            DefaultKeyedValues rowData\n                = (DefaultKeyedValues) this.rows.get(row);\n            int col = rowData.getIndex(columnKey);\n            return (col >= 0 ? rowData.getValue(col) : null);\n        }\n        else {\n            throw new UnknownKeyException(\"Unrecognised rowKey: \" + rowKey);\n        }\n    }\n\n    /**\n     * Adds a value to the table.  Performs the same function as\n     * #setValue(Number, Comparable, Comparable).\n     *\n     * @param value  the value (<code>null</code> permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @see #setValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public void addValue(Number value, Comparable rowKey,\n                         Comparable columnKey) {\n        // defer argument checking\n        setValue(value, rowKey, columnKey);\n    }\n\n    /**\n     * Adds or updates a value.\n     *\n     * @param value  the value (<code>null</code> permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @see #addValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public void setValue(Number value, Comparable rowKey,\n                         Comparable columnKey) {\n\n        DefaultKeyedValues row;\n        int rowIndex = getRowIndex(rowKey);\n\n        if (rowIndex >= 0) {\n            row = (DefaultKeyedValues) this.rows.get(rowIndex);\n        }\n        else {\n            row = new DefaultKeyedValues();\n            if (this.sortRowKeys) {\n                rowIndex = -rowIndex - 1;\n                this.rowKeys.add(rowIndex, rowKey);\n                this.rows.add(rowIndex, row);\n            }\n            else {\n                this.rowKeys.add(rowKey);\n                this.rows.add(row);\n            }\n        }\n        row.setValue(columnKey, value);\n\n        int columnIndex = this.columnKeys.indexOf(columnKey);\n        if (columnIndex < 0) {\n            this.columnKeys.add(columnKey);\n        }\n    }\n\n    /**\n     * Removes a value from the table by setting it to <code>null</code>.  If\n     * all the values in the specified row and/or column are now\n     * <code>null</code>, the row and/or column is removed from the table.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @see #addValue(Number, Comparable, Comparable)\n     */\n    public void removeValue(Comparable rowKey, Comparable columnKey) {\n        setValue(null, rowKey, columnKey);\n\n        // 1. check whether the row is now empty.\n        boolean allNull = true;\n        int rowIndex = getRowIndex(rowKey);\n        DefaultKeyedValues row = (DefaultKeyedValues) this.rows.get(rowIndex);\n\n        for (int item = 0, itemCount = row.getItemCount(); item < itemCount;\n             item++) {\n            if (row.getValue(item) != null) {\n                allNull = false;\n                break;\n            }\n        }\n\n        if (allNull) {\n            this.rowKeys.remove(rowIndex);\n            this.rows.remove(rowIndex);\n        }\n\n        // 2. check whether the column is now empty.\n        allNull = true;\n        //int columnIndex = getColumnIndex(columnKey);\n\n        for (int item = 0, itemCount = this.rows.size(); item < itemCount;\n             item++) {\n            row = (DefaultKeyedValues) this.rows.get(item);\n            int columnIndex = row.getIndex(columnKey);\n            if (columnIndex >= 0 && row.getValue(columnIndex) != null) {\n                allNull = false;\n                break;\n            }\n        }\n\n        if (allNull) {\n            for (int item = 0, itemCount = this.rows.size(); item < itemCount;\n                 item++) {\n                row = (DefaultKeyedValues) this.rows.get(item);\n                int columnIndex = row.getIndex(columnKey);\n                if (columnIndex >= 0) {\n                    row.removeValue(columnIndex);\n                }\n            }\n            this.columnKeys.remove(columnKey);\n        }\n    }\n\n    /**\n     * Removes a row.\n     *\n     * @param rowIndex  the row index.\n     *\n     * @see #removeRow(Comparable)\n     * @see #removeColumn(int)\n     */\n    public void removeRow(int rowIndex) {\n        this.rowKeys.remove(rowIndex);\n        this.rows.remove(rowIndex);\n    }\n\n    /**\n     * Removes a row from the table.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     *\n     * @see #removeRow(int)\n     * @see #removeColumn(Comparable)\n     *\n     * @throws UnknownKeyException if <code>rowKey</code> is not defined in the\n     *         table.\n     */\n    public void removeRow(Comparable rowKey) {\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        int index = getRowIndex(rowKey);\n        if (index >= 0) {\n            removeRow(index);\n        }\n        else {\n            throw new UnknownKeyException(\"Unknown key: \" + rowKey);\n        }\n    }\n\n    /**\n     * Removes a column.\n     *\n     * @param columnIndex  the column index.\n     *\n     * @see #removeColumn(Comparable)\n     * @see #removeRow(int)\n     */\n    public void removeColumn(int columnIndex) {\n        Comparable columnKey = getColumnKey(columnIndex);\n        removeColumn(columnKey);\n    }\n\n    /**\n     * Removes a column from the table.\n     *\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @throws UnknownKeyException if the table does not contain a column with\n     *     the specified key.\n     * @throws IllegalArgumentException if <code>columnKey</code> is\n     *     <code>null</code>.\n     *\n     * @see #removeColumn(int)\n     * @see #removeRow(Comparable)\n     */\n    public void removeColumn(Comparable columnKey) {\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        if (!this.columnKeys.contains(columnKey)) {\n            throw new UnknownKeyException(\"Unknown key: \" + columnKey);\n        }\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n            int index = rowData.getIndex(columnKey);\n            if (index >= 0) {\n                rowData.removeValue(columnKey);\n            }\n        }\n        this.columnKeys.remove(columnKey);\n    }\n\n    /**\n     * Clears all the data and associated keys.\n     */\n    public void clear() {\n        this.rowKeys.clear();\n        this.columnKeys.clear();\n        this.rows.clear();\n    }\n\n    /**\n     * Tests if this object is equal to another.\n     *\n     * @param o  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object o) {\n\n        if (o == null) {\n            return false;\n        }\n        if (o == this) {\n            return true;\n        }\n\n        if (!(o instanceof KeyedValues2D)) {\n            return false;\n        }\n        KeyedValues2D kv2D = (KeyedValues2D) o;\n        if (!getRowKeys().equals(kv2D.getRowKeys())) {\n            return false;\n        }\n        if (!getColumnKeys().equals(kv2D.getColumnKeys())) {\n            return false;\n        }\n        int rowCount = getRowCount();\n        if (rowCount != kv2D.getRowCount()) {\n            return false;\n        }\n\n        int colCount = getColumnCount();\n        if (colCount != kv2D.getColumnCount()) {\n            return false;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < colCount; c++) {\n                Number v1 = getValue(r, c);\n                Number v2 = kv2D.getValue(r, c);\n                if (v1 == null) {\n                    if (v2 != null) {\n                        return false;\n                    }\n                }\n                else {\n                    if (!v1.equals(v2)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.rowKeys.hashCode();\n        result = 29 * result + this.columnKeys.hashCode();\n        result = 29 * result + this.rows.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultKeyedValues2D clone = (DefaultKeyedValues2D) super.clone();\n        // for the keys, a shallow copy should be fine because keys\n        // should be immutable...\n        clone.columnKeys = new java.util.ArrayList(this.columnKeys);\n        clone.rowKeys = new java.util.ArrayList(this.rowKeys);\n\n        // but the row data requires a deep copy\n        clone.rows = (List) ObjectUtilities.deepClone(this.rows);\n        return clone;\n    }\n\n\t/**\n\t * Removes a row from the dataset and sends a {@link DatasetChangeEvent}\n\t * to all registered listeners.\n\t *\n\t * @param defaultCategoryDataset TODO\n\t * @param rowIndex  the row index.\n\t * @see #removeColumn(int)\n\t */\n\tpublic void removeRow(DefaultCategoryDataset defaultCategoryDataset, int rowIndex) {\n\t    removeRow(rowIndex);\n\t    defaultCategoryDataset.fireDatasetChanged();\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 582,
                        "lineEnd": 593,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.data.category.DefaultCategoryDataset\nRationale: The method directly interacts with the DefaultCategoryDataset by firing a dataset change event after removing a row, indicating that it is closely related to the dataset's management and should reside within the DefaultCategoryDataset class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5206
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "removeRow",
                            "method_signature": "public void removeRow(DefaultCategoryDataset defaultCategoryDataset, int rowIndex)",
                            "target_class": "DefaultCategoryDataset",
                            "rationale": "The method removeRow() is responsible for removing a row from the dataset and notifying listeners of the change. This behavior is more aligned with the responsibilities of the DefaultCategoryDataset class, which should manage its own state and notify listeners."
                        }
                    ],
                    "llm_response_time": 1784
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "removeRow",
                            "method_signature": "public void removeRow(DefaultCategoryDataset defaultCategoryDataset, int rowIndex)",
                            "target_class": "DefaultCategoryDataset",
                            "rationale": "The method removeRow() is responsible for removing a row from the dataset and notifying listeners of the change. This behavior is more aligned with the responsibilities of the DefaultCategoryDataset class, which should manage its own state and notify listeners."
                        }
                    ],
                    "llm_response_time": 1150
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "removeRow",
                            "method_signature": "public void removeRow(DefaultCategoryDataset defaultCategoryDataset, int rowIndex)",
                            "target_class": "DefaultCategoryDataset",
                            "rationale": "The method removeRow() is responsible for removing a row from the dataset and notifying listeners of the change. This behavior is more aligned with the responsibilities of the DefaultCategoryDataset class, which should manage its own state and notify listeners."
                        }
                    ],
                    "llm_response_time": 1551
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "removeRow",
                            "method_signature": "public void removeRow(DefaultCategoryDataset defaultCategoryDataset, int rowIndex)",
                            "target_class": "DefaultCategoryDataset",
                            "rationale": "The method removeRow() is responsible for removing a row from the dataset and notifying listeners of the change. This behavior is more aligned with the responsibilities of the DefaultCategoryDataset class, which should manage its own state and notify listeners."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "removeRow"
                ],
                "llm_response_time": 648
            },
            "targetClassMap": {
                "removeRow": {
                    "target_classes": [
                        {
                            "class_name": "DefaultCategoryDataset",
                            "similarity_score": 0.818321052133694
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "DefaultCategoryDataset"
                    ],
                    "llm_response_time": 968,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.ClipPath::setDomainCrosshairLockedOnData(boolean):void need move org.jfree.chart.plot.ContourPlot",
        "class_name": "org.jfree.chart.ClipPath",
        "telemetry": {
            "id": "36bd88d3-9a15-47de-9abb-b6e1c475fa29",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 392,
                "lineStart": 63,
                "lineEnd": 454,
                "bodyLineStart": 63,
                "language": "java",
                "sourceCode": "/**\n * This class would typically be used with a\n * {@link org.jfree.chart.plot.ContourPlot}.  It allows the user to define a\n * <code>GeneralPath</code> curve in plot coordinates.  This curve can then be\n * used mask off or define regions within the contour plot.  The data must be\n * sorted.\n *\n * @deprecated This class is no longer supported (as of version 1.0.4).  If\n *     you are creating contour plots, please try to use {@link XYPlot} and\n *     {@link XYBlockRenderer}.\n */\npublic class ClipPath implements Cloneable {\n\n    /** The x values. */\n    private double[] xValue = null;\n\n    /** The y values. */\n    private double[] yValue = null;\n\n    /** Controls whether drawing will be clipped (\n     * false would still allow the drawing or filling of path */\n    private boolean clip = true;\n\n    /** Controls whether the path is drawn as an outline. */\n    private boolean drawPath = false;\n\n    /** Controls whether the path is filled. */\n    private boolean fillPath = false;\n\n    /** The fill paint. */\n    private Paint fillPaint = null;\n\n    /** The draw paint. */\n    private Paint drawPaint = null;\n\n    /** The draw stroke. */\n    private Stroke drawStroke = null;\n\n    /** The composite. */\n    private Composite composite = null;\n\n    /**\n     * Constructor for ClipPath.\n     */\n    public ClipPath() {\n        super();\n    }\n\n    /**\n     * Constructor for ClipPath.\n     * Default values are assumed for the fillPath and drawPath options as\n     * false and true respectively.  The fillPaint is set to Color.GRAY, the\n     * drawColor is Color.BLUE, the stroke is BasicStroke(1)\n     * and the composite is AlphaComposite.Src.\n     *\n     * @param xValue  x coordinates of curved to be created\n     * @param yValue  y coordinates of curved to be created\n     */\n    public ClipPath(double[] xValue, double[] yValue) {\n        this(xValue, yValue, true, false, true);\n    }\n\n\n    /**\n     * Constructor for ClipPath.\n     * The fillPaint is set to Color.GRAY, the drawColor is Color.BLUE, the\n     * stroke is BasicStroke(1) and the composite is AlphaComposite.Src.\n     *\n     * @param xValue  x coordinates of curved to be created\n     * @param yValue  y coordinates of curved to be created\n     * @param clip  clip?\n     * @param fillPath  whether the path is to filled\n     * @param drawPath  whether the path is to drawn as an outline\n     */\n    public ClipPath(double[] xValue, double[] yValue,\n                    boolean clip, boolean fillPath, boolean drawPath) {\n        this.xValue = xValue;\n        this.yValue = yValue;\n\n        this.clip = clip;\n        this.fillPath = fillPath;\n        this.drawPath = drawPath;\n\n        this.fillPaint = java.awt.Color.gray;\n        this.drawPaint = java.awt.Color.blue;\n        this.drawStroke = new BasicStroke(1);\n        this.composite = java.awt.AlphaComposite.Src;\n    }\n\n    /**\n     * Constructor for ClipPath.\n     *\n     * @param xValue  x coordinates of curved to be created\n     * @param yValue  y coordinates of curved to be created\n     * @param fillPath  whether the path is to filled\n     * @param drawPath  whether the path is to drawn as an outline\n     * @param fillPaint  the fill paint\n     * @param drawPaint  the outline stroke color\n     * @param drawStroke  the stroke style\n     * @param composite  the composite rule\n     */\n    public ClipPath(double[] xValue, double[] yValue, boolean fillPath,\n                    boolean drawPath, Paint fillPaint, Paint drawPaint,\n                    Stroke drawStroke, Composite composite) {\n\n        this.xValue = xValue;\n        this.yValue = yValue;\n\n        this.fillPath = fillPath;\n        this.drawPath = drawPath;\n\n        this.fillPaint = fillPaint;\n        this.drawPaint = drawPaint;\n        this.drawStroke = drawStroke;\n        this.composite = composite;\n\n    }\n\n    /**\n     * Draws the clip path.\n     *\n     * @param g2  current graphics2D.\n     * @param dataArea  the dataArea that the plot is being draw in.\n     * @param horizontalAxis  the horizontal axis.\n     * @param verticalAxis  the vertical axis.\n     *\n     * @return The GeneralPath defining the outline\n     */\n    public GeneralPath draw(Graphics2D g2,\n                            Rectangle2D dataArea,\n                            ValueAxis horizontalAxis, ValueAxis verticalAxis) {\n\n        GeneralPath generalPath = generateClipPath(\n            dataArea, horizontalAxis, verticalAxis\n        );\n        if (this.fillPath || this.drawPath) {\n            Composite saveComposite = g2.getComposite();\n            Paint savePaint = g2.getPaint();\n            Stroke saveStroke = g2.getStroke();\n\n            if (this.fillPaint != null) {\n                g2.setPaint(this.fillPaint);\n            }\n            if (this.composite != null) {\n                g2.setComposite(this.composite);\n            }\n            if (this.fillPath) {\n                g2.fill(generalPath);\n            }\n\n            if (this.drawStroke != null) {\n                g2.setStroke(this.drawStroke);\n            }\n            if (this.drawPath) {\n                g2.draw(generalPath);\n            }\n            g2.setPaint(savePaint);\n            g2.setComposite(saveComposite);\n            g2.setStroke(saveStroke);\n        }\n        return generalPath;\n\n    }\n\n    /**\n     * Generates the clip path.\n     *\n     * @param dataArea  the dataArea that the plot is being draw in.\n     * @param horizontalAxis  the horizontal axis.\n     * @param verticalAxis  the vertical axis.\n     *\n     * @return The GeneralPath defining the outline\n     */\n    public GeneralPath generateClipPath(Rectangle2D dataArea,\n                                        ValueAxis horizontalAxis,\n                                        ValueAxis verticalAxis) {\n\n        GeneralPath generalPath = new GeneralPath();\n        double transX = horizontalAxis.valueToJava2D(\n            this.xValue[0], dataArea, RectangleEdge.BOTTOM\n        );\n        double transY = verticalAxis.valueToJava2D(\n            this.yValue[0], dataArea, RectangleEdge.LEFT\n        );\n        generalPath.moveTo((float) transX, (float) transY);\n        for (int k = 0; k < this.yValue.length; k++) {\n            transX = horizontalAxis.valueToJava2D(\n                this.xValue[k], dataArea, RectangleEdge.BOTTOM\n            );\n            transY = verticalAxis.valueToJava2D(\n                this.yValue[k], dataArea, RectangleEdge.LEFT\n            );\n            generalPath.lineTo((float) transX, (float) transY);\n        }\n        generalPath.closePath();\n\n        return generalPath;\n\n    }\n\n    /**\n     * Returns the composite.\n     *\n     * @return Composite\n     */\n    public Composite getComposite() {\n        return this.composite;\n    }\n\n    /**\n     * Returns the drawPaint.\n     *\n     * @return Paint\n     */\n    public Paint getDrawPaint() {\n        return this.drawPaint;\n    }\n\n    /**\n     * Returns the drawPath.\n     *\n     * @return boolean\n     */\n    public boolean isDrawPath() {\n        return this.drawPath;\n    }\n\n    /**\n     * Returns the drawStroke.\n     *\n     * @return Stroke\n     */\n    public Stroke getDrawStroke() {\n        return this.drawStroke;\n    }\n\n    /**\n     * Returns the fillPaint.\n     *\n     * @return Paint\n     */\n    public Paint getFillPaint() {\n        return this.fillPaint;\n    }\n\n    /**\n     * Returns the fillPath.\n     *\n     * @return boolean\n     */\n    public boolean isFillPath() {\n        return this.fillPath;\n    }\n\n    /**\n     * Returns the xValue.\n     *\n     * @return double[]\n     */\n    public double[] getXValue() {\n        return this.xValue;\n    }\n\n    /**\n     * Returns the yValue.\n     *\n     * @return double[]\n     */\n    public double[] getYValue() {\n        return this.yValue;\n    }\n\n    /**\n     * Sets the composite.\n     *\n     * @param composite The composite to set\n     */\n    public void setComposite(Composite composite) {\n        this.composite = composite;\n    }\n\n    /**\n     * Sets the drawPaint.\n     *\n     * @param drawPaint The drawPaint to set\n     */\n    public void setDrawPaint(Paint drawPaint) {\n        this.drawPaint = drawPaint;\n    }\n\n    /**\n     * Sets the drawPath.\n     *\n     * @param drawPath The drawPath to set\n     */\n    public void setDrawPath(boolean drawPath) {\n        this.drawPath = drawPath;\n    }\n\n    /**\n     * Sets the drawStroke.\n     *\n     * @param drawStroke The drawStroke to set\n     */\n    public void setDrawStroke(Stroke drawStroke) {\n        this.drawStroke = drawStroke;\n    }\n\n    /**\n     * Sets the fillPaint.\n     *\n     * @param fillPaint The fillPaint to set\n     */\n    public void setFillPaint(Paint fillPaint) {\n        this.fillPaint = fillPaint;\n    }\n\n    /**\n     * Sets the fillPath.\n     *\n     * @param fillPath The fillPath to set\n     */\n    public void setFillPath(boolean fillPath) {\n        this.fillPath = fillPath;\n    }\n\n    /**\n     * Sets the xValue.\n     *\n     * @param xValue The xValue to set\n     */\n    public void setXValue(double[] xValue) {\n        this.xValue = xValue;\n    }\n\n    /**\n     * Sets the yValue.\n     *\n     * @param yValue The yValue to set\n     */\n    public void setYValue(double[] yValue) {\n        this.yValue = yValue;\n    }\n\n    /**\n     * Returns the clip.\n     *\n     * @return boolean\n     */\n    public boolean isClip() {\n        return this.clip;\n    }\n\n    /**\n     * Sets the clip.\n     *\n     * @param clip The clip to set\n     */\n    public void setClip(boolean clip) {\n        this.clip = clip;\n    }\n\n    /**\n     * Returns a clone of the object (a deeper clone than default to avoid bugs\n     * when setting values in cloned object).\n     *\n     * @return The clone.\n     *\n     * @throws CloneNotSupportedException if cloning is not supported.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        ClipPath clone = (ClipPath) super.clone();\n        clone.xValue = (double[]) this.xValue.clone();\n        clone.yValue = (double[]) this.yValue.clone();\n        return clone;\n    }\n\n\t/**\n\t * Sets the flag indicating whether or not the domain crosshair should\n\t * \"lock-on\" to actual data values.\n\t *\n\t * @param contourPlot TODO\n\t * @param flag  the flag.\n\t */\n\tpublic void setDomainCrosshairLockedOnData(ContourPlot contourPlot, boolean flag) {\n\t    if (contourPlot.domainCrosshairLockedOnData != flag) {\n\t        contourPlot.domainCrosshairLockedOnData = flag;\n\t        contourPlot.fireChangeEvent();\n\t    }\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 439,
                        "lineEnd": 451,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.ContourPlot\nRationale: The method directly manipulates the 'domainCrosshairLockedOnData' property of the ContourPlot class and triggers a change event, indicating it is closely related to the state and behavior of ContourPlot.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5315
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setDomainCrosshairLockedOnData",
                            "method_signature": "public void setDomainCrosshairLockedOnData(ContourPlot contourPlot, boolean flag)",
                            "target_class": "ContourPlot",
                            "rationale": "The method setDomainCrosshairLockedOnData directly manipulates the state of a ContourPlot instance, making it more appropriate to be part of the ContourPlot class rather than the ClipPath class."
                        }
                    ],
                    "llm_response_time": 1547
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setDomainCrosshairLockedOnData",
                            "method_signature": "public void setDomainCrosshairLockedOnData(ContourPlot contourPlot, boolean flag)",
                            "target_class": "ContourPlot",
                            "rationale": "The method setDomainCrosshairLockedOnData directly manipulates the state of a ContourPlot instance, making it more appropriate to be part of the ContourPlot class rather than ClipPath."
                        }
                    ],
                    "llm_response_time": 1225
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setDomainCrosshairLockedOnData",
                            "method_signature": "public void setDomainCrosshairLockedOnData(ContourPlot contourPlot, boolean flag)",
                            "target_class": "ContourPlot",
                            "rationale": "The method setDomainCrosshairLockedOnData directly manipulates the state of a ContourPlot instance, making it more appropriate to be part of the ContourPlot class rather than the ClipPath class."
                        }
                    ],
                    "llm_response_time": 1755
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setDomainCrosshairLockedOnData",
                            "method_signature": "public void setDomainCrosshairLockedOnData(ContourPlot contourPlot, boolean flag)",
                            "target_class": "ContourPlot",
                            "rationale": "The method setDomainCrosshairLockedOnData directly manipulates the state of a ContourPlot instance, making it more appropriate to be part of the ContourPlot class rather than the ClipPath class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setDomainCrosshairLockedOnData"
                ],
                "llm_response_time": 695
            },
            "targetClassMap": {
                "setDomainCrosshairLockedOnData": {
                    "target_classes": [
                        {
                            "class_name": "ContourPlot",
                            "similarity_score": 0.7656787843366891
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ContourPlot"
                    ],
                    "llm_response_time": 1205,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "- method org.jfree.data.Range::getItemCount(int):int need move org.jfree.data.time.DynamicTimeSeriesCollection",
        "class_name": "org.jfree.data.Range",
        "telemetry": {
            "id": "1991cf4e-c7a8-43d0-97fe-bb4f05d2171b",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 359,
                "lineStart": 68,
                "lineEnd": 426,
                "bodyLineStart": 68,
                "language": "java",
                "sourceCode": "/**\n * Represents an immutable range of values.\n */\npublic strictfp class Range implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -906333695431863380L;\n\n    /** The lower bound of the range. */\n    private double lower;\n\n    /** The upper bound of the range. */\n    private double upper;\n\n    /**\n     * Creates a new range.\n     *\n     * @param lower  the lower bound (must be <= upper bound).\n     * @param upper  the upper bound (must be >= lower bound).\n     */\n    public Range(double lower, double upper) {\n        if (lower > upper) {\n            String msg = \"Range(double, double): require lower (\" + lower\n                + \") <= upper (\" + upper + \").\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.lower = lower;\n        this.upper = upper;\n    }\n\n    /**\n     * Returns the lower bound for the range.\n     *\n     * @return The lower bound.\n     */\n    public double getLowerBound() {\n        return this.lower;\n    }\n\n    /**\n     * Returns the upper bound for the range.\n     *\n     * @return The upper bound.\n     */\n    public double getUpperBound() {\n        return this.upper;\n    }\n\n    /**\n     * Returns the length of the range.\n     *\n     * @return The length.\n     */\n    public double getLength() {\n        return this.upper - this.lower;\n    }\n\n    /**\n     * Returns the central value for the range.\n     *\n     * @return The central value.\n     */\n    public double getCentralValue() {\n        return this.lower / 2.0 + this.upper / 2.0;\n    }\n\n    /**\n     * Returns <code>true</code> if the range contains the specified value and\n     * <code>false</code> otherwise.\n     *\n     * @param value  the value to lookup.\n     *\n     * @return <code>true</code> if the range contains the specified value.\n     */\n    public boolean contains(double value) {\n        return (value >= this.lower && value <= this.upper);\n    }\n\n    /**\n     * Returns <code>true</code> if the range intersects with the specified\n     * range, and <code>false</code> otherwise.\n     *\n     * @param b0  the lower bound (should be <= b1).\n     * @param b1  the upper bound (should be >= b0).\n     *\n     * @return A boolean.\n     */\n    public boolean intersects(double b0, double b1) {\n        if (b0 <= this.lower) {\n            return (b1 > this.lower);\n        }\n        else {\n            return (b0 < this.upper && b1 >= b0);\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if the range intersects with the specified\n     * range, and <code>false</code> otherwise.\n     *\n     * @param range  another range (<code>null</code> not permitted).\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.9\n     */\n    public boolean intersects(Range range) {\n        return intersects(range.getLowerBound(), range.getUpperBound());\n    }\n\n    /**\n     * Returns the value within the range that is closest to the specified\n     * value.\n     *\n     * @param value  the value.\n     *\n     * @return The constrained value.\n     */\n    public double constrain(double value) {\n        double result = value;\n        if (!contains(value)) {\n            if (value > this.upper) {\n                result = this.upper;\n            }\n            else if (value < this.lower) {\n                result = this.lower;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new range by combining two existing ranges.\n     * <P>\n     * Note that:\n     * <ul>\n     *   <li>either range can be <code>null</code>, in which case the other\n     *       range is returned;</li>\n     *   <li>if both ranges are <code>null</code> the return value is\n     *       <code>null</code>.</li>\n     * </ul>\n     *\n     * @param range1  the first range (<code>null</code> permitted).\n     * @param range2  the second range (<code>null</code> permitted).\n     *\n     * @return A new range (possibly <code>null</code>).\n     */\n    public static Range combine(Range range1, Range range2) {\n        if (range1 == null) {\n            return range2;\n        }\n        else {\n            if (range2 == null) {\n                return range1;\n            }\n            else {\n                double l = Math.min(range1.getLowerBound(),\n                        range2.getLowerBound());\n                double u = Math.max(range1.getUpperBound(),\n                        range2.getUpperBound());\n                return new Range(l, u);\n            }\n        }\n    }\n\n    /**\n     * Returns a range that includes all the values in the specified\n     * <code>range</code> AND the specified <code>value</code>.\n     *\n     * @param range  the range (<code>null</code> permitted).\n     * @param value  the value that must be included.\n     *\n     * @return A range.\n     *\n     * @since 1.0.1\n     */\n    public static Range expandToInclude(Range range, double value) {\n        if (range == null) {\n            return new Range(value, value);\n        }\n        if (value < range.getLowerBound()) {\n            return new Range(value, range.getUpperBound());\n        }\n        else if (value > range.getUpperBound()) {\n            return new Range(range.getLowerBound(), value);\n        }\n        else {\n            return range;\n        }\n    }\n\n    /**\n     * Creates a new range by adding margins to an existing range.\n     *\n     * @param range  the range (<code>null</code> not permitted).\n     * @param lowerMargin  the lower margin (expressed as a percentage of the\n     *                     range length).\n     * @param upperMargin  the upper margin (expressed as a percentage of the\n     *                     range length).\n     *\n     * @return The expanded range.\n     */\n    public static Range expand(Range range,\n                               double lowerMargin, double upperMargin) {\n        if (range == null) {\n            throw new IllegalArgumentException(\"Null 'range' argument.\");\n        }\n        double length = range.getLength();\n        double lower = range.getLowerBound() - length * lowerMargin;\n        double upper = range.getUpperBound() + length * upperMargin;\n        if (lower > upper) {\n            lower = lower / 2.0 + upper / 2.0;\n            upper = lower;\n        }\n        return new Range(lower, upper);\n    }\n\n    /**\n     * Shifts the range by the specified amount.\n     *\n     * @param base  the base range (<code>null</code> not permitted).\n     * @param delta  the shift amount.\n     *\n     * @return A new range.\n     */\n    public static Range shift(Range base, double delta) {\n        return shift(base, delta, false);\n    }\n\n    /**\n     * Shifts the range by the specified amount.\n     *\n     * @param base  the base range (<code>null</code> not permitted).\n     * @param delta  the shift amount.\n     * @param allowZeroCrossing  a flag that determines whether or not the\n     *                           bounds of the range are allowed to cross\n     *                           zero after adjustment.\n     *\n     * @return A new range.\n     */\n    public static Range shift(Range base, double delta,\n                              boolean allowZeroCrossing) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Null 'base' argument.\");\n        }\n        if (allowZeroCrossing) {\n            return new Range(base.getLowerBound() + delta,\n                    base.getUpperBound() + delta);\n        }\n        else {\n            return new Range(shiftWithNoZeroCrossing(base.getLowerBound(),\n                    delta), shiftWithNoZeroCrossing(base.getUpperBound(),\n                    delta));\n        }\n    }\n\n    /**\n     * Returns the given <code>value</code> adjusted by <code>delta</code> but\n     * with a check to prevent the result from crossing <code>0.0</code>.\n     *\n     * @param value  the value.\n     * @param delta  the adjustment.\n     *\n     * @return The adjusted value.\n     */\n    private static double shiftWithNoZeroCrossing(double value, double delta) {\n        if (value > 0.0) {\n            return Math.max(value + delta, 0.0);\n        }\n        else if (value < 0.0) {\n            return Math.min(value + delta, 0.0);\n        }\n        else {\n            return value + delta;\n        }\n    }\n\n    /**\n     * Scales the range by the specified factor.\n     *\n     * @param base the base range (<code>null</code> not permitted).\n     * @param factor the scaling factor (must be non-negative).\n     *\n     * @return A new range.\n     *\n     * @since 1.0.9\n     */\n    public static Range scale(Range base, double factor) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Null 'base' argument.\");\n        }\n        if (factor < 0) {\n            throw new IllegalArgumentException(\"Negative 'factor' argument.\");\n        }\n        return new Range(base.getLowerBound() * factor,\n                base.getUpperBound() * factor);\n    }\n\n    /**\n     * Tests this object for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Range)) {\n            return false;\n        }\n        Range range = (Range) obj;\n        if (!(this.lower == range.lower)) {\n            return false;\n        }\n        if (!(this.upper == range.upper)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        long temp;\n        temp = Double.doubleToLongBits(this.lower);\n        result = (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(this.upper);\n        result = 29 * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }\n\n    /**\n     * Returns a string representation of this Range.\n     *\n     * @return A String \"Range[lower,upper]\" where lower=lower range and\n     *         upper=upper range.\n     */\n    public String toString() {\n        return (\"Range[\" + this.lower + \",\" + this.upper + \"]\");\n    }\n\n\t/**\n\t * Returns the number of items in a series.\n\t * <p>\n\t * For this implementation, all series have the same number of items.\n\t *\n\t * @param dynamicTimeSeriesCollection TODO\n\t * @param series  the series index (zero-based).\n\t * @return The item count.\n\t */\n\tpublic int getItemCount(DynamicTimeSeriesCollection dynamicTimeSeriesCollection, int series) {  // all arrays equal length,\n\t                                       // so ignore argument:\n\t    return dynamicTimeSeriesCollection.historyCount;\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 411,
                        "lineEnd": 423,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.data.time.DynamicTimeSeriesCollection\nRationale: The method getItemCount directly operates on the properties of the DynamicTimeSeriesCollection class, specifically accessing its historyCount attribute. It is logical for this method to reside within the class that it is primarily concerned with.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5060
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getItemCount",
                            "method_signature": "public int getItemCount(DynamicTimeSeriesCollection dynamicTimeSeriesCollection, int series)",
                            "target_class": "DynamicTimeSeriesCollection",
                            "rationale": "The getItemCount method is specific to the DynamicTimeSeriesCollection and should be moved there to maintain the Single Responsibility Principle and encapsulate the logic related to time series data."
                        }
                    ],
                    "llm_response_time": 1470
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getItemCount",
                            "method_signature": "public int getItemCount(DynamicTimeSeriesCollection dynamicTimeSeriesCollection, int series)",
                            "target_class": "DynamicTimeSeriesCollection",
                            "rationale": "The getItemCount method is specific to the DynamicTimeSeriesCollection and should be moved there to maintain the Single Responsibility Principle and encapsulate the logic related to time series data."
                        }
                    ],
                    "llm_response_time": 1271
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "getItemCount",
                            "method_signature": "public int getItemCount(DynamicTimeSeriesCollection dynamicTimeSeriesCollection, int series)",
                            "target_class": "DynamicTimeSeriesCollection",
                            "rationale": "The getItemCount method is specific to the DynamicTimeSeriesCollection and should be moved there to maintain cohesion and encapsulation."
                        }
                    ],
                    "llm_response_time": 1641
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getItemCount",
                            "method_signature": "public int getItemCount(DynamicTimeSeriesCollection dynamicTimeSeriesCollection, int series)",
                            "target_class": "DynamicTimeSeriesCollection",
                            "rationale": "The getItemCount method is specific to the DynamicTimeSeriesCollection and should be moved there to maintain the Single Responsibility Principle and encapsulate the logic related to time series data."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "getItemCount"
                ],
                "llm_response_time": 607
            },
            "targetClassMap": {
                "getItemCount": {
                    "target_classes": [
                        {
                            "class_name": "DynamicTimeSeriesCollection",
                            "similarity_score": 0.7765641592002399
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "DynamicTimeSeriesCollection"
                    ],
                    "llm_response_time": 943,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.ChartPanel::setFollowDataInSubranges(boolean):void need move org.jfree.chart.plot.JThermometer",
        "class_name": "org.jfree.chart.ChartPanel",
        "telemetry": {
            "id": "73ccaf27-3d3f-4284-bcbd-974121be3f52",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 2888,
                "lineStart": 240,
                "lineEnd": 3127,
                "bodyLineStart": 240,
                "language": "java",
                "sourceCode": "/**\n * A Swing GUI component for displaying a {@link JFreeChart} object.\n * <P>\n * The panel registers with the chart to receive notification of changes to any\n * component of the chart.  The chart is redrawn automatically whenever this\n * notification is received.\n */\npublic class ChartPanel extends JPanel implements ChartChangeListener,\n        ChartProgressListener, ActionListener, MouseListener,\n        MouseMotionListener, OverlayChangeListener, Printable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 6046366297214274674L;\n\n    /**\n     * Default setting for buffer usage.  The default has been changed to\n     * <code>true</code> from version 1.0.13 onwards, because of a severe\n     * performance problem with drawing the zoom rectangle using XOR (which\n     * now happens only when the buffer is NOT used).\n     */\n    public static final boolean DEFAULT_BUFFER_USED = true;\n\n    /** The default panel width. */\n    public static final int DEFAULT_WIDTH = 680;\n\n    /** The default panel height. */\n    public static final int DEFAULT_HEIGHT = 420;\n\n    /** The default limit below which chart scaling kicks in. */\n    public static final int DEFAULT_MINIMUM_DRAW_WIDTH = 300;\n\n    /** The default limit below which chart scaling kicks in. */\n    public static final int DEFAULT_MINIMUM_DRAW_HEIGHT = 200;\n\n    /** The default limit above which chart scaling kicks in. */\n    public static final int DEFAULT_MAXIMUM_DRAW_WIDTH = 1024;\n\n    /** The default limit above which chart scaling kicks in. */\n    public static final int DEFAULT_MAXIMUM_DRAW_HEIGHT = 768;\n\n    /** The minimum size required to perform a zoom on a rectangle */\n    public static final int DEFAULT_ZOOM_TRIGGER_DISTANCE = 10;\n\n    /** Properties action command. */\n    public static final String PROPERTIES_COMMAND = \"PROPERTIES\";\n\n    /**\n     * Copy action command.\n     *\n     * @since 1.0.13\n     */\n    public static final String COPY_COMMAND = \"COPY\";\n\n    /** Save action command. */\n    public static final String SAVE_COMMAND = \"SAVE\";\n\n    /** Print action command. */\n    public static final String PRINT_COMMAND = \"PRINT\";\n\n    /** Zoom in (both axes) action command. */\n    public static final String ZOOM_IN_BOTH_COMMAND = \"ZOOM_IN_BOTH\";\n\n    /** Zoom in (domain axis only) action command. */\n    public static final String ZOOM_IN_DOMAIN_COMMAND = \"ZOOM_IN_DOMAIN\";\n\n    /** Zoom in (range axis only) action command. */\n    public static final String ZOOM_IN_RANGE_COMMAND = \"ZOOM_IN_RANGE\";\n\n    /** Zoom out (both axes) action command. */\n    public static final String ZOOM_OUT_BOTH_COMMAND = \"ZOOM_OUT_BOTH\";\n\n    /** Zoom out (domain axis only) action command. */\n    public static final String ZOOM_OUT_DOMAIN_COMMAND = \"ZOOM_DOMAIN_BOTH\";\n\n    /** Zoom out (range axis only) action command. */\n    public static final String ZOOM_OUT_RANGE_COMMAND = \"ZOOM_RANGE_BOTH\";\n\n    /** Zoom reset (both axes) action command. */\n    public static final String ZOOM_RESET_BOTH_COMMAND = \"ZOOM_RESET_BOTH\";\n\n    /** Zoom reset (domain axis only) action command. */\n    public static final String ZOOM_RESET_DOMAIN_COMMAND = \"ZOOM_RESET_DOMAIN\";\n\n    /** Zoom reset (range axis only) action command. */\n    public static final String ZOOM_RESET_RANGE_COMMAND = \"ZOOM_RESET_RANGE\";\n\n    /** The chart that is displayed in the panel. */\n    private JFreeChart chart;\n\n    /** Storage for registered (chart) mouse listeners. */\n    private transient EventListenerList chartMouseListeners;\n\n    /** A flag that controls whether or not the off-screen buffer is used. */\n    private boolean useBuffer;\n\n    /** A flag that indicates that the buffer should be refreshed. */\n    private boolean refreshBuffer;\n\n    /** A buffer for the rendered chart. */\n    private transient Image chartBuffer;\n\n    /** The height of the chart buffer. */\n    private int chartBufferHeight;\n\n    /** The width of the chart buffer. */\n    private int chartBufferWidth;\n\n    /**\n     * The minimum width for drawing a chart (uses scaling for smaller widths).\n     */\n    private int minimumDrawWidth;\n\n    /**\n     * The minimum height for drawing a chart (uses scaling for smaller\n     * heights).\n     */\n    private int minimumDrawHeight;\n\n    /**\n     * The maximum width for drawing a chart (uses scaling for bigger\n     * widths).\n     */\n    private int maximumDrawWidth;\n\n    /**\n     * The maximum height for drawing a chart (uses scaling for bigger\n     * heights).\n     */\n    private int maximumDrawHeight;\n\n    /** The popup menu for the frame. */\n    private JPopupMenu popup;\n\n    /** The drawing info collected the last time the chart was drawn. */\n    private ChartRenderingInfo info;\n\n    /** The chart anchor point. */\n    private Point2D anchor;\n\n    /** The scale factor used to draw the chart. */\n    private double scaleX;\n\n    /** The scale factor used to draw the chart. */\n    private double scaleY;\n\n    /** The plot orientation. */\n    private PlotOrientation orientation = PlotOrientation.VERTICAL;\n\n    /** A flag that controls whether or not domain zooming is enabled. */\n    private boolean domainZoomable = false;\n\n    /** A flag that controls whether or not range zooming is enabled. */\n    private boolean rangeZoomable = false;\n\n    /**\n     * The zoom rectangle starting point (selected by the user with a mouse\n     * click).  This is a point on the screen, not the chart (which may have\n     * been scaled up or down to fit the panel).\n     */\n    private Point2D zoomPoint = null;\n\n    /** The zoom rectangle (selected by the user with the mouse). */\n    private transient Rectangle2D zoomRectangle = null;\n\n    /** Controls if the zoom rectangle is drawn as an outline or filled. */\n    private boolean fillZoomRectangle = true;\n\n    /** The minimum distance required to drag the mouse to trigger a zoom. */\n    private int zoomTriggerDistance;\n\n    /** A flag that controls whether or not horizontal tracing is enabled. */\n    private boolean horizontalAxisTrace = false;\n\n    /** A flag that controls whether or not vertical tracing is enabled. */\n    private boolean verticalAxisTrace = false;\n\n    /** A vertical trace line. */\n    private transient Line2D verticalTraceLine;\n\n    /** A horizontal trace line. */\n    private transient Line2D horizontalTraceLine;\n\n    /** Menu item for zooming in on a chart (both axes). */\n    private JMenuItem zoomInBothMenuItem;\n\n    /** Menu item for zooming in on a chart (domain axis). */\n    private JMenuItem zoomInDomainMenuItem;\n\n    /** Menu item for zooming in on a chart (range axis). */\n    private JMenuItem zoomInRangeMenuItem;\n\n    /** Menu item for zooming out on a chart. */\n    private JMenuItem zoomOutBothMenuItem;\n\n    /** Menu item for zooming out on a chart (domain axis). */\n    private JMenuItem zoomOutDomainMenuItem;\n\n    /** Menu item for zooming out on a chart (range axis). */\n    private JMenuItem zoomOutRangeMenuItem;\n\n    /** Menu item for resetting the zoom (both axes). */\n    private JMenuItem zoomResetBothMenuItem;\n\n    /** Menu item for resetting the zoom (domain axis only). */\n    private JMenuItem zoomResetDomainMenuItem;\n\n    /** Menu item for resetting the zoom (range axis only). */\n    private JMenuItem zoomResetRangeMenuItem;\n\n    /**\n     * The default directory for saving charts to file.\n     *\n     * @since 1.0.7\n     */\n    private File defaultDirectoryForSaveAs;\n\n    /** A flag that controls whether or not file extensions are enforced. */\n    private boolean enforceFileExtensions;\n\n    /** A flag that indicates if original tooltip delays are changed. */\n    private boolean ownToolTipDelaysActive;\n\n    /** Original initial tooltip delay of ToolTipManager.sharedInstance(). */\n    private int originalToolTipInitialDelay;\n\n    /** Original reshow tooltip delay of ToolTipManager.sharedInstance(). */\n    private int originalToolTipReshowDelay;\n\n    /** Original dismiss tooltip delay of ToolTipManager.sharedInstance(). */\n    private int originalToolTipDismissDelay;\n\n    /** Own initial tooltip delay to be used in this chart panel. */\n    private int ownToolTipInitialDelay;\n\n    /** Own reshow tooltip delay to be used in this chart panel. */\n    private int ownToolTipReshowDelay;\n\n    /** Own dismiss tooltip delay to be used in this chart panel. */\n    private int ownToolTipDismissDelay;\n\n    /** The factor used to zoom in on an axis range. */\n    private double zoomInFactor = 0.5;\n\n    /** The factor used to zoom out on an axis range. */\n    private double zoomOutFactor = 2.0;\n\n    /**\n     * A flag that controls whether zoom operations are centred on the\n     * current anchor point, or the centre point of the relevant axis.\n     *\n     * @since 1.0.7\n     */\n    private boolean zoomAroundAnchor;\n\n    /**\n     * The paint used to draw the zoom rectangle outline.\n     *\n     * @since 1.0.13\n     */\n    private transient Paint zoomOutlinePaint;\n\n    /**\n     * The zoom fill paint (should use transparency).\n     *\n     * @since 1.0.13\n     */\n    private transient Paint zoomFillPaint;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources\n            = ResourceBundleWrapper.getBundle(\n                    \"org.jfree.chart.LocalizationBundle\");\n\n    /** \n     * Temporary storage for the width and height of the chart \n     * drawing area during panning.\n     */\n    private double panW, panH;\n\n    /** The last mouse position during panning. */\n    private Point panLast;\n\n    /**\n     * The mask for mouse events to trigger panning.\n     *\n     * @since 1.0.13\n     */\n    private int panMask = InputEvent.CTRL_MASK;\n\n    /**\n     * A list of overlays for the panel.\n     *\n     * @since 1.0.13\n     */\n    private List overlays;\n\n    /**\n     * Constructs a panel that displays the specified chart.\n     *\n     * @param chart  the chart.\n     */\n    public ChartPanel(JFreeChart chart) {\n\n        this(\n            chart,\n            DEFAULT_WIDTH,\n            DEFAULT_HEIGHT,\n            DEFAULT_MINIMUM_DRAW_WIDTH,\n            DEFAULT_MINIMUM_DRAW_HEIGHT,\n            DEFAULT_MAXIMUM_DRAW_WIDTH,\n            DEFAULT_MAXIMUM_DRAW_HEIGHT,\n            DEFAULT_BUFFER_USED,\n            true,  // properties\n            true,  // save\n            true,  // print\n            true,  // zoom\n            true   // tooltips\n        );\n\n    }\n\n    /**\n     * Constructs a panel containing a chart.  The <code>useBuffer</code> flag\n     * controls whether or not an offscreen <code>BufferedImage</code> is\n     * maintained for the chart.  If the buffer is used, more memory is\n     * consumed, but panel repaints will be a lot quicker in cases where the\n     * chart itself hasn't changed (for example, when another frame is moved\n     * to reveal the panel).  WARNING: If you set the <code>useBuffer</code>\n     * flag to false, note that the mouse zooming rectangle will (in that case)\n     * be drawn using XOR, and there is a SEVERE performance problem with that\n     * on JRE6 on Windows.\n     *\n     * @param chart  the chart.\n     * @param useBuffer  a flag controlling whether or not an off-screen buffer\n     *                   is used (read the warning above before setting this\n     *                   to <code>false</code>).\n     */\n    public ChartPanel(JFreeChart chart, boolean useBuffer) {\n\n        this(chart, DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_MINIMUM_DRAW_WIDTH,\n                DEFAULT_MINIMUM_DRAW_HEIGHT, DEFAULT_MAXIMUM_DRAW_WIDTH,\n                DEFAULT_MAXIMUM_DRAW_HEIGHT, useBuffer,\n                true,  // properties\n                true,  // save\n                true,  // print\n                true,  // zoom\n                true   // tooltips\n                );\n\n    }\n\n    /**\n     * Constructs a JFreeChart panel.\n     *\n     * @param chart  the chart.\n     * @param properties  a flag indicating whether or not the chart property\n     *                    editor should be available via the popup menu.\n     * @param save  a flag indicating whether or not save options should be\n     *              available via the popup menu.\n     * @param print  a flag indicating whether or not the print option\n     *               should be available via the popup menu.\n     * @param zoom  a flag indicating whether or not zoom options should\n     *              be added to the popup menu.\n     * @param tooltips  a flag indicating whether or not tooltips should be\n     *                  enabled for the chart.\n     */\n    public ChartPanel(JFreeChart chart,\n                      boolean properties,\n                      boolean save,\n                      boolean print,\n                      boolean zoom,\n                      boolean tooltips) {\n\n        this(chart,\n             DEFAULT_WIDTH,\n             DEFAULT_HEIGHT,\n             DEFAULT_MINIMUM_DRAW_WIDTH,\n             DEFAULT_MINIMUM_DRAW_HEIGHT,\n             DEFAULT_MAXIMUM_DRAW_WIDTH,\n             DEFAULT_MAXIMUM_DRAW_HEIGHT,\n             DEFAULT_BUFFER_USED,\n             properties,\n             save,\n             print,\n             zoom,\n             tooltips\n             );\n\n    }\n\n    /**\n     * Constructs a JFreeChart panel.\n     *\n     * @param chart  the chart.\n     * @param width  the preferred width of the panel.\n     * @param height  the preferred height of the panel.\n     * @param minimumDrawWidth  the minimum drawing width.\n     * @param minimumDrawHeight  the minimum drawing height.\n     * @param maximumDrawWidth  the maximum drawing width.\n     * @param maximumDrawHeight  the maximum drawing height.\n     * @param useBuffer  a flag that indicates whether to use the off-screen\n     *                   buffer to improve performance (at the expense of\n     *                   memory).\n     * @param properties  a flag indicating whether or not the chart property\n     *                    editor should be available via the popup menu.\n     * @param save  a flag indicating whether or not save options should be\n     *              available via the popup menu.\n     * @param print  a flag indicating whether or not the print option\n     *               should be available via the popup menu.\n     * @param zoom  a flag indicating whether or not zoom options should be\n     *              added to the popup menu.\n     * @param tooltips  a flag indicating whether or not tooltips should be\n     *                  enabled for the chart.\n     */\n    public ChartPanel(JFreeChart chart, int width, int height,\n            int minimumDrawWidth, int minimumDrawHeight, int maximumDrawWidth,\n            int maximumDrawHeight, boolean useBuffer, boolean properties,\n            boolean save, boolean print, boolean zoom, boolean tooltips) {\n\n        this(chart, width, height, minimumDrawWidth, minimumDrawHeight,\n                maximumDrawWidth, maximumDrawHeight, useBuffer, properties,\n                true, save, print, zoom, tooltips);\n    }\n\n    /**\n     * Constructs a JFreeChart panel.\n     *\n     * @param chart  the chart.\n     * @param width  the preferred width of the panel.\n     * @param height  the preferred height of the panel.\n     * @param minimumDrawWidth  the minimum drawing width.\n     * @param minimumDrawHeight  the minimum drawing height.\n     * @param maximumDrawWidth  the maximum drawing width.\n     * @param maximumDrawHeight  the maximum drawing height.\n     * @param useBuffer  a flag that indicates whether to use the off-screen\n     *                   buffer to improve performance (at the expense of\n     *                   memory).\n     * @param properties  a flag indicating whether or not the chart property\n     *                    editor should be available via the popup menu.\n     * @param copy  a flag indicating whether or not a copy option should be\n     *              available via the popup menu.\n     * @param save  a flag indicating whether or not save options should be\n     *              available via the popup menu.\n     * @param print  a flag indicating whether or not the print option\n     *               should be available via the popup menu.\n     * @param zoom  a flag indicating whether or not zoom options should be\n     *              added to the popup menu.\n     * @param tooltips  a flag indicating whether or not tooltips should be\n     *                  enabled for the chart.\n     *\n     * @since 1.0.13\n     */\n    public ChartPanel(JFreeChart chart, int width, int height,\n           int minimumDrawWidth, int minimumDrawHeight, int maximumDrawWidth,\n           int maximumDrawHeight, boolean useBuffer, boolean properties,\n           boolean copy, boolean save, boolean print, boolean zoom,\n           boolean tooltips) {\n\n        setChart(chart);\n        this.chartMouseListeners = new EventListenerList();\n        this.info = new ChartRenderingInfo();\n        setPreferredSize(new Dimension(width, height));\n        this.useBuffer = useBuffer;\n        this.refreshBuffer = false;\n        this.minimumDrawWidth = minimumDrawWidth;\n        this.minimumDrawHeight = minimumDrawHeight;\n        this.maximumDrawWidth = maximumDrawWidth;\n        this.maximumDrawHeight = maximumDrawHeight;\n        this.zoomTriggerDistance = DEFAULT_ZOOM_TRIGGER_DISTANCE;\n\n        // set up popup menu...\n        this.popup = null;\n        if (properties || copy || save || print || zoom) {\n            this.popup = createPopupMenu(properties, copy, save, print, zoom);\n        }\n\n        enableEvents(AWTEvent.MOUSE_EVENT_MASK);\n        enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);\n        setDisplayToolTips(tooltips);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n\n        this.defaultDirectoryForSaveAs = null;\n        this.enforceFileExtensions = true;\n\n        // initialize ChartPanel-specific tool tip delays with\n        // values the from ToolTipManager.sharedInstance()\n        ToolTipManager ttm = ToolTipManager.sharedInstance();\n        this.ownToolTipInitialDelay = ttm.getInitialDelay();\n        this.ownToolTipDismissDelay = ttm.getDismissDelay();\n        this.ownToolTipReshowDelay = ttm.getReshowDelay();\n\n        this.zoomAroundAnchor = false;\n        this.zoomOutlinePaint = Color.blue;\n        this.zoomFillPaint = new Color(0, 0, 255, 63);\n\n        this.panMask = InputEvent.CTRL_MASK;\n        // for MacOSX we can't use the CTRL key for mouse drags, see:\n        // http://developer.apple.com/qa/qa2004/qa1362.html\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        if (osName.startsWith(\"mac os x\")) {\n            this.panMask = InputEvent.ALT_MASK;\n        }\n\n        this.overlays = new java.util.ArrayList();\n    }\n\n    /**\n     * Returns the chart contained in the panel.\n     *\n     * @return The chart (possibly <code>null</code>).\n     */\n    public JFreeChart getChart() {\n        return this.chart;\n    }\n\n    /**\n     * Sets the chart that is displayed in the panel.\n     *\n     * @param chart  the chart (<code>null</code> permitted).\n     */\n    public void setChart(JFreeChart chart) {\n\n        // stop listening for changes to the existing chart\n        if (this.chart != null) {\n            this.chart.removeChangeListener(this);\n            this.chart.removeProgressListener(this);\n        }\n\n        // add the new chart\n        this.chart = chart;\n        if (chart != null) {\n            this.chart.addChangeListener(this);\n            this.chart.addProgressListener(this);\n            Plot plot = chart.getPlot();\n            this.domainZoomable = false;\n            this.rangeZoomable = false;\n            if (plot instanceof Zoomable) {\n                Zoomable z = (Zoomable) plot;\n                this.domainZoomable = z.isDomainZoomable();\n                this.rangeZoomable = z.isRangeZoomable();\n                this.orientation = z.getOrientation();\n            }\n        }\n        else {\n            this.domainZoomable = false;\n            this.rangeZoomable = false;\n        }\n        if (this.useBuffer) {\n            this.refreshBuffer = true;\n        }\n        repaint();\n\n    }\n\n    /**\n     * Returns the minimum drawing width for charts.\n     * <P>\n     * If the width available on the panel is less than this, then the chart is\n     * drawn at the minimum width then scaled down to fit.\n     *\n     * @return The minimum drawing width.\n     */\n    public int getMinimumDrawWidth() {\n        return this.minimumDrawWidth;\n    }\n\n    /**\n     * Sets the minimum drawing width for the chart on this panel.\n     * <P>\n     * At the time the chart is drawn on the panel, if the available width is\n     * less than this amount, the chart will be drawn using the minimum width\n     * then scaled down to fit the available space.\n     *\n     * @param width  The width.\n     */\n    public void setMinimumDrawWidth(int width) {\n        this.minimumDrawWidth = width;\n    }\n\n    /**\n     * Returns the maximum drawing width for charts.\n     * <P>\n     * If the width available on the panel is greater than this, then the chart\n     * is drawn at the maximum width then scaled up to fit.\n     *\n     * @return The maximum drawing width.\n     */\n    public int getMaximumDrawWidth() {\n        return this.maximumDrawWidth;\n    }\n\n    /**\n     * Sets the maximum drawing width for the chart on this panel.\n     * <P>\n     * At the time the chart is drawn on the panel, if the available width is\n     * greater than this amount, the chart will be drawn using the maximum\n     * width then scaled up to fit the available space.\n     *\n     * @param width  The width.\n     */\n    public void setMaximumDrawWidth(int width) {\n        this.maximumDrawWidth = width;\n    }\n\n    /**\n     * Returns the minimum drawing height for charts.\n     * <P>\n     * If the height available on the panel is less than this, then the chart\n     * is drawn at the minimum height then scaled down to fit.\n     *\n     * @return The minimum drawing height.\n     */\n    public int getMinimumDrawHeight() {\n        return this.minimumDrawHeight;\n    }\n\n    /**\n     * Sets the minimum drawing height for the chart on this panel.\n     * <P>\n     * At the time the chart is drawn on the panel, if the available height is\n     * less than this amount, the chart will be drawn using the minimum height\n     * then scaled down to fit the available space.\n     *\n     * @param height  The height.\n     */\n    public void setMinimumDrawHeight(int height) {\n        this.minimumDrawHeight = height;\n    }\n\n    /**\n     * Returns the maximum drawing height for charts.\n     * <P>\n     * If the height available on the panel is greater than this, then the\n     * chart is drawn at the maximum height then scaled up to fit.\n     *\n     * @return The maximum drawing height.\n     */\n    public int getMaximumDrawHeight() {\n        return this.maximumDrawHeight;\n    }\n\n    /**\n     * Sets the maximum drawing height for the chart on this panel.\n     * <P>\n     * At the time the chart is drawn on the panel, if the available height is\n     * greater than this amount, the chart will be drawn using the maximum\n     * height then scaled up to fit the available space.\n     *\n     * @param height  The height.\n     */\n    public void setMaximumDrawHeight(int height) {\n        this.maximumDrawHeight = height;\n    }\n\n    /**\n     * Returns the X scale factor for the chart.  This will be 1.0 if no\n     * scaling has been used.\n     *\n     * @return The scale factor.\n     */\n    public double getScaleX() {\n        return this.scaleX;\n    }\n\n    /**\n     * Returns the Y scale factory for the chart.  This will be 1.0 if no\n     * scaling has been used.\n     *\n     * @return The scale factor.\n     */\n    public double getScaleY() {\n        return this.scaleY;\n    }\n\n    /**\n     * Returns the anchor point.\n     *\n     * @return The anchor point (possibly <code>null</code>).\n     */\n    public Point2D getAnchor() {\n        return this.anchor;\n    }\n\n    /**\n     * Sets the anchor point.  This method is provided for the use of\n     * subclasses, not end users.\n     *\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     */\n    protected void setAnchor(Point2D anchor) {\n        this.anchor = anchor;\n    }\n\n    /**\n     * Returns the popup menu.\n     *\n     * @return The popup menu.\n     */\n    public JPopupMenu getPopupMenu() {\n        return this.popup;\n    }\n\n    /**\n     * Sets the popup menu for the panel.\n     *\n     * @param popup  the popup menu (<code>null</code> permitted).\n     */\n    public void setPopupMenu(JPopupMenu popup) {\n        this.popup = popup;\n    }\n\n    /**\n     * Returns the chart rendering info from the most recent chart redraw.\n     *\n     * @return The chart rendering info.\n     */\n    public ChartRenderingInfo getChartRenderingInfo() {\n        return this.info;\n    }\n\n    /**\n     * A convenience method that switches on mouse-based zooming.\n     *\n     * @param flag  <code>true</code> enables zooming and rectangle fill on\n     *              zoom.\n     */\n    public void setMouseZoomable(boolean flag) {\n        setMouseZoomable(flag, true);\n    }\n\n    /**\n     * A convenience method that switches on mouse-based zooming.\n     *\n     * @param flag  <code>true</code> if zooming enabled\n     * @param fillRectangle  <code>true</code> if zoom rectangle is filled,\n     *                       false if rectangle is shown as outline only.\n     */\n    public void setMouseZoomable(boolean flag, boolean fillRectangle) {\n        setDomainZoomable(flag);\n        setRangeZoomable(flag);\n        setFillZoomRectangle(fillRectangle);\n    }\n\n    /**\n     * Returns the flag that determines whether or not zooming is enabled for\n     * the domain axis.\n     *\n     * @return A boolean.\n     */\n    public boolean isDomainZoomable() {\n        return this.domainZoomable;\n    }\n\n    /**\n     * Sets the flag that controls whether or not zooming is enable for the\n     * domain axis.  A check is made to ensure that the current plot supports\n     * zooming for the domain values.\n     *\n     * @param flag  <code>true</code> enables zooming if possible.\n     */\n    public void setDomainZoomable(boolean flag) {\n        if (flag) {\n            Plot plot = this.chart.getPlot();\n            if (plot instanceof Zoomable) {\n                Zoomable z = (Zoomable) plot;\n                this.domainZoomable = flag && (z.isDomainZoomable());\n            }\n        }\n        else {\n            this.domainZoomable = false;\n        }\n    }\n\n    /**\n     * Returns the flag that determines whether or not zooming is enabled for\n     * the range axis.\n     *\n     * @return A boolean.\n     */\n    public boolean isRangeZoomable() {\n        return this.rangeZoomable;\n    }\n\n    /**\n     * A flag that controls mouse-based zooming on the vertical axis.\n     *\n     * @param flag  <code>true</code> enables zooming.\n     */\n    public void setRangeZoomable(boolean flag) {\n        if (flag) {\n            Plot plot = this.chart.getPlot();\n            if (plot instanceof Zoomable) {\n                Zoomable z = (Zoomable) plot;\n                this.rangeZoomable = flag && (z.isRangeZoomable());\n            }\n        }\n        else {\n            this.rangeZoomable = false;\n        }\n    }\n\n    /**\n     * Returns the flag that controls whether or not the zoom rectangle is\n     * filled when drawn.\n     *\n     * @return A boolean.\n     */\n    public boolean getFillZoomRectangle() {\n        return this.fillZoomRectangle;\n    }\n\n    /**\n     * A flag that controls how the zoom rectangle is drawn.\n     *\n     * @param flag  <code>true</code> instructs to fill the rectangle on\n     *              zoom, otherwise it will be outlined.\n     */\n    public void setFillZoomRectangle(boolean flag) {\n        this.fillZoomRectangle = flag;\n    }\n\n    /**\n     * Returns the zoom trigger distance.  This controls how far the mouse must\n     * move before a zoom action is triggered.\n     *\n     * @return The distance (in Java2D units).\n     */\n    public int getZoomTriggerDistance() {\n        return this.zoomTriggerDistance;\n    }\n\n    /**\n     * Sets the zoom trigger distance.  This controls how far the mouse must\n     * move before a zoom action is triggered.\n     *\n     * @param distance  the distance (in Java2D units).\n     */\n    public void setZoomTriggerDistance(int distance) {\n        this.zoomTriggerDistance = distance;\n    }\n\n    /**\n     * Returns the flag that controls whether or not a horizontal axis trace\n     * line is drawn over the plot area at the current mouse location.\n     *\n     * @return A boolean.\n     */\n    public boolean getHorizontalAxisTrace() {\n        return this.horizontalAxisTrace;\n    }\n\n    /**\n     * A flag that controls trace lines on the horizontal axis.\n     *\n     * @param flag  <code>true</code> enables trace lines for the mouse\n     *      pointer on the horizontal axis.\n     */\n    public void setHorizontalAxisTrace(boolean flag) {\n        this.horizontalAxisTrace = flag;\n    }\n\n    /**\n     * Returns the horizontal trace line.\n     *\n     * @return The horizontal trace line (possibly <code>null</code>).\n     */\n    protected Line2D getHorizontalTraceLine() {\n        return this.horizontalTraceLine;\n    }\n\n    /**\n     * Sets the horizontal trace line.\n     *\n     * @param line  the line (<code>null</code> permitted).\n     */\n    protected void setHorizontalTraceLine(Line2D line) {\n        this.horizontalTraceLine = line;\n    }\n\n    /**\n     * Returns the flag that controls whether or not a vertical axis trace\n     * line is drawn over the plot area at the current mouse location.\n     *\n     * @return A boolean.\n     */\n    public boolean getVerticalAxisTrace() {\n        return this.verticalAxisTrace;\n    }\n\n    /**\n     * A flag that controls trace lines on the vertical axis.\n     *\n     * @param flag  <code>true</code> enables trace lines for the mouse\n     *              pointer on the vertical axis.\n     */\n    public void setVerticalAxisTrace(boolean flag) {\n        this.verticalAxisTrace = flag;\n    }\n\n    /**\n     * Returns the vertical trace line.\n     *\n     * @return The vertical trace line (possibly <code>null</code>).\n     */\n    protected Line2D getVerticalTraceLine() {\n        return this.verticalTraceLine;\n    }\n\n    /**\n     * Sets the vertical trace line.\n     *\n     * @param line  the line (<code>null</code> permitted).\n     */\n    protected void setVerticalTraceLine(Line2D line) {\n        this.verticalTraceLine = line;\n    }\n\n    /**\n     * Returns the default directory for the \"save as\" option.\n     *\n     * @return The default directory (possibly <code>null</code>).\n     *\n     * @since 1.0.7\n     */\n    public File getDefaultDirectoryForSaveAs() {\n        return this.defaultDirectoryForSaveAs;\n    }\n\n    /**\n     * Sets the default directory for the \"save as\" option.  If you set this\n     * to <code>null</code>, the user's default directory will be used.\n     *\n     * @param directory  the directory (<code>null</code> permitted).\n     *\n     * @since 1.0.7\n     */\n    public void setDefaultDirectoryForSaveAs(File directory) {\n        if (directory != null) {\n            if (!directory.isDirectory()) {\n                throw new IllegalArgumentException(\n                        \"The 'directory' argument is not a directory.\");\n            }\n        }\n        this.defaultDirectoryForSaveAs = directory;\n    }\n\n    /**\n     * Returns <code>true</code> if file extensions should be enforced, and\n     * <code>false</code> otherwise.\n     *\n     * @return The flag.\n     *\n     * @see #setEnforceFileExtensions(boolean)\n     */\n    public boolean isEnforceFileExtensions() {\n        return this.enforceFileExtensions;\n    }\n\n    /**\n     * Sets a flag that controls whether or not file extensions are enforced.\n     *\n     * @param enforce  the new flag value.\n     *\n     * @see #isEnforceFileExtensions()\n     */\n    public void setEnforceFileExtensions(boolean enforce) {\n        this.enforceFileExtensions = enforce;\n    }\n\n    /**\n     * Returns the flag that controls whether or not zoom operations are\n     * centered around the current anchor point.\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.7\n     *\n     * @see #setZoomAroundAnchor(boolean)\n     */\n    public boolean getZoomAroundAnchor() {\n        return this.zoomAroundAnchor;\n    }\n\n    /**\n     * Sets the flag that controls whether or not zoom operations are\n     * centered around the current anchor point.\n     *\n     * @param zoomAroundAnchor  the new flag value.\n     *\n     * @since 1.0.7\n     *\n     * @see #getZoomAroundAnchor()\n     */\n    public void setZoomAroundAnchor(boolean zoomAroundAnchor) {\n        this.zoomAroundAnchor = zoomAroundAnchor;\n    }\n\n    /**\n     * Returns the zoom rectangle fill paint.\n     *\n     * @return The zoom rectangle fill paint (never <code>null</code>).\n     *\n     * @see #setZoomFillPaint(java.awt.Paint)\n     * @see #setFillZoomRectangle(boolean)\n     *\n     * @since 1.0.13\n     */\n    public Paint getZoomFillPaint() {\n        return this.zoomFillPaint;\n    }\n\n    /**\n     * Sets the zoom rectangle fill paint.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @see #getZoomFillPaint()\n     * @see #getFillZoomRectangle()\n     *\n     * @since 1.0.13\n     */\n    public void setZoomFillPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.zoomFillPaint = paint;\n    }\n\n    /**\n     * Returns the zoom rectangle outline paint.\n     *\n     * @return The zoom rectangle outline paint (never <code>null</code>).\n     *\n     * @see #setZoomOutlinePaint(java.awt.Paint)\n     * @see #setFillZoomRectangle(boolean)\n     *\n     * @since 1.0.13\n     */\n    public Paint getZoomOutlinePaint() {\n        return this.zoomOutlinePaint;\n    }\n\n    /**\n     * Sets the zoom rectangle outline paint.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @see #getZoomOutlinePaint()\n     * @see #getFillZoomRectangle()\n     *\n     * @since 1.0.13\n     */\n    public void setZoomOutlinePaint(Paint paint) {\n        this.zoomOutlinePaint = paint;\n    }\n\n    /**\n     * The mouse wheel handler.  This will be an instance of MouseWheelHandler\n     * but we can't reference that class directly because it depends on JRE 1.4\n     * and we still want to support JRE 1.3.1.\n     */\n    private Object mouseWheelHandler;\n\n    /**\n     * Returns <code>true</code> if the mouse wheel handler is enabled, and\n     * <code>false</code> otherwise.\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.13\n     */\n    public boolean isMouseWheelEnabled() {\n        return this.mouseWheelHandler != null;\n    }\n\n    /**\n     * Enables or disables mouse wheel support for the panel.\n     * Note that this method does nothing when running JFreeChart on JRE 1.3.1,\n     * because that older version of the Java runtime does not support\n     * mouse wheel events.\n     *\n     * @param flag  a boolean.\n     *\n     * @since 1.0.13\n     */\n    public void setMouseWheelEnabled(boolean flag) {\n        if (flag && this.mouseWheelHandler == null) {\n            // use reflection to instantiate a mouseWheelHandler because to\n            // continue supporting JRE 1.3.1 we cannot depend on the\n            // MouseWheelListener interface directly\n            try {\n                Class c = Class.forName(\"org.jfree.chart.MouseWheelHandler\");\n                Constructor cc = c.getConstructor(new Class[] {\n                        ChartPanel.class});\n                Object mwh = cc.newInstance(new Object[] {this});\n                this.mouseWheelHandler = mwh;\n            }\n            catch (ClassNotFoundException e) {\n                // the class isn't there, so we must have compiled JFreeChart\n                // with JDK 1.3.1 - thus, we can't have mouse wheel support\n            }\n            catch (SecurityException e) {\n                e.printStackTrace();\n            }\n            catch (NoSuchMethodException e) {\n                e.printStackTrace();\n            }\n            catch (IllegalArgumentException e) {\n                e.printStackTrace();\n            }\n            catch (InstantiationException e) {\n                e.printStackTrace();\n            }\n            catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n            catch (InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n        else {\n\n            if (this.mouseWheelHandler != null) {\n                // use reflection to deregister the mouseWheelHandler\n                try {\n                    Class mwl = Class.forName(\n                            \"java.awt.event.MouseWheelListener\");\n                    Class c2 = ChartPanel.class;\n                    Method m = c2.getMethod(\"removeMouseWheelListener\",\n                            new Class[] {mwl});\n                    m.invoke(this, new Object[] {this.mouseWheelHandler});\n                }\n                catch (ClassNotFoundException e) {\n                    // must be running on JRE 1.3.1, so just ignore this\n                }\n                catch (SecurityException e) {\n                    e.printStackTrace();\n                }\n                catch (NoSuchMethodException e) {\n                    e.printStackTrace();\n                }\n                catch (IllegalArgumentException e) {\n                    e.printStackTrace();\n                }\n                catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n                catch (InvocationTargetException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    /**\n     * Add an overlay to the panel.\n     *\n     * @param overlay  the overlay (<code>null</code> not permitted).\n     *\n     * @since 1.0.13\n     */\n    public void addOverlay(Overlay overlay) {\n        if (overlay == null) {\n            throw new IllegalArgumentException(\"Null 'overlay' argument.\");\n        }\n        this.overlays.add(overlay);\n        overlay.addChangeListener(this);\n        repaint();\n    }\n\n    /**\n     * Removes an overlay from the panel.\n     *\n     * @param overlay  the overlay to remove (<code>null</code> not permitted).\n     *\n     * @since 1.0.13\n     */\n    public void removeOverlay(Overlay overlay) {\n        if (overlay == null) {\n            throw new IllegalArgumentException(\"Null 'overlay' argument.\");\n        }\n        boolean removed = this.overlays.remove(overlay);\n        if (removed) {\n            overlay.removeChangeListener(this);\n            repaint();\n        }\n    }\n\n    /**\n     * Handles a change to an overlay by repainting the panel.\n     *\n     * @param event  the event.\n     *\n     * @since 1.0.13\n     */\n    public void overlayChanged(OverlayChangeEvent event) {\n        repaint();\n    }\n\n    /**\n     * Switches the display of tooltips for the panel on or off.  Note that\n     * tooltips can only be displayed if the chart has been configured to\n     * generate tooltip items.\n     *\n     * @param flag  <code>true</code> to enable tooltips, <code>false</code> to\n     *              disable tooltips.\n     */\n    public void setDisplayToolTips(boolean flag) {\n        if (flag) {\n            ToolTipManager.sharedInstance().registerComponent(this);\n        }\n        else {\n            ToolTipManager.sharedInstance().unregisterComponent(this);\n        }\n    }\n\n    /**\n     * Returns a string for the tooltip.\n     *\n     * @param e  the mouse event.\n     *\n     * @return A tool tip or <code>null</code> if no tooltip is available.\n     */\n    public String getToolTipText(MouseEvent e) {\n\n        String result = null;\n        if (this.info != null) {\n            EntityCollection entities = this.info.getEntityCollection();\n            if (entities != null) {\n                Insets insets = getInsets();\n                ChartEntity entity = entities.getEntity(\n                        (int) ((e.getX() - insets.left) / this.scaleX),\n                        (int) ((e.getY() - insets.top) / this.scaleY));\n                if (entity != null) {\n                    result = entity.getToolTipText();\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.\n     */\n    public Point translateJava2DToScreen(Point2D java2DPoint) {\n        Insets insets = getInsets();\n        int x = (int) (java2DPoint.getX() * this.scaleX + insets.left);\n        int y = (int) (java2DPoint.getY() * this.scaleY + insets.top);\n        return new Point(x, y);\n    }\n\n    /**\n     * Translates a panel (component) location to a Java2D point.\n     *\n     * @param screenPoint  the screen location (<code>null</code> not\n     *                     permitted).\n     *\n     * @return The Java2D coordinates.\n     */\n    public Point2D translateScreenToJava2D(Point screenPoint) {\n        Insets insets = getInsets();\n        double x = (screenPoint.getX() - insets.left) / this.scaleX;\n        double y = (screenPoint.getY() - insets.top) / this.scaleY;\n        return new Point2D.Double(x, y);\n    }\n\n    /**\n     * Applies any scaling that is in effect for the chart drawing to the\n     * given rectangle.\n     *\n     * @param rect  the rectangle (<code>null</code> not permitted).\n     *\n     * @return A new scaled rectangle.\n     */\n    public Rectangle2D scale(Rectangle2D rect) {\n        Insets insets = getInsets();\n        double x = rect.getX() * getScaleX() + insets.left;\n        double y = rect.getY() * getScaleY() + insets.top;\n        double w = rect.getWidth() * getScaleX();\n        double h = rect.getHeight() * getScaleY();\n        return new Rectangle2D.Double(x, y, w, h);\n    }\n\n    /**\n     * Returns the chart entity at a given point.\n     * <P>\n     * This method will return null if there is (a) no entity at the given\n     * point, or (b) no entity collection has been generated.\n     *\n     * @param viewX  the x-coordinate.\n     * @param viewY  the y-coordinate.\n     *\n     * @return The chart entity (possibly <code>null</code>).\n     */\n    public ChartEntity getEntityForPoint(int viewX, int viewY) {\n\n        ChartEntity result = null;\n        if (this.info != null) {\n            Insets insets = getInsets();\n            double x = (viewX - insets.left) / this.scaleX;\n            double y = (viewY - insets.top) / this.scaleY;\n            EntityCollection entities = this.info.getEntityCollection();\n            result = entities != null ? entities.getEntity(x, y) : null;\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the flag that controls whether or not the offscreen buffer\n     * needs to be refreshed.\n     *\n     * @return A boolean.\n     */\n    public boolean getRefreshBuffer() {\n        return this.refreshBuffer;\n    }\n\n    /**\n     * Sets the refresh buffer flag.  This flag is used to avoid unnecessary\n     * redrawing of the chart when the offscreen image buffer is used.\n     *\n     * @param flag  <code>true</code> indicates that the buffer should be\n     *              refreshed.\n     */\n    public void setRefreshBuffer(boolean flag) {\n        this.refreshBuffer = flag;\n    }\n\n    /**\n     * Paints the component by drawing the chart to fill the entire component,\n     * but allowing for the insets (which will be non-zero if a border has been\n     * set for this component).  To increase performance (at the expense of\n     * memory), an off-screen buffer image can be used.\n     *\n     * @param g  the graphics device for drawing on.\n     */\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        if (this.chart == null) {\n            return;\n        }\n        Graphics2D g2 = (Graphics2D) g.create();\n\n        // first determine the size of the chart rendering area...\n        Dimension size = getSize();\n        Insets insets = getInsets();\n        Rectangle2D available = new Rectangle2D.Double(insets.left, insets.top,\n                size.getWidth() - insets.left - insets.right,\n                size.getHeight() - insets.top - insets.bottom);\n\n        // work out if scaling is required...\n        boolean scale = false;\n        double drawWidth = available.getWidth();\n        double drawHeight = available.getHeight();\n        this.scaleX = 1.0;\n        this.scaleY = 1.0;\n\n        if (drawWidth < this.minimumDrawWidth) {\n            this.scaleX = drawWidth / this.minimumDrawWidth;\n            drawWidth = this.minimumDrawWidth;\n            scale = true;\n        }\n        else if (drawWidth > this.maximumDrawWidth) {\n            this.scaleX = drawWidth / this.maximumDrawWidth;\n            drawWidth = this.maximumDrawWidth;\n            scale = true;\n        }\n\n        if (drawHeight < this.minimumDrawHeight) {\n            this.scaleY = drawHeight / this.minimumDrawHeight;\n            drawHeight = this.minimumDrawHeight;\n            scale = true;\n        }\n        else if (drawHeight > this.maximumDrawHeight) {\n            this.scaleY = drawHeight / this.maximumDrawHeight;\n            drawHeight = this.maximumDrawHeight;\n            scale = true;\n        }\n\n        Rectangle2D chartArea = new Rectangle2D.Double(0.0, 0.0, drawWidth,\n                drawHeight);\n\n        // are we using the chart buffer?\n        if (this.useBuffer) {\n\n            // do we need to resize the buffer?\n            if ((this.chartBuffer == null)\n                    || (this.chartBufferWidth != available.getWidth())\n                    || (this.chartBufferHeight != available.getHeight())) {\n                this.chartBufferWidth = (int) available.getWidth();\n                this.chartBufferHeight = (int) available.getHeight();\n                GraphicsConfiguration gc = g2.getDeviceConfiguration();\n                this.chartBuffer = gc.createCompatibleImage(\n                        this.chartBufferWidth, this.chartBufferHeight,\n                        Transparency.TRANSLUCENT);\n                this.refreshBuffer = true;\n            }\n\n            // do we need to redraw the buffer?\n            if (this.refreshBuffer) {\n\n                this.refreshBuffer = false; // clear the flag\n\n                Rectangle2D bufferArea = new Rectangle2D.Double(\n                        0, 0, this.chartBufferWidth, this.chartBufferHeight);\n\n                Graphics2D bufferG2 = (Graphics2D)\n                        this.chartBuffer.getGraphics();\n                Rectangle r = new Rectangle(0, 0, this.chartBufferWidth,\n                        this.chartBufferHeight);\n                bufferG2.setPaint(getBackground());\n                bufferG2.fill(r);\n                if (scale) {\n                    AffineTransform saved = bufferG2.getTransform();\n                    AffineTransform st = AffineTransform.getScaleInstance(\n                            this.scaleX, this.scaleY);\n                    bufferG2.transform(st);\n                    this.chart.draw(bufferG2, chartArea, this.anchor,\n                            this.info);\n                    bufferG2.setTransform(saved);\n                }\n                else {\n                    this.chart.draw(bufferG2, bufferArea, this.anchor,\n                            this.info);\n                }\n\n            }\n\n            // zap the buffer onto the panel...\n            g2.drawImage(this.chartBuffer, insets.left, insets.top, this);\n\n        }\n\n        // or redrawing the chart every time...\n        else {\n\n            AffineTransform saved = g2.getTransform();\n            g2.translate(insets.left, insets.top);\n            if (scale) {\n                AffineTransform st = AffineTransform.getScaleInstance(\n                        this.scaleX, this.scaleY);\n                g2.transform(st);\n            }\n            this.chart.draw(g2, chartArea, this.anchor, this.info);\n            g2.setTransform(saved);\n\n        }\n\n        Iterator iterator = this.overlays.iterator();\n        while (iterator.hasNext()) {\n            Overlay overlay = (Overlay) iterator.next();\n            overlay.paintOverlay(g2, this);\n        }\n\n        // redraw the zoom rectangle (if present) - if useBuffer is false,\n        // we use XOR so we can XOR the rectangle away again without redrawing\n        // the chart\n        drawZoomRectangle(g2, !this.useBuffer);\n\n        g2.dispose();\n\n        this.anchor = null;\n        this.verticalTraceLine = null;\n        this.horizontalTraceLine = null;\n\n    }\n\n    /**\n     * Receives notification of changes to the chart, and redraws the chart.\n     *\n     * @param event  details of the chart change event.\n     */\n    public void chartChanged(ChartChangeEvent event) {\n        this.refreshBuffer = true;\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n            Zoomable z = (Zoomable) plot;\n            this.orientation = z.getOrientation();\n        }\n        repaint();\n    }\n\n    /**\n     * Receives notification of a chart progress event.\n     *\n     * @param event  the event.\n     */\n    public void chartProgress(ChartProgressEvent event) {\n        // does nothing - override if necessary\n    }\n\n    /**\n     * Handles action events generated by the popup menu.\n     *\n     * @param event  the event.\n     */\n    public void actionPerformed(ActionEvent event) {\n\n        String command = event.getActionCommand();\n\n        // many of the zoom methods need a screen location - all we have is\n        // the zoomPoint, but it might be null.  Here we grab the x and y\n        // coordinates, or use defaults...\n        double screenX = -1.0;\n        double screenY = -1.0;\n        if (this.zoomPoint != null) {\n            screenX = this.zoomPoint.getX();\n            screenY = this.zoomPoint.getY();\n        }\n\n        if (command.equals(PROPERTIES_COMMAND)) {\n            doEditChartProperties();\n        }\n        else if (command.equals(COPY_COMMAND)) {\n            doCopy();\n        }\n        else if (command.equals(SAVE_COMMAND)) {\n            try {\n                doSaveAs();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        else if (command.equals(PRINT_COMMAND)) {\n            createChartPrintJob();\n        }\n        else if (command.equals(ZOOM_IN_BOTH_COMMAND)) {\n            zoomInBoth(screenX, screenY);\n        }\n        else if (command.equals(ZOOM_IN_DOMAIN_COMMAND)) {\n            zoomInDomain(screenX, screenY);\n        }\n        else if (command.equals(ZOOM_IN_RANGE_COMMAND)) {\n            zoomInRange(screenX, screenY);\n        }\n        else if (command.equals(ZOOM_OUT_BOTH_COMMAND)) {\n            zoomOutBoth(screenX, screenY);\n        }\n        else if (command.equals(ZOOM_OUT_DOMAIN_COMMAND)) {\n            zoomOutDomain(screenX, screenY);\n        }\n        else if (command.equals(ZOOM_OUT_RANGE_COMMAND)) {\n            zoomOutRange(screenX, screenY);\n        }\n        else if (command.equals(ZOOM_RESET_BOTH_COMMAND)) {\n            restoreAutoBounds();\n        }\n        else if (command.equals(ZOOM_RESET_DOMAIN_COMMAND)) {\n            restoreAutoDomainBounds();\n        }\n        else if (command.equals(ZOOM_RESET_RANGE_COMMAND)) {\n            restoreAutoRangeBounds();\n        }\n\n    }\n\n    /**\n     * Handles a 'mouse entered' event. This method changes the tooltip delays\n     * of ToolTipManager.sharedInstance() to the possibly different values set\n     * for this chart panel.\n     *\n     * @param e  the mouse event.\n     */\n    public void mouseEntered(MouseEvent e) {\n        if (!this.ownToolTipDelaysActive) {\n            ToolTipManager ttm = ToolTipManager.sharedInstance();\n\n            this.originalToolTipInitialDelay = ttm.getInitialDelay();\n            ttm.setInitialDelay(this.ownToolTipInitialDelay);\n\n            this.originalToolTipReshowDelay = ttm.getReshowDelay();\n            ttm.setReshowDelay(this.ownToolTipReshowDelay);\n\n            this.originalToolTipDismissDelay = ttm.getDismissDelay();\n            ttm.setDismissDelay(this.ownToolTipDismissDelay);\n\n            this.ownToolTipDelaysActive = true;\n        }\n    }\n\n    /**\n     * Handles a 'mouse exited' event. This method resets the tooltip delays of\n     * ToolTipManager.sharedInstance() to their\n     * original values in effect before mouseEntered()\n     *\n     * @param e  the mouse event.\n     */\n    public void mouseExited(MouseEvent e) {\n        if (this.ownToolTipDelaysActive) {\n            // restore original tooltip dealys\n            ToolTipManager ttm = ToolTipManager.sharedInstance();\n            ttm.setInitialDelay(this.originalToolTipInitialDelay);\n            ttm.setReshowDelay(this.originalToolTipReshowDelay);\n            ttm.setDismissDelay(this.originalToolTipDismissDelay);\n            this.ownToolTipDelaysActive = false;\n        }\n    }\n\n    /**\n     * Handles a 'mouse pressed' event.\n     * <P>\n     * This event is the popup trigger on Unix/Linux.  For Windows, the popup\n     * trigger is the 'mouse released' event.\n     *\n     * @param e  The mouse event.\n     */\n    public void mousePressed(MouseEvent e) {\n        Plot plot = this.chart.getPlot();\n        int mods = e.getModifiers();\n        if ((mods & this.panMask) == this.panMask) {\n            // can we pan this plot?\n            if (plot instanceof Pannable) {\n                Pannable pannable = (Pannable) plot;\n                if (pannable.isDomainPannable() || pannable.isRangePannable()) {\n                    Rectangle2D screenDataArea = getScreenDataArea(e.getX(),\n                            e.getY());\n                    if (screenDataArea != null && screenDataArea.contains(\n                            e.getPoint())) {\n                        this.panW = screenDataArea.getWidth();\n                        this.panH = screenDataArea.getHeight();\n                        this.panLast = e.getPoint();\n                        setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n                    }\n                }\n                // the actual panning occurs later in the mouseDragged() \n                // method\n            }\n        }\n        else if (this.zoomRectangle == null) {\n            Rectangle2D screenDataArea = getScreenDataArea(e.getX(), e.getY());\n            if (screenDataArea != null) {\n                this.zoomPoint = getPointInRectangle(e.getX(), e.getY(),\n                        screenDataArea);\n            }\n            else {\n                this.zoomPoint = null;\n            }\n            if (e.isPopupTrigger()) {\n                if (this.popup != null) {\n                    displayPopupMenu(e.getX(), e.getY());\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of the given rectangle.  This method could be moved to JCommon.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the rectangle (<code>null</code> not permitted).\n     *\n     * @return A point within the rectangle.\n     */\n    private Point2D getPointInRectangle(int x, int y, Rectangle2D area) {\n        double xx = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        double yy = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(xx, yy);\n    }\n\n    /**\n     * Handles a 'mouse dragged' event.\n     *\n     * @param e  the mouse event.\n     */\n    public void mouseDragged(MouseEvent e) {\n\n        // if the popup menu has already been triggered, then ignore dragging...\n        if (this.popup != null && this.popup.isShowing()) {\n            return;\n        }\n\n        // handle panning if we have a start point\n        if (this.panLast != null) {\n            double dx = e.getX() - this.panLast.getX();\n            double dy = e.getY() - this.panLast.getY();\n            if (dx == 0.0 && dy == 0.0) {\n                return;\n            }\n            double wPercent = -dx / this.panW;\n            double hPercent = dy / this.panH;\n            boolean old = this.chart.getPlot().isNotify();\n            this.chart.getPlot().setNotify(false);\n            Pannable p = (Pannable) this.chart.getPlot();\n            if (p.getOrientation() == PlotOrientation.VERTICAL) {\n                p.panDomainAxes(wPercent, this.info.getPlotInfo(),\n                        this.panLast);\n                p.panRangeAxes(hPercent, this.info.getPlotInfo(),\n                        this.panLast);\n            }\n            else {\n                p.panDomainAxes(hPercent, this.info.getPlotInfo(),\n                        this.panLast);\n                p.panRangeAxes(wPercent, this.info.getPlotInfo(),\n                        this.panLast);\n            }\n            this.panLast = e.getPoint();\n            this.chart.getPlot().setNotify(old);\n            return;\n        }\n\n        // if no initial zoom point was set, ignore dragging...\n        if (this.zoomPoint == null) {\n            return;\n        }\n        Graphics2D g2 = (Graphics2D) getGraphics();\n\n        // erase the previous zoom rectangle (if any).  We only need to do\n        // this is we are using XOR mode, which we do when we're not using\n        // the buffer (if there is a buffer, then at the end of this method we\n        // just trigger a repaint)\n        if (!this.useBuffer) {\n            drawZoomRectangle(g2, true);\n        }\n\n        boolean hZoom = false;\n        boolean vZoom = false;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            hZoom = this.rangeZoomable;\n            vZoom = this.domainZoomable;\n        }\n        else {\n            hZoom = this.domainZoomable;\n            vZoom = this.rangeZoomable;\n        }\n        Rectangle2D scaledDataArea = getScreenDataArea(\n                (int) this.zoomPoint.getX(), (int) this.zoomPoint.getY());\n        if (hZoom && vZoom) {\n            // selected rectangle shouldn't extend outside the data area...\n            double xmax = Math.min(e.getX(), scaledDataArea.getMaxX());\n            double ymax = Math.min(e.getY(), scaledDataArea.getMaxY());\n            this.zoomRectangle = new Rectangle2D.Double(\n                    this.zoomPoint.getX(), this.zoomPoint.getY(),\n                    xmax - this.zoomPoint.getX(), ymax - this.zoomPoint.getY());\n        }\n        else if (hZoom) {\n            double xmax = Math.min(e.getX(), scaledDataArea.getMaxX());\n            this.zoomRectangle = new Rectangle2D.Double(\n                    this.zoomPoint.getX(), scaledDataArea.getMinY(),\n                    xmax - this.zoomPoint.getX(), scaledDataArea.getHeight());\n        }\n        else if (vZoom) {\n            double ymax = Math.min(e.getY(), scaledDataArea.getMaxY());\n            this.zoomRectangle = new Rectangle2D.Double(\n                    scaledDataArea.getMinX(), this.zoomPoint.getY(),\n                    scaledDataArea.getWidth(), ymax - this.zoomPoint.getY());\n        }\n\n        // Draw the new zoom rectangle...\n        if (this.useBuffer) {\n            repaint();\n        }\n        else {\n            // with no buffer, we use XOR to draw the rectangle \"over\" the\n            // chart...\n            drawZoomRectangle(g2, true);\n        }\n        g2.dispose();\n\n    }\n\n    /**\n     * Handles a 'mouse released' event.  On Windows, we need to check if this\n     * is a popup trigger, but only if we haven't already been tracking a zoom\n     * rectangle.\n     *\n     * @param e  information about the event.\n     */\n    public void mouseReleased(MouseEvent e) {\n\n        // if we've been panning, we need to reset now that the mouse is \n        // released...\n        if (this.panLast != null) {\n            this.panLast = null;\n            setCursor(Cursor.getDefaultCursor());\n        }\n\n        else if (this.zoomRectangle != null) {\n            boolean hZoom = false;\n            boolean vZoom = false;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                hZoom = this.rangeZoomable;\n                vZoom = this.domainZoomable;\n            }\n            else {\n                hZoom = this.domainZoomable;\n                vZoom = this.rangeZoomable;\n            }\n\n            boolean zoomTrigger1 = hZoom && Math.abs(e.getX()\n                - this.zoomPoint.getX()) >= this.zoomTriggerDistance;\n            boolean zoomTrigger2 = vZoom && Math.abs(e.getY()\n                - this.zoomPoint.getY()) >= this.zoomTriggerDistance;\n            if (zoomTrigger1 || zoomTrigger2) {\n                if ((hZoom && (e.getX() < this.zoomPoint.getX()))\n                    || (vZoom && (e.getY() < this.zoomPoint.getY()))) {\n                    restoreAutoBounds();\n                }\n                else {\n                    double x, y, w, h;\n                    Rectangle2D screenDataArea = getScreenDataArea(\n                            (int) this.zoomPoint.getX(),\n                            (int) this.zoomPoint.getY());\n                    double maxX = screenDataArea.getMaxX();\n                    double maxY = screenDataArea.getMaxY();\n                    // for mouseReleased event, (horizontalZoom || verticalZoom)\n                    // will be true, so we can just test for either being false;\n                    // otherwise both are true\n                    if (!vZoom) {\n                        x = this.zoomPoint.getX();\n                        y = screenDataArea.getMinY();\n                        w = Math.min(this.zoomRectangle.getWidth(),\n                                maxX - this.zoomPoint.getX());\n                        h = screenDataArea.getHeight();\n                    }\n                    else if (!hZoom) {\n                        x = screenDataArea.getMinX();\n                        y = this.zoomPoint.getY();\n                        w = screenDataArea.getWidth();\n                        h = Math.min(this.zoomRectangle.getHeight(),\n                                maxY - this.zoomPoint.getY());\n                    }\n                    else {\n                        x = this.zoomPoint.getX();\n                        y = this.zoomPoint.getY();\n                        w = Math.min(this.zoomRectangle.getWidth(),\n                                maxX - this.zoomPoint.getX());\n                        h = Math.min(this.zoomRectangle.getHeight(),\n                                maxY - this.zoomPoint.getY());\n                    }\n                    Rectangle2D zoomArea = new Rectangle2D.Double(x, y, w, h);\n                    zoom(zoomArea);\n                }\n                this.zoomPoint = null;\n                this.zoomRectangle = null;\n            }\n            else {\n                // erase the zoom rectangle\n                Graphics2D g2 = (Graphics2D) getGraphics();\n                if (this.useBuffer) {\n                    repaint();\n                }\n                else {\n                    drawZoomRectangle(g2, true);\n                }\n                g2.dispose();\n                this.zoomPoint = null;\n                this.zoomRectangle = null;\n            }\n\n        }\n\n        else if (e.isPopupTrigger()) {\n            if (this.popup != null) {\n                displayPopupMenu(e.getX(), e.getY());\n            }\n        }\n\n    }\n\n    /**\n     * Receives notification of mouse clicks on the panel. These are\n     * translated and passed on to any registered {@link ChartMouseListener}s.\n     *\n     * @param event  Information about the mouse event.\n     */\n    public void mouseClicked(MouseEvent event) {\n\n        Insets insets = getInsets();\n        int x = (int) ((event.getX() - insets.left) / this.scaleX);\n        int y = (int) ((event.getY() - insets.top) / this.scaleY);\n\n        this.anchor = new Point2D.Double(x, y);\n        if (this.chart == null) {\n            return;\n        }\n        this.chart.setNotify(true);  // force a redraw\n        // new entity code...\n        Object[] listeners = this.chartMouseListeners.getListeners(\n                ChartMouseListener.class);\n        if (listeners.length == 0) {\n            return;\n        }\n\n        ChartEntity entity = null;\n        if (this.info != null) {\n            EntityCollection entities = this.info.getEntityCollection();\n            if (entities != null) {\n                entity = entities.getEntity(x, y);\n            }\n        }\n        ChartMouseEvent chartEvent = new ChartMouseEvent(getChart(), event,\n                entity);\n        for (int i = listeners.length - 1; i >= 0; i -= 1) {\n            ((ChartMouseListener) listeners[i]).chartMouseClicked(chartEvent);\n        }\n\n    }\n\n    /**\n     * Implementation of the MouseMotionListener's method.\n     *\n     * @param e  the event.\n     */\n    public void mouseMoved(MouseEvent e) {\n        Graphics2D g2 = (Graphics2D) getGraphics();\n        if (this.horizontalAxisTrace) {\n            drawHorizontalAxisTrace(g2, e.getX());\n        }\n        if (this.verticalAxisTrace) {\n            drawVerticalAxisTrace(g2, e.getY());\n        }\n        g2.dispose();\n\n        Object[] listeners = this.chartMouseListeners.getListeners(\n                ChartMouseListener.class);\n        if (listeners.length == 0) {\n            return;\n        }\n        Insets insets = getInsets();\n        int x = (int) ((e.getX() - insets.left) / this.scaleX);\n        int y = (int) ((e.getY() - insets.top) / this.scaleY);\n\n        ChartEntity entity = null;\n        if (this.info != null) {\n            EntityCollection entities = this.info.getEntityCollection();\n            if (entities != null) {\n                entity = entities.getEntity(x, y);\n            }\n        }\n\n        // we can only generate events if the panel's chart is not null\n        // (see bug report 1556951)\n        if (this.chart != null) {\n            ChartMouseEvent event = new ChartMouseEvent(getChart(), e, entity);\n            for (int i = listeners.length - 1; i >= 0; i -= 1) {\n                ((ChartMouseListener) listeners[i]).chartMouseMoved(event);\n            }\n        }\n\n    }\n\n    /**\n     * Zooms in on an anchor point (specified in screen coordinate space).\n     *\n     * @param x  the x value (in screen coordinates).\n     * @param y  the y value (in screen coordinates).\n     */\n    public void zoomInBoth(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot == null) {\n            return;\n        }\n        // here we tweak the notify flag on the plot so that only\n        // one notification happens even though we update multiple\n        // axes...\n        boolean savedNotify = plot.isNotify();\n        plot.setNotify(false);\n        zoomInDomain(x, y);\n        zoomInRange(x, y);\n        plot.setNotify(savedNotify);\n    }\n\n    /**\n     * Decreases the length of the domain axis, centered about the given\n     * coordinate on the screen.  The length of the domain axis is reduced\n     * by the value of {@link #getZoomInFactor()}.\n     *\n     * @param x  the x coordinate (in screen coordinates).\n     * @param y  the y-coordinate (in screen coordinates).\n     */\n    public void zoomInDomain(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n            // here we tweak the notify flag on the plot so that only\n            // one notification happens even though we update multiple\n            // axes...\n            boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            Zoomable z = (Zoomable) plot;\n            z.zoomDomainAxes(this.zoomInFactor, this.info.getPlotInfo(),\n                    translateScreenToJava2D(new Point((int) x, (int) y)),\n                    this.zoomAroundAnchor);\n            plot.setNotify(savedNotify);\n        }\n    }\n\n    /**\n     * Decreases the length of the range axis, centered about the given\n     * coordinate on the screen.  The length of the range axis is reduced by\n     * the value of {@link #getZoomInFactor()}.\n     *\n     * @param x  the x-coordinate (in screen coordinates).\n     * @param y  the y coordinate (in screen coordinates).\n     */\n    public void zoomInRange(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n            // here we tweak the notify flag on the plot so that only\n            // one notification happens even though we update multiple\n            // axes...\n            boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            Zoomable z = (Zoomable) plot;\n            z.zoomRangeAxes(this.zoomInFactor, this.info.getPlotInfo(),\n                    translateScreenToJava2D(new Point((int) x, (int) y)),\n                    this.zoomAroundAnchor);\n            plot.setNotify(savedNotify);\n        }\n    }\n\n    /**\n     * Zooms out on an anchor point (specified in screen coordinate space).\n     *\n     * @param x  the x value (in screen coordinates).\n     * @param y  the y value (in screen coordinates).\n     */\n    public void zoomOutBoth(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot == null) {\n            return;\n        }\n        // here we tweak the notify flag on the plot so that only\n        // one notification happens even though we update multiple\n        // axes...\n        boolean savedNotify = plot.isNotify();\n        plot.setNotify(false);\n        zoomOutDomain(x, y);\n        zoomOutRange(x, y);\n        plot.setNotify(savedNotify);\n    }\n\n    /**\n     * Increases the length of the domain axis, centered about the given\n     * coordinate on the screen.  The length of the domain axis is increased\n     * by the value of {@link #getZoomOutFactor()}.\n     *\n     * @param x  the x coordinate (in screen coordinates).\n     * @param y  the y-coordinate (in screen coordinates).\n     */\n    public void zoomOutDomain(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n            // here we tweak the notify flag on the plot so that only\n            // one notification happens even though we update multiple\n            // axes...\n            boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            Zoomable z = (Zoomable) plot;\n            z.zoomDomainAxes(this.zoomOutFactor, this.info.getPlotInfo(),\n                    translateScreenToJava2D(new Point((int) x, (int) y)),\n                    this.zoomAroundAnchor);\n            plot.setNotify(savedNotify);\n        }\n    }\n\n    /**\n     * Increases the length the range axis, centered about the given\n     * coordinate on the screen.  The length of the range axis is increased\n     * by the value of {@link #getZoomOutFactor()}.\n     *\n     * @param x  the x coordinate (in screen coordinates).\n     * @param y  the y-coordinate (in screen coordinates).\n     */\n    public void zoomOutRange(double x, double y) {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n            // here we tweak the notify flag on the plot so that only\n            // one notification happens even though we update multiple\n            // axes...\n            boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            Zoomable z = (Zoomable) plot;\n            z.zoomRangeAxes(this.zoomOutFactor, this.info.getPlotInfo(),\n                    translateScreenToJava2D(new Point((int) x, (int) y)),\n                    this.zoomAroundAnchor);\n            plot.setNotify(savedNotify);\n        }\n    }\n\n    /**\n     * Zooms in on a selected region.\n     *\n     * @param selection  the selected region.\n     */\n    public void zoom(Rectangle2D selection) {\n\n        // get the origin of the zoom selection in the Java2D space used for\n        // drawing the chart (that is, before any scaling to fit the panel)\n        Point2D selectOrigin = translateScreenToJava2D(new Point(\n                (int) Math.ceil(selection.getX()),\n                (int) Math.ceil(selection.getY())));\n        PlotRenderingInfo plotInfo = this.info.getPlotInfo();\n        Rectangle2D scaledDataArea = getScreenDataArea(\n                (int) selection.getCenterX(), (int) selection.getCenterY());\n        if ((selection.getHeight() > 0) && (selection.getWidth() > 0)) {\n\n            double hLower = (selection.getMinX() - scaledDataArea.getMinX())\n                / scaledDataArea.getWidth();\n            double hUpper = (selection.getMaxX() - scaledDataArea.getMinX())\n                / scaledDataArea.getWidth();\n            double vLower = (scaledDataArea.getMaxY() - selection.getMaxY())\n                / scaledDataArea.getHeight();\n            double vUpper = (scaledDataArea.getMaxY() - selection.getMinY())\n                / scaledDataArea.getHeight();\n\n            Plot p = this.chart.getPlot();\n            if (p instanceof Zoomable) {\n                // here we tweak the notify flag on the plot so that only\n                // one notification happens even though we update multiple\n                // axes...\n                boolean savedNotify = p.isNotify();\n                p.setNotify(false);\n                Zoomable z = (Zoomable) p;\n                if (z.getOrientation() == PlotOrientation.HORIZONTAL) {\n                    z.zoomDomainAxes(vLower, vUpper, plotInfo, selectOrigin);\n                    z.zoomRangeAxes(hLower, hUpper, plotInfo, selectOrigin);\n                }\n                else {\n                    z.zoomDomainAxes(hLower, hUpper, plotInfo, selectOrigin);\n                    z.zoomRangeAxes(vLower, vUpper, plotInfo, selectOrigin);\n                }\n                p.setNotify(savedNotify);\n            }\n\n        }\n\n    }\n\n    /**\n     * Restores the auto-range calculation on both axes.\n     */\n    public void restoreAutoBounds() {\n        Plot plot = this.chart.getPlot();\n        if (plot == null) {\n            return;\n        }\n        // here we tweak the notify flag on the plot so that only\n        // one notification happens even though we update multiple\n        // axes...\n        boolean savedNotify = plot.isNotify();\n        plot.setNotify(false);\n        restoreAutoDomainBounds();\n        restoreAutoRangeBounds();\n        plot.setNotify(savedNotify);\n    }\n\n    /**\n     * Restores the auto-range calculation on the domain axis.\n     */\n    public void restoreAutoDomainBounds() {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n            Zoomable z = (Zoomable) plot;\n            // here we tweak the notify flag on the plot so that only\n            // one notification happens even though we update multiple\n            // axes...\n            boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            // we need to guard against this.zoomPoint being null\n            Point2D zp = (this.zoomPoint != null\n                    ? this.zoomPoint : new Point());\n            z.zoomDomainAxes(0.0, this.info.getPlotInfo(), zp);\n            plot.setNotify(savedNotify);\n        }\n    }\n\n    /**\n     * Restores the auto-range calculation on the range axis.\n     */\n    public void restoreAutoRangeBounds() {\n        Plot plot = this.chart.getPlot();\n        if (plot instanceof Zoomable) {\n            Zoomable z = (Zoomable) plot;\n            // here we tweak the notify flag on the plot so that only\n            // one notification happens even though we update multiple\n            // axes...\n            boolean savedNotify = plot.isNotify();\n            plot.setNotify(false);\n            // we need to guard against this.zoomPoint being null\n            Point2D zp = (this.zoomPoint != null\n                    ? this.zoomPoint : new Point());\n            z.zoomRangeAxes(0.0, this.info.getPlotInfo(), zp);\n            plot.setNotify(savedNotify);\n        }\n    }\n\n    /**\n     * Returns the data area for the chart (the area inside the axes) with the\n     * current scaling applied (that is, the area as it appears on screen).\n     *\n     * @return The scaled data area.\n     */\n    public Rectangle2D getScreenDataArea() {\n        Rectangle2D dataArea = this.info.getPlotInfo().getDataArea();\n        Insets insets = getInsets();\n        double x = dataArea.getX() * this.scaleX + insets.left;\n        double y = dataArea.getY() * this.scaleY + insets.top;\n        double w = dataArea.getWidth() * this.scaleX;\n        double h = dataArea.getHeight() * this.scaleY;\n        return new Rectangle2D.Double(x, y, w, h);\n    }\n\n    /**\n     * Returns the data area (the area inside the axes) for the plot or subplot,\n     * with the current scaling applied.\n     *\n     * @param x  the x-coordinate (for subplot selection).\n     * @param y  the y-coordinate (for subplot selection).\n     *\n     * @return The scaled data area.\n     */\n    public Rectangle2D getScreenDataArea(int x, int y) {\n        PlotRenderingInfo plotInfo = this.info.getPlotInfo();\n        Rectangle2D result;\n        if (plotInfo.getSubplotCount() == 0) {\n            result = getScreenDataArea();\n        }\n        else {\n            // get the origin of the zoom selection in the Java2D space used for\n            // drawing the chart (that is, before any scaling to fit the panel)\n            Point2D selectOrigin = translateScreenToJava2D(new Point(x, y));\n            int subplotIndex = plotInfo.getSubplotIndex(selectOrigin);\n            if (subplotIndex == -1) {\n                return null;\n            }\n            result = scale(plotInfo.getSubplotInfo(subplotIndex).getDataArea());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the initial tooltip delay value used inside this chart panel.\n     *\n     * @return An integer representing the initial delay value, in milliseconds.\n     *\n     * @see javax.swing.ToolTipManager#getInitialDelay()\n     */\n    public int getInitialDelay() {\n        return this.ownToolTipInitialDelay;\n    }\n\n    /**\n     * Returns the reshow tooltip delay value used inside this chart panel.\n     *\n     * @return An integer representing the reshow  delay value, in milliseconds.\n     *\n     * @see javax.swing.ToolTipManager#getReshowDelay()\n     */\n    public int getReshowDelay() {\n        return this.ownToolTipReshowDelay;\n    }\n\n    /**\n     * Returns the dismissal tooltip delay value used inside this chart panel.\n     *\n     * @return An integer representing the dismissal delay value, in\n     *         milliseconds.\n     *\n     * @see javax.swing.ToolTipManager#getDismissDelay()\n     */\n    public int getDismissDelay() {\n        return this.ownToolTipDismissDelay;\n    }\n\n    /**\n     * Specifies the initial delay value for this chart panel.\n     *\n     * @param delay  the number of milliseconds to delay (after the cursor has\n     *               paused) before displaying.\n     *\n     * @see javax.swing.ToolTipManager#setInitialDelay(int)\n     */\n    public void setInitialDelay(int delay) {\n        this.ownToolTipInitialDelay = delay;\n    }\n\n    /**\n     * Specifies the amount of time before the user has to wait initialDelay\n     * milliseconds before a tooltip will be shown.\n     *\n     * @param delay  time in milliseconds\n     *\n     * @see javax.swing.ToolTipManager#setReshowDelay(int)\n     */\n    public void setReshowDelay(int delay) {\n        this.ownToolTipReshowDelay = delay;\n    }\n\n    /**\n     * Specifies the dismissal delay value for this chart panel.\n     *\n     * @param delay the number of milliseconds to delay before taking away the\n     *              tooltip\n     *\n     * @see javax.swing.ToolTipManager#setDismissDelay(int)\n     */\n    public void setDismissDelay(int delay) {\n        this.ownToolTipDismissDelay = delay;\n    }\n\n    /**\n     * Returns the zoom in factor.\n     *\n     * @return The zoom in factor.\n     *\n     * @see #setZoomInFactor(double)\n     */\n    public double getZoomInFactor() {\n        return this.zoomInFactor;\n    }\n\n    /**\n     * Sets the zoom in factor.\n     *\n     * @param factor  the factor.\n     *\n     * @see #getZoomInFactor()\n     */\n    public void setZoomInFactor(double factor) {\n        this.zoomInFactor = factor;\n    }\n\n    /**\n     * Returns the zoom out factor.\n     *\n     * @return The zoom out factor.\n     *\n     * @see #setZoomOutFactor(double)\n     */\n    public double getZoomOutFactor() {\n        return this.zoomOutFactor;\n    }\n\n    /**\n     * Sets the zoom out factor.\n     *\n     * @param factor  the factor.\n     *\n     * @see #getZoomOutFactor()\n     */\n    public void setZoomOutFactor(double factor) {\n        this.zoomOutFactor = factor;\n    }\n\n    /**\n     * Draws zoom rectangle (if present).\n     * The drawing is performed in XOR mode, therefore\n     * when this method is called twice in a row,\n     * the second call will completely restore the state\n     * of the canvas.\n     *\n     * @param g2 the graphics device.\n     * @param xor  use XOR for drawing?\n     */\n    private void drawZoomRectangle(Graphics2D g2, boolean xor) {\n        if (this.zoomRectangle != null) {\n            if (xor) {\n                 // Set XOR mode to draw the zoom rectangle\n                g2.setXORMode(Color.gray);\n            }\n            if (this.fillZoomRectangle) {\n                g2.setPaint(this.zoomFillPaint);\n                g2.fill(this.zoomRectangle);\n            }\n            else {\n                g2.setPaint(this.zoomOutlinePaint);\n                g2.draw(this.zoomRectangle);\n            }\n            if (xor) {\n                // Reset to the default 'overwrite' mode\n                g2.setPaintMode();\n            }\n        }\n    }\n\n    /**\n     * Draws a vertical line used to trace the mouse position to the horizontal\n     * axis.\n     *\n     * @param g2 the graphics device.\n     * @param x  the x-coordinate of the trace line.\n     */\n    private void drawHorizontalAxisTrace(Graphics2D g2, int x) {\n\n        Rectangle2D dataArea = getScreenDataArea();\n\n        g2.setXORMode(Color.orange);\n        if (((int) dataArea.getMinX() < x) && (x < (int) dataArea.getMaxX())) {\n\n            if (this.verticalTraceLine != null) {\n                g2.draw(this.verticalTraceLine);\n                this.verticalTraceLine.setLine(x, (int) dataArea.getMinY(), x,\n                        (int) dataArea.getMaxY());\n            }\n            else {\n                this.verticalTraceLine = new Line2D.Float(x,\n                        (int) dataArea.getMinY(), x, (int) dataArea.getMaxY());\n            }\n            g2.draw(this.verticalTraceLine);\n        }\n\n        // Reset to the default 'overwrite' mode\n        g2.setPaintMode();\n    }\n\n    /**\n     * Draws a horizontal line used to trace the mouse position to the vertical\n     * axis.\n     *\n     * @param g2 the graphics device.\n     * @param y  the y-coordinate of the trace line.\n     */\n    private void drawVerticalAxisTrace(Graphics2D g2, int y) {\n\n        Rectangle2D dataArea = getScreenDataArea();\n\n        g2.setXORMode(Color.orange);\n        if (((int) dataArea.getMinY() < y) && (y < (int) dataArea.getMaxY())) {\n\n            if (this.horizontalTraceLine != null) {\n                g2.draw(this.horizontalTraceLine);\n                this.horizontalTraceLine.setLine((int) dataArea.getMinX(), y,\n                        (int) dataArea.getMaxX(), y);\n            }\n            else {\n                this.horizontalTraceLine = new Line2D.Float(\n                        (int) dataArea.getMinX(), y, (int) dataArea.getMaxX(),\n                        y);\n            }\n            g2.draw(this.horizontalTraceLine);\n        }\n\n        // Reset to the default 'overwrite' mode\n        g2.setPaintMode();\n    }\n\n    /**\n     * Displays a dialog that allows the user to edit the properties for the\n     * current chart.\n     *\n     * @since 1.0.3\n     */\n    public void doEditChartProperties() {\n\n        ChartEditor editor = ChartEditorManager.getChartEditor(this.chart);\n        int result = JOptionPane.showConfirmDialog(this, editor,\n                localizationResources.getString(\"Chart_Properties\"),\n                JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);\n        if (result == JOptionPane.OK_OPTION) {\n            editor.updateChart(this.chart);\n        }\n\n    }\n\n    /**\n     * Copies the current chart to the system clipboard.\n     * \n     * @since 1.0.13\n     */\n    public void doCopy() {\n        Clipboard systemClipboard\n                = Toolkit.getDefaultToolkit().getSystemClipboard();\n        ChartTransferable selection = new ChartTransferable(this.chart, \n                getWidth(), getHeight());\n        systemClipboard.setContents(selection, null);\n    }\n\n    /**\n     * Opens a file chooser and gives the user an opportunity to save the chart\n     * in PNG format.\n     *\n     * @throws IOException if there is an I/O error.\n     */\n    public void doSaveAs() throws IOException {\n\n        JFileChooser fileChooser = new JFileChooser();\n        fileChooser.setCurrentDirectory(this.defaultDirectoryForSaveAs);\n        ExtensionFileFilter filter = new ExtensionFileFilter(\n                localizationResources.getString(\"PNG_Image_Files\"), \".png\");\n        fileChooser.addChoosableFileFilter(filter);\n\n        int option = fileChooser.showSaveDialog(this);\n        if (option == JFileChooser.APPROVE_OPTION) {\n            String filename = fileChooser.getSelectedFile().getPath();\n            if (isEnforceFileExtensions()) {\n                if (!filename.endsWith(\".png\")) {\n                    filename = filename + \".png\";\n                }\n            }\n            ChartUtilities.saveChartAsPNG(new File(filename), this.chart,\n                    getWidth(), getHeight());\n        }\n\n    }\n\n    /**\n     * Creates a print job for the chart.\n     */\n    public void createChartPrintJob() {\n\n        PrinterJob job = PrinterJob.getPrinterJob();\n        PageFormat pf = job.defaultPage();\n        PageFormat pf2 = job.pageDialog(pf);\n        if (pf2 != pf) {\n            job.setPrintable(this, pf2);\n            if (job.printDialog()) {\n                try {\n                    job.print();\n                }\n                catch (PrinterException e) {\n                    JOptionPane.showMessageDialog(this, e);\n                }\n            }\n        }\n\n    }\n\n    /**\n     * Prints the chart on a single page.\n     *\n     * @param g  the graphics context.\n     * @param pf  the page format to use.\n     * @param pageIndex  the index of the page. If not <code>0</code>, nothing\n     *                   gets print.\n     *\n     * @return The result of printing.\n     */\n    public int print(Graphics g, PageFormat pf, int pageIndex) {\n\n        if (pageIndex != 0) {\n            return NO_SUCH_PAGE;\n        }\n        Graphics2D g2 = (Graphics2D) g;\n        double x = pf.getImageableX();\n        double y = pf.getImageableY();\n        double w = pf.getImageableWidth();\n        double h = pf.getImageableHeight();\n        this.chart.draw(g2, new Rectangle2D.Double(x, y, w, h), this.anchor,\n                null);\n        return PAGE_EXISTS;\n\n    }\n\n    /**\n     * Adds a listener to the list of objects listening for chart mouse events.\n     *\n     * @param listener  the listener (<code>null</code> not permitted).\n     */\n    public void addChartMouseListener(ChartMouseListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"Null 'listener' argument.\");\n        }\n        this.chartMouseListeners.add(ChartMouseListener.class, listener);\n    }\n\n    /**\n     * Removes a listener from the list of objects listening for chart mouse\n     * events.\n     *\n     * @param listener  the listener.\n     */\n    public void removeChartMouseListener(ChartMouseListener listener) {\n        this.chartMouseListeners.remove(ChartMouseListener.class, listener);\n    }\n\n    /**\n     * Returns an array of the listeners of the given type registered with the\n     * panel.\n     *\n     * @param listenerType  the listener type.\n     *\n     * @return An array of listeners.\n     */\n    public EventListener[] getListeners(Class listenerType) {\n        if (listenerType == ChartMouseListener.class) {\n            // fetch listeners from local storage\n            return this.chartMouseListeners.getListeners(listenerType);\n        }\n        else {\n            return super.getListeners(listenerType);\n        }\n    }\n\n    /**\n     * Creates a popup menu for the panel.\n     *\n     * @param properties  include a menu item for the chart property editor.\n     * @param save  include a menu item for saving the chart.\n     * @param print  include a menu item for printing the chart.\n     * @param zoom  include menu items for zooming.\n     *\n     * @return The popup menu.\n     */\n    protected JPopupMenu createPopupMenu(boolean properties, boolean save,\n            boolean print, boolean zoom) {\n        return createPopupMenu(properties, false, save, print, zoom);\n    }\n\n    /**\n     * Creates a popup menu for the panel.\n     *\n     * @param properties  include a menu item for the chart property editor.\n     * @param copy include a menu item for copying to the clipboard.\n     * @param save  include a menu item for saving the chart.\n     * @param print  include a menu item for printing the chart.\n     * @param zoom  include menu items for zooming.\n     *\n     * @return The popup menu.\n     *\n     * @since 1.0.13\n     */\n    protected JPopupMenu createPopupMenu(boolean properties,\n            boolean copy, boolean save, boolean print, boolean zoom) {\n\n        JPopupMenu result = new JPopupMenu(\"Chart:\");\n        boolean separator = false;\n\n        if (properties) {\n            JMenuItem propertiesItem = new JMenuItem(\n                    localizationResources.getString(\"Properties...\"));\n            propertiesItem.setActionCommand(PROPERTIES_COMMAND);\n            propertiesItem.addActionListener(this);\n            result.add(propertiesItem);\n            separator = true;\n        }\n\n        if (copy) {\n            if (separator) {\n                result.addSeparator();\n                separator = false;\n            }\n            JMenuItem copyItem = new JMenuItem(\n                    localizationResources.getString(\"Copy\"));\n            copyItem.setActionCommand(COPY_COMMAND);\n            copyItem.addActionListener(this);\n            result.add(copyItem);\n            separator = !save;\n        }\n\n        if (save) {\n            if (separator) {\n                result.addSeparator();\n                separator = false;\n            }\n            JMenuItem saveItem = new JMenuItem(\n                    localizationResources.getString(\"Save_as...\"));\n            saveItem.setActionCommand(SAVE_COMMAND);\n            saveItem.addActionListener(this);\n            result.add(saveItem);\n            separator = true;\n        }\n\n        if (print) {\n            if (separator) {\n                result.addSeparator();\n                separator = false;\n            }\n            JMenuItem printItem = new JMenuItem(\n                    localizationResources.getString(\"Print...\"));\n            printItem.setActionCommand(PRINT_COMMAND);\n            printItem.addActionListener(this);\n            result.add(printItem);\n            separator = true;\n        }\n\n        if (zoom) {\n            if (separator) {\n                result.addSeparator();\n                separator = false;\n            }\n\n            JMenu zoomInMenu = new JMenu(\n                    localizationResources.getString(\"Zoom_In\"));\n\n            this.zoomInBothMenuItem = new JMenuItem(\n                    localizationResources.getString(\"All_Axes\"));\n            this.zoomInBothMenuItem.setActionCommand(ZOOM_IN_BOTH_COMMAND);\n            this.zoomInBothMenuItem.addActionListener(this);\n            zoomInMenu.add(this.zoomInBothMenuItem);\n\n            zoomInMenu.addSeparator();\n\n            this.zoomInDomainMenuItem = new JMenuItem(\n                    localizationResources.getString(\"Domain_Axis\"));\n            this.zoomInDomainMenuItem.setActionCommand(ZOOM_IN_DOMAIN_COMMAND);\n            this.zoomInDomainMenuItem.addActionListener(this);\n            zoomInMenu.add(this.zoomInDomainMenuItem);\n\n            this.zoomInRangeMenuItem = new JMenuItem(\n                    localizationResources.getString(\"Range_Axis\"));\n            this.zoomInRangeMenuItem.setActionCommand(ZOOM_IN_RANGE_COMMAND);\n            this.zoomInRangeMenuItem.addActionListener(this);\n            zoomInMenu.add(this.zoomInRangeMenuItem);\n\n            result.add(zoomInMenu);\n\n            JMenu zoomOutMenu = new JMenu(\n                    localizationResources.getString(\"Zoom_Out\"));\n\n            this.zoomOutBothMenuItem = new JMenuItem(\n                    localizationResources.getString(\"All_Axes\"));\n            this.zoomOutBothMenuItem.setActionCommand(ZOOM_OUT_BOTH_COMMAND);\n            this.zoomOutBothMenuItem.addActionListener(this);\n            zoomOutMenu.add(this.zoomOutBothMenuItem);\n\n            zoomOutMenu.addSeparator();\n\n            this.zoomOutDomainMenuItem = new JMenuItem(\n                    localizationResources.getString(\"Domain_Axis\"));\n            this.zoomOutDomainMenuItem.setActionCommand(\n                    ZOOM_OUT_DOMAIN_COMMAND);\n            this.zoomOutDomainMenuItem.addActionListener(this);\n            zoomOutMenu.add(this.zoomOutDomainMenuItem);\n\n            this.zoomOutRangeMenuItem = new JMenuItem(\n                    localizationResources.getString(\"Range_Axis\"));\n            this.zoomOutRangeMenuItem.setActionCommand(ZOOM_OUT_RANGE_COMMAND);\n            this.zoomOutRangeMenuItem.addActionListener(this);\n            zoomOutMenu.add(this.zoomOutRangeMenuItem);\n\n            result.add(zoomOutMenu);\n\n            JMenu autoRangeMenu = new JMenu(\n                    localizationResources.getString(\"Auto_Range\"));\n\n            this.zoomResetBothMenuItem = new JMenuItem(\n                    localizationResources.getString(\"All_Axes\"));\n            this.zoomResetBothMenuItem.setActionCommand(\n                    ZOOM_RESET_BOTH_COMMAND);\n            this.zoomResetBothMenuItem.addActionListener(this);\n            autoRangeMenu.add(this.zoomResetBothMenuItem);\n\n            autoRangeMenu.addSeparator();\n            this.zoomResetDomainMenuItem = new JMenuItem(\n                    localizationResources.getString(\"Domain_Axis\"));\n            this.zoomResetDomainMenuItem.setActionCommand(\n                    ZOOM_RESET_DOMAIN_COMMAND);\n            this.zoomResetDomainMenuItem.addActionListener(this);\n            autoRangeMenu.add(this.zoomResetDomainMenuItem);\n\n            this.zoomResetRangeMenuItem = new JMenuItem(\n                    localizationResources.getString(\"Range_Axis\"));\n            this.zoomResetRangeMenuItem.setActionCommand(\n                    ZOOM_RESET_RANGE_COMMAND);\n            this.zoomResetRangeMenuItem.addActionListener(this);\n            autoRangeMenu.add(this.zoomResetRangeMenuItem);\n\n            result.addSeparator();\n            result.add(autoRangeMenu);\n\n        }\n\n        return result;\n\n    }\n\n    /**\n     * The idea is to modify the zooming options depending on the type of chart\n     * being displayed by the panel.\n     *\n     * @param x  horizontal position of the popup.\n     * @param y  vertical position of the popup.\n     */\n    protected void displayPopupMenu(int x, int y) {\n\n        if (this.popup != null) {\n\n            // go through each zoom menu item and decide whether or not to\n            // enable it...\n            Plot plot = this.chart.getPlot();\n            boolean isDomainZoomable = false;\n            boolean isRangeZoomable = false;\n            if (plot instanceof Zoomable) {\n                Zoomable z = (Zoomable) plot;\n                isDomainZoomable = z.isDomainZoomable();\n                isRangeZoomable = z.isRangeZoomable();\n            }\n\n            if (this.zoomInDomainMenuItem != null) {\n                this.zoomInDomainMenuItem.setEnabled(isDomainZoomable);\n            }\n            if (this.zoomOutDomainMenuItem != null) {\n                this.zoomOutDomainMenuItem.setEnabled(isDomainZoomable);\n            }\n            if (this.zoomResetDomainMenuItem != null) {\n                this.zoomResetDomainMenuItem.setEnabled(isDomainZoomable);\n            }\n\n            if (this.zoomInRangeMenuItem != null) {\n                this.zoomInRangeMenuItem.setEnabled(isRangeZoomable);\n            }\n            if (this.zoomOutRangeMenuItem != null) {\n                this.zoomOutRangeMenuItem.setEnabled(isRangeZoomable);\n            }\n\n            if (this.zoomResetRangeMenuItem != null) {\n                this.zoomResetRangeMenuItem.setEnabled(isRangeZoomable);\n            }\n\n            if (this.zoomInBothMenuItem != null) {\n                this.zoomInBothMenuItem.setEnabled(isDomainZoomable\n                        && isRangeZoomable);\n            }\n            if (this.zoomOutBothMenuItem != null) {\n                this.zoomOutBothMenuItem.setEnabled(isDomainZoomable\n                        && isRangeZoomable);\n            }\n            if (this.zoomResetBothMenuItem != null) {\n                this.zoomResetBothMenuItem.setEnabled(isDomainZoomable\n                        && isRangeZoomable);\n            }\n\n            this.popup.show(this, x, y);\n        }\n\n    }\n\n    /**\n     * Updates the UI for a LookAndFeel change.\n     */\n    public void updateUI() {\n        // here we need to update the UI for the popup menu, if the panel\n        // has one...\n        if (this.popup != null) {\n            SwingUtilities.updateComponentTreeUI(this.popup);\n        }\n        super.updateUI();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.zoomFillPaint, stream);\n        SerialUtilities.writePaint(this.zoomOutlinePaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.zoomFillPaint = SerialUtilities.readPaint(stream);\n        this.zoomOutlinePaint = SerialUtilities.readPaint(stream);\n\n        // we create a new but empty chartMouseListeners list\n        this.chartMouseListeners = new EventListenerList();\n\n        // register as a listener with sub-components...\n        if (this.chart != null) {\n            this.chart.addChangeListener(this);\n        }\n\n    }\n\n\t/**\n\t * Sets the flag that controls whether or not the display range follows the\n\t * data value.\n\t *\n\t * @param jThermometer TODO\n\t * @param flag  the new value of the flag.\n\t */\n\tpublic void setFollowDataInSubranges(JThermometer jThermometer, boolean flag) {\n\t    jThermometer.plot.setFollowDataInSubranges(flag);\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 3115,
                        "lineEnd": 3124,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.JThermometer\nRationale: The method directly interacts with the JThermometer instance and modifies its plot's behavior, making it logical for the method to reside within the JThermometer class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 9740
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setFollowDataInSubranges",
                            "method_signature": "public void setFollowDataInSubranges(JThermometer jThermometer, boolean flag)",
                            "target_class": "JThermometer",
                            "rationale": "The method directly manipulates the state of a JThermometer instance, which suggests it belongs in the JThermometer class rather than the ChartPanel class."
                        }
                    ],
                    "llm_response_time": 3587
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setFollowDataInSubranges",
                            "method_signature": "public void setFollowDataInSubranges(JThermometer jThermometer, boolean flag)",
                            "target_class": "JThermometer",
                            "rationale": "The method directly manipulates the state of a JThermometer instance, which suggests it is more appropriate for the JThermometer class to handle its own data-following behavior."
                        }
                    ],
                    "llm_response_time": 2213
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setFollowDataInSubranges",
                            "method_signature": "public void setFollowDataInSubranges(JThermometer jThermometer, boolean flag)",
                            "target_class": "JThermometer",
                            "rationale": "The method directly manipulates the state of a JThermometer instance, which suggests it is more appropriate for the JThermometer class to handle its own data following behavior."
                        }
                    ],
                    "llm_response_time": 2340
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setFollowDataInSubranges",
                            "method_signature": "public void setFollowDataInSubranges(JThermometer jThermometer, boolean flag)",
                            "target_class": "JThermometer",
                            "rationale": "The method directly manipulates the state of a JThermometer instance, which suggests it belongs in the JThermometer class rather than the ChartPanel class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setFollowDataInSubranges"
                ],
                "llm_response_time": 1524
            },
            "targetClassMap": {
                "setFollowDataInSubranges": {
                    "target_classes": [
                        {
                            "class_name": "JThermometer",
                            "similarity_score": 0.8086879412924785
                        },
                        {
                            "class_name": "JFreeChart",
                            "similarity_score": 0.7532425111768579
                        },
                        {
                            "class_name": "ChartRenderingInfo",
                            "similarity_score": 0.7023380820026366
                        },
                        {
                            "class_name": "PlotOrientation",
                            "similarity_score": 0.5983388251364445
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JThermometer",
                        "JFreeChart",
                        "ChartRenderingInfo",
                        "PlotOrientation"
                    ],
                    "llm_response_time": 1855,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "- method org.jfree.chart.event.PlotChangeEvent::plotChanged(PlotChangeEvent):void need move org.jfree.chart.plot.CombinedDomainXYPlot",
        "class_name": "org.jfree.chart.event.PlotChangeEvent",
        "telemetry": {
            "id": "deb42bc7-cbb0-4d09-8be9-385289dcd826",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 40,
                "lineStart": 49,
                "lineEnd": 88,
                "bodyLineStart": 49,
                "language": "java",
                "sourceCode": "/**\n * An event that can be forwarded to any\n * {@link org.jfree.chart.event.PlotChangeListener} to signal a change to a\n * plot.\n */\npublic class PlotChangeEvent extends ChartChangeEvent {\n\n    /** The plot that generated the event. */\n    private Plot plot;\n\n    /**\n     * Creates a new PlotChangeEvent.\n     *\n     * @param plot  the plot that generated the event.\n     */\n    public PlotChangeEvent(Plot plot) {\n        super(plot);\n        this.plot = plot;\n    }\n\n    /**\n     * Returns the plot that generated the event.\n     *\n     * @return The plot that generated the event.\n     */\n    public Plot getPlot() {\n        return this.plot;\n    }\n\n\t/**\n\t * Receives a {@link PlotChangeEvent} and responds by notifying all\n\t * listeners.\n\t *\n\t * @param combinedDomainXYPlot TODO\n\t */\n\tpublic void plotChanged(CombinedDomainXYPlot combinedDomainXYPlot) {\n\t    combinedDomainXYPlot.notifyListeners(this);\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 77,
                        "lineEnd": 85,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.CombinedDomainXYPlot\nRationale: The method plotChanged() directly interacts with the CombinedDomainXYPlot instance by notifying its listeners, making it more appropriate for this method to reside within the CombinedDomainXYPlot class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5576
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "plotChanged",
                            "method_signature": "public void plotChanged(CombinedDomainXYPlot combinedDomainXYPlot)",
                            "target_class": "CombinedDomainXYPlot",
                            "rationale": "The plotChanged() method is responsible for notifying listeners of changes in the plot, which is a behavior that is more relevant to the CombinedDomainXYPlot class. Moving it there would enhance cohesion and maintainability."
                        }
                    ],
                    "llm_response_time": 1830
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "plotChanged",
                            "method_signature": "public void plotChanged(CombinedDomainXYPlot combinedDomainXYPlot)",
                            "target_class": "CombinedDomainXYPlot",
                            "rationale": "The plotChanged() method is responsible for notifying listeners of a plot change, which is a behavior that is more relevant to the CombinedDomainXYPlot class. Moving it there would enhance cohesion and maintainability."
                        }
                    ],
                    "llm_response_time": 1430
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "plotChanged",
                            "method_signature": "public void plotChanged(CombinedDomainXYPlot combinedDomainXYPlot)",
                            "target_class": "CombinedDomainXYPlot",
                            "rationale": "The plotChanged() method is responsible for notifying listeners of changes in the plot, which is a behavior that is more relevant to the CombinedDomainXYPlot class. Moving it there would enhance cohesion and maintainability."
                        }
                    ],
                    "llm_response_time": 1633
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "plotChanged",
                            "method_signature": "public void plotChanged(CombinedDomainXYPlot combinedDomainXYPlot)",
                            "target_class": "CombinedDomainXYPlot",
                            "rationale": "The plotChanged() method is responsible for notifying listeners of changes in the plot, which is a behavior that is more relevant to the CombinedDomainXYPlot class. Moving it there would enhance cohesion and maintainability."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "plotChanged"
                ],
                "llm_response_time": 611
            },
            "targetClassMap": {
                "plotChanged": {
                    "target_classes": [
                        {
                            "class_name": "CombinedDomainXYPlot",
                            "similarity_score": 0.5812863315311165
                        },
                        {
                            "class_name": "Plot",
                            "similarity_score": 0.6584514997366655
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CombinedDomainXYPlot",
                        "Plot"
                    ],
                    "llm_response_time": 1498,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.plot.Plot::setPlot(Plot):void need move org.jfree.chart.axis.Axis",
        "class_name": "org.jfree.chart.plot.Plot",
        "telemetry": {
            "id": "7aa288c4-efea-4fce-b836-de65f9e70bfd",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1348,
                "lineStart": 183,
                "lineEnd": 1530,
                "bodyLineStart": 183,
                "language": "java",
                "sourceCode": "/**\n * The base class for all plots in JFreeChart.  The {@link JFreeChart} class\n * delegates the drawing of axes and data to the plot.  This base class\n * provides facilities common to most plot types.\n */\npublic abstract class Plot implements AxisChangeListener,\n        DatasetChangeListener, MarkerChangeListener, LegendItemSource,\n        PublicCloneable, Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -8831571430103671324L;\n\n    /** Useful constant representing zero. */\n    public static final Number ZERO = new Integer(0);\n\n    /** The default insets. */\n    public static final RectangleInsets DEFAULT_INSETS\n            = new RectangleInsets(4.0, 8.0, 4.0, 8.0);\n\n    /** The default outline stroke. */\n    public static final Stroke DEFAULT_OUTLINE_STROKE = new BasicStroke(0.5f);\n\n    /** The default outline color. */\n    public static final Paint DEFAULT_OUTLINE_PAINT = Color.gray;\n\n    /** The default foreground alpha transparency. */\n    public static final float DEFAULT_FOREGROUND_ALPHA = 1.0f;\n\n    /** The default background alpha transparency. */\n    public static final float DEFAULT_BACKGROUND_ALPHA = 1.0f;\n\n    /** The default background color. */\n    public static final Paint DEFAULT_BACKGROUND_PAINT = Color.white;\n\n    /** The minimum width at which the plot should be drawn. */\n    public static final int MINIMUM_WIDTH_TO_DRAW = 10;\n\n    /** The minimum height at which the plot should be drawn. */\n    public static final int MINIMUM_HEIGHT_TO_DRAW = 10;\n\n    /** A default box shape for legend items. */\n    public static final Shape DEFAULT_LEGEND_ITEM_BOX\n            = new Rectangle2D.Double(-4.0, -4.0, 8.0, 8.0);\n\n    /** A default circle shape for legend items. */\n    public static final Shape DEFAULT_LEGEND_ITEM_CIRCLE\n            = new Ellipse2D.Double(-4.0, -4.0, 8.0, 8.0);\n\n    /** The parent plot (<code>null</code> if this is the root plot). */\n    private Plot parent;\n\n    /** The dataset group (to be used for thread synchronisation). */\n    public DatasetGroup datasetGroup;\n\n    /** The message to display if no data is available. */\n    private String noDataMessage;\n\n    /** The font used to display the 'no data' message. */\n    private Font noDataMessageFont;\n\n    /** The paint used to draw the 'no data' message. */\n    private transient Paint noDataMessagePaint;\n\n    /** Amount of blank space around the plot area. */\n    private RectangleInsets insets;\n\n    /**\n     * A flag that controls whether or not the plot outline is drawn.\n     *\n     * @since 1.0.6\n     */\n    private boolean outlineVisible;\n\n    /** The Stroke used to draw an outline around the plot. */\n    private transient Stroke outlineStroke;\n\n    /** The Paint used to draw an outline around the plot. */\n    private transient Paint outlinePaint;\n\n    /** An optional color used to fill the plot background. */\n    private transient Paint backgroundPaint;\n\n    /** An optional image for the plot background. */\n    private transient Image backgroundImage;  // not currently serialized\n\n    /** The alignment for the background image. */\n    private int backgroundImageAlignment = Align.FIT;\n\n    /** The alpha value used to draw the background image. */\n    private float backgroundImageAlpha = 0.5f;\n\n    /** The alpha-transparency for the plot. */\n    private float foregroundAlpha;\n\n    /** The alpha transparency for the background paint. */\n    private float backgroundAlpha;\n\n    /** The drawing supplier. */\n    private DrawingSupplier drawingSupplier;\n\n    /** Storage for registered change listeners. */\n    private transient EventListenerList listenerList;\n\n    /**\n     * A flag that controls whether or not the plot will notify listeners\n     * of changes (defaults to true, but sometimes it is useful to disable\n     * this).\n     *\n     * @since 1.0.13\n     */\n    private boolean notify;\n\n    /**\n     * Creates a new plot.\n     */\n    protected Plot() {\n\n        this.parent = null;\n        this.insets = DEFAULT_INSETS;\n        this.backgroundPaint = DEFAULT_BACKGROUND_PAINT;\n        this.backgroundAlpha = DEFAULT_BACKGROUND_ALPHA;\n        this.backgroundImage = null;\n        this.outlineVisible = true;\n        this.outlineStroke = DEFAULT_OUTLINE_STROKE;\n        this.outlinePaint = DEFAULT_OUTLINE_PAINT;\n        this.foregroundAlpha = DEFAULT_FOREGROUND_ALPHA;\n\n        this.noDataMessage = null;\n        this.noDataMessageFont = new Font(\"SansSerif\", Font.PLAIN, 12);\n        this.noDataMessagePaint = Color.black;\n\n        this.drawingSupplier = new DefaultDrawingSupplier();\n\n        this.notify = true;\n        this.listenerList = new EventListenerList();\n\n    }\n\n    /**\n     * Returns the dataset group for the plot (not currently used).\n     *\n     * @return The dataset group.\n     *\n     * @see #MISSING()\n     */\n    public DatasetGroup getDatasetGroup() {\n        return this.datasetGroup;\n    }\n\n    /**\n     * Returns the string that is displayed when the dataset is empty or\n     * <code>null</code>.\n     *\n     * @return The 'no data' message (<code>null</code> possible).\n     *\n     * @see #setNoDataMessage(String)\n     * @see #getNoDataMessageFont()\n     * @see #getNoDataMessagePaint()\n     */\n    public String getNoDataMessage() {\n        return this.noDataMessage;\n    }\n\n    /**\n     * Sets the message that is displayed when the dataset is empty or\n     * <code>null</code>, and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param message  the message (<code>null</code> permitted).\n     *\n     * @see #getNoDataMessage()\n     */\n    public void setNoDataMessage(String message) {\n        this.noDataMessage = message;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the font used to display the 'no data' message.\n     *\n     * @return The font (never <code>null</code>).\n     *\n     * @see #setNoDataMessageFont(Font)\n     * @see #getNoDataMessage()\n     */\n    public Font getNoDataMessageFont() {\n        return this.noDataMessageFont;\n    }\n\n    /**\n     * Sets the font used to display the 'no data' message and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param font  the font (<code>null</code> not permitted).\n     *\n     * @see #getNoDataMessageFont()\n     */\n    public void setNoDataMessageFont(Font font) {\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        this.noDataMessageFont = font;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to display the 'no data' message.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setNoDataMessagePaint(Paint)\n     * @see #getNoDataMessage()\n     */\n    public Paint getNoDataMessagePaint() {\n        return this.noDataMessagePaint;\n    }\n\n    /**\n     * Sets the paint used to display the 'no data' message and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @see #getNoDataMessagePaint()\n     */\n    public void setNoDataMessagePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.noDataMessagePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a short string describing the plot type.\n     * <P>\n     * Note: this gets used in the chart property editing user interface,\n     * but there needs to be a better mechanism for identifying the plot type.\n     *\n     * @return A short string describing the plot type (never\n     *     <code>null</code>).\n     */\n    public abstract String getPlotType();\n\n    /**\n     * Returns the parent plot (or <code>null</code> if this plot is not part\n     * of a combined plot).\n     *\n     * @return The parent plot.\n     *\n     * @see #setParent(Plot)\n     * @see #getRootPlot()\n     */\n    public Plot getParent() {\n        return this.parent;\n    }\n\n    /**\n     * Sets the parent plot.  This method is intended for internal use, you\n     * shouldn't need to call it directly.\n     *\n     * @param parent  the parent plot (<code>null</code> permitted).\n     *\n     * @see #getParent()\n     */\n    public void setParent(Plot parent) {\n        this.parent = parent;\n    }\n\n    /**\n     * Returns the root plot.\n     *\n     * @return The root plot.\n     *\n     * @see #getParent()\n     */\n    public Plot getRootPlot() {\n\n        Plot p = getParent();\n        if (p == null) {\n            return this;\n        }\n        else {\n            return p.getRootPlot();\n        }\n\n    }\n\n    /**\n     * Returns <code>true</code> if this plot is part of a combined plot\n     * structure (that is, {@link #getParent()} returns a non-<code>null</code>\n     * value), and <code>false</code> otherwise.\n     *\n     * @return <code>true</code> if this plot is part of a combined plot\n     *         structure.\n     *\n     * @see #getParent()\n     */\n    public boolean isSubplot() {\n        return (getParent() != null);\n    }\n\n    /**\n     * Returns the insets for the plot area.\n     *\n     * @return The insets (never <code>null</code>).\n     *\n     * @see #setInsets(RectangleInsets)\n     */\n    public RectangleInsets getInsets() {\n        return this.insets;\n    }\n\n    /**\n     * Sets the insets for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param insets  the new insets (<code>null</code> not permitted).\n     *\n     * @see #getInsets()\n     * @see #setInsets(RectangleInsets, boolean)\n     */\n    public void setInsets(RectangleInsets insets) {\n        setInsets(insets, true);\n    }\n\n    /**\n     * Sets the insets for the plot and, if requested,  and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param insets  the new insets (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether the registered listeners are\n     *                notified.\n     *\n     * @see #getInsets()\n     * @see #setInsets(RectangleInsets)\n     */\n    public void setInsets(RectangleInsets insets, boolean notify) {\n        if (insets == null) {\n            throw new IllegalArgumentException(\"Null 'insets' argument.\");\n        }\n        if (!this.insets.equals(insets)) {\n            this.insets = insets;\n            if (notify) {\n                fireChangeEvent();\n            }\n        }\n\n    }\n\n    /**\n     * Returns the background color of the plot area.\n     *\n     * @return The paint (possibly <code>null</code>).\n     *\n     * @see #setBackgroundPaint(Paint)\n     */\n    public Paint getBackgroundPaint() {\n        return this.backgroundPaint;\n    }\n\n    /**\n     * Sets the background color of the plot area and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @see #getBackgroundPaint()\n     */\n    public void setBackgroundPaint(Paint paint) {\n\n        if (paint == null) {\n            if (this.backgroundPaint != null) {\n                this.backgroundPaint = null;\n                fireChangeEvent();\n            }\n        }\n        else {\n            if (this.backgroundPaint != null) {\n                if (this.backgroundPaint.equals(paint)) {\n                    return;  // nothing to do\n                }\n            }\n            this.backgroundPaint = paint;\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns the alpha transparency of the plot area background.\n     *\n     * @return The alpha transparency.\n     *\n     * @see #setBackgroundAlpha(float)\n     */\n    public float getBackgroundAlpha() {\n        return this.backgroundAlpha;\n    }\n\n    /**\n     * Sets the alpha transparency of the plot area background, and notifies\n     * registered listeners that the plot has been modified.\n     *\n     * @param alpha the new alpha value (in the range 0.0f to 1.0f).\n     *\n     * @see #getBackgroundAlpha()\n     */\n    public void setBackgroundAlpha(float alpha) {\n        if (this.backgroundAlpha != alpha) {\n            this.backgroundAlpha = alpha;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the drawing supplier for the plot.\n     *\n     * @return The drawing supplier (possibly <code>null</code>).\n     *\n     * @see #setDrawingSupplier(DrawingSupplier)\n     */\n    public DrawingSupplier getDrawingSupplier() {\n        DrawingSupplier result = null;\n        Plot p = getParent();\n        if (p != null) {\n            result = p.getDrawingSupplier();\n        }\n        else {\n            result = this.drawingSupplier;\n        }\n        return result;\n    }\n\n    /**\n     * Sets the drawing supplier for the plot and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  The drawing\n     * supplier is responsible for supplying a limitless (possibly repeating)\n     * sequence of <code>Paint</code>, <code>Stroke</code> and\n     * <code>Shape</code> objects that the plot's renderer(s) can use to\n     * populate its (their) tables.\n     *\n     * @param supplier  the new supplier.\n     *\n     * @see #getDrawingSupplier()\n     */\n    public void setDrawingSupplier(DrawingSupplier supplier) {\n        this.drawingSupplier = supplier;\n        fireChangeEvent();\n    }\n\n    /**\n     * Sets the drawing supplier for the plot and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.  The drawing\n     * supplier is responsible for supplying a limitless (possibly repeating)\n     * sequence of <code>Paint</code>, <code>Stroke</code> and\n     * <code>Shape</code> objects that the plot's renderer(s) can use to\n     * populate its (their) tables.\n     *\n     * @param supplier  the new supplier.\n     * @param notify  notify listeners?\n     *\n     * @see #getDrawingSupplier()\n     *\n     * @since 1.0.11\n     */\n    public void setDrawingSupplier(DrawingSupplier supplier, boolean notify) {\n        this.drawingSupplier = supplier;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the background image that is used to fill the plot's background\n     * area.\n     *\n     * @return The image (possibly <code>null</code>).\n     *\n     * @see #setBackgroundImage(Image)\n     */\n    public Image getBackgroundImage() {\n        return this.backgroundImage;\n    }\n\n    /**\n     * Sets the background image for the plot and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param image  the image (<code>null</code> permitted).\n     *\n     * @see #getBackgroundImage()\n     */\n    public void setBackgroundImage(Image image) {\n        this.backgroundImage = image;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the background image alignment. Alignment constants are defined\n     * in the <code>org.jfree.ui.Align</code> class in the JCommon class\n     * library.\n     *\n     * @return The alignment.\n     *\n     * @see #setBackgroundImageAlignment(int)\n     */\n    public int getBackgroundImageAlignment() {\n        return this.backgroundImageAlignment;\n    }\n\n    /**\n     * Sets the alignment for the background image and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  Alignment options\n     * are defined by the {@link org.jfree.ui.Align} class in the JCommon\n     * class library.\n     *\n     * @param alignment  the alignment.\n     *\n     * @see #getBackgroundImageAlignment()\n     */\n    public void setBackgroundImageAlignment(int alignment) {\n        if (this.backgroundImageAlignment != alignment) {\n            this.backgroundImageAlignment = alignment;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the alpha transparency used to draw the background image.  This\n     * is a value in the range 0.0f to 1.0f, where 0.0f is fully transparent\n     * and 1.0f is fully opaque.\n     *\n     * @return The alpha transparency.\n     *\n     * @see #setBackgroundImageAlpha(float)\n     */\n    public float getBackgroundImageAlpha() {\n        return this.backgroundImageAlpha;\n    }\n\n    /**\n     * Sets the alpha transparency used when drawing the background image.\n     *\n     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f, where\n     *     0.0f is fully transparent, and 1.0f is fully opaque).\n     *\n     * @throws IllegalArgumentException if <code>alpha</code> is not within\n     *     the specified range.\n     *\n     * @see #getBackgroundImageAlpha()\n     */\n    public void setBackgroundImageAlpha(float alpha) {\n        if (alpha < 0.0f || alpha > 1.0f)\n            throw new IllegalArgumentException(\n                    \"The 'alpha' value must be in the range 0.0f to 1.0f.\");\n        if (this.backgroundImageAlpha != alpha) {\n            this.backgroundImageAlpha = alpha;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the flag that controls whether or not the plot outline is\n     * drawn.  The default value is <code>true</code>.  Note that for\n     * historical reasons, the plot's outline paint and stroke can take on\n     * <code>null</code> values, in which case the outline will not be drawn\n     * even if this flag is set to <code>true</code>.\n     *\n     * @return The outline visibility flag.\n     *\n     * @since 1.0.6\n     *\n     * @see #setOutlineVisible(boolean)\n     */\n    public boolean isOutlineVisible() {\n        return this.outlineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the plot's outline is\n     * drawn, and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param visible  the new flag value.\n     *\n     * @since 1.0.6\n     *\n     * @see #isOutlineVisible()\n     */\n    public void setOutlineVisible(boolean visible) {\n        this.outlineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used to outline the plot area.\n     *\n     * @return The stroke (possibly <code>null</code>).\n     *\n     * @see #setOutlineStroke(Stroke)\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to outline the plot area and sends a\n     * {@link PlotChangeEvent} to all registered listeners. If you set this\n     * attribute to <code>null</code>, no outline will be drawn.\n     *\n     * @param stroke  the stroke (<code>null</code> permitted).\n     *\n     * @see #getOutlineStroke()\n     */\n    public void setOutlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            if (this.outlineStroke != null) {\n                this.outlineStroke = null;\n                fireChangeEvent();\n            }\n        }\n        else {\n            if (this.outlineStroke != null) {\n                if (this.outlineStroke.equals(stroke)) {\n                    return;  // nothing to do\n                }\n            }\n            this.outlineStroke = stroke;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the color used to draw the outline of the plot area.\n     *\n     * @return The color (possibly <code>null<code>).\n     *\n     * @see #setOutlinePaint(Paint)\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the outline of the plot area and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  If you set this\n     * attribute to <code>null</code>, no outline will be drawn.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @see #getOutlinePaint()\n     */\n    public void setOutlinePaint(Paint paint) {\n        if (paint == null) {\n            if (this.outlinePaint != null) {\n                this.outlinePaint = null;\n                fireChangeEvent();\n            }\n        }\n        else {\n            if (this.outlinePaint != null) {\n                if (this.outlinePaint.equals(paint)) {\n                    return;  // nothing to do\n                }\n            }\n            this.outlinePaint = paint;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the alpha-transparency for the plot foreground.\n     *\n     * @return The alpha-transparency.\n     *\n     * @see #setForegroundAlpha(float)\n     */\n    public float getForegroundAlpha() {\n        return this.foregroundAlpha;\n    }\n\n    /**\n     * Sets the alpha-transparency for the plot and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param alpha  the new alpha transparency.\n     *\n     * @see #getForegroundAlpha()\n     */\n    public void setForegroundAlpha(float alpha) {\n        if (this.foregroundAlpha != alpha) {\n            this.foregroundAlpha = alpha;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the legend items for the plot.  By default, this method returns\n     * <code>null</code>.  Subclasses should override to return a\n     * {@link LegendItemCollection}.\n     *\n     * @return The legend items for the plot (possibly <code>null</code>).\n     */\n    public LegendItemCollection getLegendItems() {\n        return null;\n    }\n\n    /**\n     * Returns a flag that controls whether or not change events are sent to\n     * registered listeners.\n     *\n     * @return A boolean.\n     *\n     * @see #setNotify(boolean)\n     *\n     * @since 1.0.13\n     */\n    public boolean isNotify() {\n        return this.notify;\n    }\n\n    /**\n     * Sets a flag that controls whether or not listeners receive\n     * {@link PlotChangeEvent} notifications.\n     *\n     * @param notify  a boolean.\n     *\n     * @see #isNotify()\n     *\n     * @since 1.0.13\n     */\n    public void setNotify(boolean notify) {\n        this.notify = notify;\n        // if the flag is being set to true, there may be queued up changes...\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Registers an object for notification of changes to the plot.\n     *\n     * @param listener  the object to be registered.\n     *\n     * @see #removeChangeListener(PlotChangeListener)\n     */\n    public void addChangeListener(PlotChangeListener listener) {\n        this.listenerList.add(PlotChangeListener.class, listener);\n    }\n\n    /**\n     * Unregisters an object for notification of changes to the plot.\n     *\n     * @param listener  the object to be unregistered.\n     *\n     * @see #addChangeListener(PlotChangeListener)\n     */\n    public void removeChangeListener(PlotChangeListener listener) {\n        this.listenerList.remove(PlotChangeListener.class, listener);\n    }\n\n    /**\n     * Notifies all registered listeners that the plot has been modified.\n     *\n     * @param event  information about the change event.\n     */\n    public void notifyListeners(PlotChangeEvent event) {\n        // if the 'notify' flag has been switched to false, we don't notify\n        // the listeners\n        if (!this.notify) {\n            return;\n        }\n        Object[] listeners = this.listenerList.getListenerList();\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == PlotChangeListener.class) {\n                ((PlotChangeListener) listeners[i + 1]).plotChanged(event);\n            }\n        }\n    }\n\n    /**\n     * Sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @since 1.0.10\n     */\n    public void fireChangeEvent() {\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Draws the plot within the specified area.  The anchor is a point on the\n     * chart that is specified externally (for instance, it may be the last\n     * point of the last mouse click performed by the user) - plots can use or\n     * ignore this value as they see fit.\n     * <br><br>\n     * Subclasses need to provide an implementation of this method, obviously.\n     *\n     * @param g2  the graphics device.\n     * @param area  the plot area.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the parent state (if any).\n     * @param info  carries back plot rendering info.\n     */\n    public abstract void draw(Graphics2D g2,\n                              Rectangle2D area,\n                              Point2D anchor,\n                              PlotState parentState,\n                              PlotRenderingInfo info);\n\n    /**\n     * Draws the plot background (the background color and/or image).\n     * <P>\n     * This method will be called during the chart drawing process and is\n     * declared public so that it can be accessed by the renderers used by\n     * certain subclasses.  You shouldn't need to call this method directly.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        // some subclasses override this method completely, so don't put\n        // anything here that *must* be done\n        fillBackground(g2, area);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * Fills the specified area with the background paint.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     *\n     * @see #getBackgroundPaint()\n     * @see #getBackgroundAlpha()\n     * @see #fillBackground(Graphics2D, Rectangle2D, PlotOrientation)\n     */\n    protected void fillBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, PlotOrientation.VERTICAL);\n    }\n\n    /**\n     * Fills the specified area with the background paint.  If the background\n     * paint is an instance of <code>GradientPaint</code>, the gradient will\n     * run in the direction suggested by the plot's orientation.\n     *\n     * @param g2  the graphics target.\n     * @param area  the plot area.\n     * @param orientation  the plot orientation (<code>null</code> not\n     *         permitted).\n     *\n     * @since 1.0.6\n     */\n    protected void fillBackground(Graphics2D g2, Rectangle2D area,\n            PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (this.backgroundPaint == null) {\n            return;\n        }\n        Paint p = this.backgroundPaint;\n        if (p instanceof GradientPaint) {\n            GradientPaint gp = (GradientPaint) p;\n            if (orientation == PlotOrientation.VERTICAL) {\n                p = new GradientPaint((float) area.getCenterX(),\n                        (float) area.getMaxY(), gp.getColor1(),\n                        (float) area.getCenterX(), (float) area.getMinY(),\n                        gp.getColor2());\n            }\n            else if (orientation == PlotOrientation.HORIZONTAL) {\n                p = new GradientPaint((float) area.getMinX(),\n                        (float) area.getCenterY(), gp.getColor1(),\n                        (float) area.getMaxX(), (float) area.getCenterY(),\n                        gp.getColor2());\n            }\n        }\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                this.backgroundAlpha));\n        g2.setPaint(p);\n        g2.fill(area);\n        g2.setComposite(originalComposite);\n    }\n\n    /**\n     * Draws the background image (if there is one) aligned within the\n     * specified area.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     *\n     * @see #getBackgroundImage()\n     * @see #getBackgroundImageAlignment()\n     * @see #getBackgroundImageAlpha()\n     */\n    public void drawBackgroundImage(Graphics2D g2, Rectangle2D area) {\n        if (this.backgroundImage != null) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    this.backgroundImageAlpha));\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0,\n                    this.backgroundImage.getWidth(null),\n                    this.backgroundImage.getHeight(null));\n            Align.align(dest, area, this.backgroundImageAlignment);\n            g2.drawImage(this.backgroundImage, (int) dest.getX(),\n                    (int) dest.getY(), (int) dest.getWidth() + 1,\n                    (int) dest.getHeight() + 1, null);\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    /**\n     * Draws the plot outline.  This method will be called during the chart\n     * drawing process and is declared public so that it can be accessed by the\n     * renderers used by certain subclasses. You shouldn't need to call this\n     * method directly.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    public void drawOutline(Graphics2D g2, Rectangle2D area) {\n        if (!this.outlineVisible) {\n            return;\n        }\n        if ((this.outlineStroke != null) && (this.outlinePaint != null)) {\n            g2.setStroke(this.outlineStroke);\n            g2.setPaint(this.outlinePaint);\n            g2.draw(area);\n        }\n    }\n\n    /**\n     * Draws a message to state that there is no data to plot.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    protected void drawNoDataMessage(Graphics2D g2, Rectangle2D area) {\n        Shape savedClip = g2.getClip();\n        g2.clip(area);\n        String message = this.noDataMessage;\n        if (message != null) {\n            g2.setFont(this.noDataMessageFont);\n            g2.setPaint(this.noDataMessagePaint);\n            TextBlock block = TextUtilities.createTextBlock(\n                    this.noDataMessage, this.noDataMessageFont,\n                    this.noDataMessagePaint, 0.9f * (float) area.getWidth(),\n                    new G2TextMeasurer(g2));\n            block.draw(g2, (float) area.getCenterX(),\n                    (float) area.getCenterY(), TextBlockAnchor.CENTER);\n        }\n        g2.setClip(savedClip);\n    }\n\n    /**\n     * Creates a plot entity that contains a reference to the plot and the\n     * data area as shape.\n     *\n     * @param dataArea  the data area used as hot spot for the entity.\n     * @param plotState  the plot rendering info containing a reference to the\n     *     EntityCollection.\n     * @param toolTip  the tool tip (defined in the respective Plot\n     *     subclass) (<code>null</code> permitted).\n     * @param urlText  the url (defined in the respective Plot subclass)\n     *     (<code>null</code> permitted).\n     *\n     *  @since 1.0.13\n     */\n \tprotected void createAndAddEntity(Rectangle2D dataArea,\n            PlotRenderingInfo plotState, String toolTip, String urlText){\n\t\tif (plotState != null && plotState.getOwner() != null) {\n\t\t\tEntityCollection e = plotState.getOwner().getEntityCollection();\n\t\t\tif (e != null) {\n                e.add(new PlotEntity(dataArea, this, toolTip, urlText));\n            }\n\t\t}\n\t}\n\n    /**\n     * Handles a 'click' on the plot.  Since the plot does not maintain any\n     * information about where it has been drawn, the plot rendering info is\n     * supplied as an argument so that the plot dimensions can be determined.\n     *\n     * @param x  the x coordinate (in Java2D space).\n     * @param y  the y coordinate (in Java2D space).\n     * @param info  an object containing information about the dimensions of\n     *              the plot.\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n        // provides a 'no action' default\n    }\n\n    /**\n     * Performs a zoom on the plot.  Subclasses should override if zooming is\n     * appropriate for the type of plot.\n     *\n     * @param percent  the zoom percentage.\n     */\n    public void zoom(double percent) {\n        // do nothing by default.\n    }\n\n    /**\n     * Receives notification of a change to one of the plot's axes.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void axisChanged(AxisChangeEvent event) {\n        fireChangeEvent();\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The plot reacts by passing on a plot change event to all registered\n     * listeners.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n        PlotChangeEvent newEvent = new PlotChangeEvent(this);\n        newEvent.setType(ChartChangeEventType.DATASET_UPDATED);\n        notifyListeners(newEvent);\n    }\n\n    /**\n     * Receives notification of a change to a marker that is assigned to the\n     * plot.\n     *\n     * @param event  the event.\n     *\n     * @since 1.0.3\n     */\n    public void markerChanged(MarkerChangeEvent event) {\n        fireChangeEvent();\n    }\n\n    /**\n     * Adjusts the supplied x-value.\n     *\n     * @param x  the x-value.\n     * @param w1  width 1.\n     * @param w2  width 2.\n     * @param edge  the edge (left or right).\n     *\n     * @return The adjusted x-value.\n     */\n    protected double getRectX(double x, double w1, double w2,\n                              RectangleEdge edge) {\n\n        double result = x;\n        if (edge == RectangleEdge.LEFT) {\n            result = result + w1;\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            result = result + w2;\n        }\n        return result;\n\n    }\n\n    /**\n     * Adjusts the supplied y-value.\n     *\n     * @param y  the x-value.\n     * @param h1  height 1.\n     * @param h2  height 2.\n     * @param edge  the edge (top or bottom).\n     *\n     * @return The adjusted y-value.\n     */\n    protected double getRectY(double y, double h1, double h2,\n                              RectangleEdge edge) {\n\n        double result = y;\n        if (edge == RectangleEdge.TOP) {\n            result = result + h1;\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            result = result + h2;\n        }\n        return result;\n\n    }\n\n    /**\n     * Tests this plot for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Plot)) {\n            return false;\n        }\n        Plot that = (Plot) obj;\n        if (!ObjectUtilities.equal(this.noDataMessage, that.noDataMessage)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(\n            this.noDataMessageFont, that.noDataMessageFont\n        )) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.noDataMessagePaint,\n                that.noDataMessagePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.insets, that.insets)) {\n            return false;\n        }\n        if (this.outlineVisible != that.outlineVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.outlineStroke, that.outlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.backgroundPaint, that.backgroundPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundImage,\n                that.backgroundImage)) {\n            return false;\n        }\n        if (this.backgroundImageAlignment != that.backgroundImageAlignment) {\n            return false;\n        }\n        if (this.backgroundImageAlpha != that.backgroundImageAlpha) {\n            return false;\n        }\n        if (this.foregroundAlpha != that.foregroundAlpha) {\n            return false;\n        }\n        if (this.backgroundAlpha != that.backgroundAlpha) {\n            return false;\n        }\n        if (!this.drawingSupplier.equals(that.drawingSupplier)) {\n            return false;\n        }\n        if (this.notify != that.notify) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Creates a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the plot does not\n     *         support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        Plot clone = (Plot) super.clone();\n        // private Plot parent <-- don't clone the parent plot, but take care\n        // childs in combined plots instead\n        if (this.datasetGroup != null) {\n            clone.datasetGroup\n                = (DatasetGroup) ObjectUtilities.clone(this.datasetGroup);\n        }\n        clone.drawingSupplier\n            = (DrawingSupplier) ObjectUtilities.clone(this.drawingSupplier);\n        clone.listenerList = new EventListenerList();\n        return clone;\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.noDataMessagePaint, stream);\n        SerialUtilities.writeStroke(this.outlineStroke, stream);\n        SerialUtilities.writePaint(this.outlinePaint, stream);\n        // backgroundImage\n        SerialUtilities.writePaint(this.backgroundPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.noDataMessagePaint = SerialUtilities.readPaint(stream);\n        this.outlineStroke = SerialUtilities.readStroke(stream);\n        this.outlinePaint = SerialUtilities.readPaint(stream);\n        // backgroundImage\n        this.backgroundPaint = SerialUtilities.readPaint(stream);\n\n        this.listenerList = new EventListenerList();\n\n    }\n\n    /**\n\t * Sets a reference to the plot that the axis is assigned to.\n\t * <P>\n\t * This method is used internally, you shouldn't need to call it yourself.\n\t *\n\t * @param axis TODO\n\t * @see #getPlot()\n\t */\n\tpublic void setPlot(Axis axis) {\n\t    axis.plot = this;\n\t    axis.configure();\n\t}\n\n\t/**\n     * Resolves a domain axis location for a given plot orientation.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param orientation  the orientation (<code>null</code> not permitted).\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public static RectangleEdge resolveDomainAxisLocation(\n            AxisLocation location, PlotOrientation orientation) {\n\n        if (location == null) {\n            throw new IllegalArgumentException(\"Null 'location' argument.\");\n        }\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n\n        RectangleEdge result = null;\n\n        if (location == AxisLocation.TOP_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.RIGHT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.TOP;\n            }\n        }\n        else if (location == AxisLocation.TOP_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.LEFT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.TOP;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.RIGHT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.LEFT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n        }\n        // the above should cover all the options...\n        if (result == null) {\n            throw new IllegalStateException(\"resolveDomainAxisLocation()\");\n        }\n        return result;\n\n    }\n\n    /**\n     * Resolves a range axis location for a given plot orientation.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param orientation  the orientation (<code>null</code> not permitted).\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public static RectangleEdge resolveRangeAxisLocation(\n            AxisLocation location, PlotOrientation orientation) {\n\n        if (location == null) {\n            throw new IllegalArgumentException(\"Null 'location' argument.\");\n        }\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n\n        RectangleEdge result = null;\n\n        if (location == AxisLocation.TOP_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.TOP;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.RIGHT;\n            }\n        }\n        else if (location == AxisLocation.TOP_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.TOP;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.LEFT;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.RIGHT;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.LEFT;\n            }\n        }\n\n        // the above should cover all the options...\n        if (result == null) {\n            throw new IllegalStateException(\"resolveRangeAxisLocation()\");\n        }\n        return result;\n\n    }\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 1395,
                        "lineEnd": 1406,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.axis.Axis\nRationale: The method setPlot() directly modifies the plot reference of the Axis instance, making it more appropriate for the Axis class to manage its own plot association.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1408,
                        "lineEnd": 1466,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "description": "move method to org.jfree.chart.plot.XYPlot\nRationale: The method resolveDomainAxisLocation() is related to determining the position of axes based on their orientation, which is a core functionality of the XYPlot class in charting libraries.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1468,
                        "lineEnd": 1527,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "description": "move method to org.jfree.chart.plot.XYPlot\nRationale: The method resolveRangeAxisLocation() is related to determining the location of range axes based on plot orientation, which is a core functionality of the XYPlot class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 11941
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "resolveDomainAxisLocation",
                            "method_signature": "public static RectangleEdge resolveDomainAxisLocation(AxisLocation location, PlotOrientation orientation)",
                            "target_class": "AxisLocationResolver",
                            "rationale": "This method is a utility function that resolves axis locations based on orientation, which could be better organized in a dedicated class for axis location resolution."
                        },
                        {
                            "method_name": "resolveRangeAxisLocation",
                            "method_signature": "public static RectangleEdge resolveRangeAxisLocation(AxisLocation location, PlotOrientation orientation)",
                            "target_class": "AxisLocationResolver",
                            "rationale": "Similar to resolveDomainAxisLocation, this method resolves range axis locations and should be moved to a dedicated class for better organization and separation of concerns."
                        },
                        {
                            "method_name": "setPlot",
                            "method_signature": "public void setPlot(Axis axis)",
                            "target_class": "Axis",
                            "rationale": "This method directly modifies the Axis object, indicating that it may be more appropriate for it to reside within the Axis class itself."
                        }
                    ],
                    "llm_response_time": 4181
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "resolveDomainAxisLocation",
                            "method_signature": "public static RectangleEdge resolveDomainAxisLocation(AxisLocation location, PlotOrientation orientation)",
                            "target_class": "AxisLocationResolver",
                            "rationale": "This method is a utility function that resolves axis locations based on orientation and should be moved to a dedicated class that handles axis-related logic."
                        },
                        {
                            "method_name": "resolveRangeAxisLocation",
                            "method_signature": "public static RectangleEdge resolveRangeAxisLocation(AxisLocation location, PlotOrientation orientation)",
                            "target_class": "AxisLocationResolver",
                            "rationale": "Similar to resolveDomainAxisLocation, this method is a utility function for resolving range axis locations and should be moved to a dedicated class that handles axis-related logic."
                        },
                        {
                            "method_name": "setPlot",
                            "method_signature": "public void setPlot(Axis axis)",
                            "target_class": "Axis",
                            "rationale": "This method directly modifies the Axis object and should be part of the Axis class to maintain encapsulation and clarity of responsibilities."
                        }
                    ],
                    "llm_response_time": 3078
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "resolveDomainAxisLocation",
                            "method_signature": "public static RectangleEdge resolveDomainAxisLocation(AxisLocation location, PlotOrientation orientation)",
                            "target_class": "AxisLocationResolver",
                            "rationale": "This method is responsible for resolving the domain axis location based on the provided parameters, which is a utility function that does not inherently belong to the Plot class."
                        },
                        {
                            "method_name": "resolveRangeAxisLocation",
                            "method_signature": "public static RectangleEdge resolveRangeAxisLocation(AxisLocation location, PlotOrientation orientation)",
                            "target_class": "AxisLocationResolver",
                            "rationale": "Similar to resolveDomainAxisLocation, this method resolves the range axis location and should be moved to a dedicated utility class that handles axis location resolution."
                        },
                        {
                            "method_name": "setPlot",
                            "method_signature": "public void setPlot(Axis axis)",
                            "target_class": "Axis",
                            "rationale": "This method modifies the Axis class by setting a reference to the plot, which indicates that it is more appropriate for the Axis class to manage its relationship with the Plot."
                        }
                    ],
                    "llm_response_time": 3163
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "resolveDomainAxisLocation",
                            "method_signature": "public static RectangleEdge resolveDomainAxisLocation(AxisLocation location, PlotOrientation orientation)",
                            "target_class": "AxisLocationResolver",
                            "rationale": "This method is a utility function that resolves axis locations based on orientation, which could be better organized in a dedicated class for axis location resolution."
                        },
                        {
                            "method_name": "resolveRangeAxisLocation",
                            "method_signature": "public static RectangleEdge resolveRangeAxisLocation(AxisLocation location, PlotOrientation orientation)",
                            "target_class": "AxisLocationResolver",
                            "rationale": "Similar to resolveDomainAxisLocation, this method resolves range axis locations and should be moved to a dedicated class for better organization and separation of concerns."
                        },
                        {
                            "method_name": "setPlot",
                            "method_signature": "public void setPlot(Axis axis)",
                            "target_class": "Axis",
                            "rationale": "This method directly modifies the Axis object, indicating that it may be more appropriate for it to reside within the Axis class itself."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setPlot",
                    "resolveDomainAxisLocation",
                    "resolveRangeAxisLocation"
                ],
                "llm_response_time": 1399
            },
            "targetClassMap": {
                "setPlot": {
                    "target_classes": [
                        {
                            "class_name": "Axis",
                            "similarity_score": 0.7512185270797515
                        },
                        {
                            "class_name": "DatasetGroup",
                            "similarity_score": 0.6681623354762872
                        },
                        {
                            "class_name": "DrawingSupplier",
                            "similarity_score": 0.6257309002352999
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Axis",
                        "DatasetGroup",
                        "DrawingSupplier"
                    ],
                    "llm_response_time": 1913,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "resolveDomainAxisLocation": {
                    "target_classes": [
                        {
                            "class_name": "Marker",
                            "similarity_score": 0.47797380227178826
                        },
                        {
                            "class_name": "XYPlot",
                            "similarity_score": 0.5802195901061773
                        },
                        {
                            "class_name": "PiePlot",
                            "similarity_score": 0.4881928147067651
                        },
                        {
                            "class_name": "Pannable",
                            "similarity_score": 0.26727513003265696
                        },
                        {
                            "class_name": "RingPlot",
                            "similarity_score": 0.5226553958704689
                        },
                        {
                            "class_name": "Zoomable",
                            "similarity_score": 0.21858019048791746
                        },
                        {
                            "class_name": "Crosshair",
                            "similarity_score": 0.5024206450660912
                        },
                        {
                            "class_name": "DialShape",
                            "similarity_score": 0.5315821174422418
                        },
                        {
                            "class_name": "MeterPlot",
                            "similarity_score": 0.5394131851759071
                        },
                        {
                            "class_name": "PiePlot3D",
                            "similarity_score": 0.6155356749740766
                        },
                        {
                            "class_name": "PlotState",
                            "similarity_score": 0.3667214959416494
                        },
                        {
                            "class_name": "PolarPlot",
                            "similarity_score": 0.5129429478519796
                        },
                        {
                            "class_name": "CompassPlot",
                            "similarity_score": 0.5264998133982739
                        },
                        {
                            "class_name": "ContourPlot",
                            "similarity_score": 0.5693864264352797
                        },
                        {
                            "class_name": "GreyPalette",
                            "similarity_score": 0.41740616176967626
                        },
                        {
                            "class_name": "ValueMarker",
                            "similarity_score": 0.40278231259204816
                        },
                        {
                            "class_name": "CategoryPlot",
                            "similarity_score": 0.5543708087848631
                        },
                        {
                            "class_name": "ColorPalette",
                            "similarity_score": 0.54672204467499
                        },
                        {
                            "class_name": "JThermometer",
                            "similarity_score": 0.4519671558208346
                        },
                        {
                            "class_name": "PiePlotState",
                            "similarity_score": 0.3499802943997173
                        },
                        {
                            "class_name": "WaferMapPlot",
                            "similarity_score": 0.5582707921250727
                        },
                        {
                            "class_name": "MeterInterval",
                            "similarity_score": 0.5186507526911924
                        },
                        {
                            "class_name": "PlotUtilities",
                            "similarity_score": 0.5139548244560364
                        },
                        {
                            "class_name": "SpiderWebPlot",
                            "similarity_score": 0.5303866320441787
                        },
                        {
                            "class_name": "ValueAxisPlot",
                            "similarity_score": 0.24187916825426117
                        },
                        {
                            "class_name": "CategoryMarker",
                            "similarity_score": 0.44833795280906485
                        },
                        {
                            "class_name": "CrosshairState",
                            "similarity_score": 0.33845204575330157
                        },
                        {
                            "class_name": "IntervalMarker",
                            "similarity_score": 0.41641949649076426
                        },
                        {
                            "class_name": "PieLabelRecord",
                            "similarity_score": 0.481069919469396
                        },
                        {
                            "class_name": "RainbowPalette",
                            "similarity_score": 0.020376463333621225
                        },
                        {
                            "class_name": "DrawingSupplier",
                            "similarity_score": 0.20733932525187604
                        },
                        {
                            "class_name": "FastScatterPlot",
                            "similarity_score": 0.5287166099470323
                        },
                        {
                            "class_name": "MultiplePiePlot",
                            "similarity_score": 0.6253214542437218
                        },
                        {
                            "class_name": "PlotOrientation",
                            "similarity_score": 0.5521362220619077
                        },
                        {
                            "class_name": "ThermometerPlot",
                            "similarity_score": 0.49871421371668206
                        },
                        {
                            "class_name": "ContourValuePlot",
                            "similarity_score": 0.2363532034576229
                        },
                        {
                            "class_name": "XYCrosshairState",
                            "similarity_score": 0.3582937284554735
                        },
                        {
                            "class_name": "PieLabelLinkStyle",
                            "similarity_score": 0.5705162250513179
                        },
                        {
                            "class_name": "PlotRenderingInfo",
                            "similarity_score": 0.4897710105127554
                        },
                        {
                            "class_name": "CombinedRangeXYPlot",
                            "similarity_score": 0.6168449258074612
                        },
                        {
                            "class_name": "PieLabelDistributor",
                            "similarity_score": 0.5522040772454879
                        },
                        {
                            "class_name": "CombinedDomainXYPlot",
                            "similarity_score": 0.6151282348426037
                        },
                        {
                            "class_name": "ContourPlotUtilities",
                            "similarity_score": 0.308722992060357
                        },
                        {
                            "class_name": "SeriesRenderingOrder",
                            "similarity_score": 0.4903943606595251
                        },
                        {
                            "class_name": "DatasetRenderingOrder",
                            "similarity_score": 0.4864154818159188
                        },
                        {
                            "class_name": "CategoryCrosshairState",
                            "similarity_score": 0.4642292039780136
                        },
                        {
                            "class_name": "DefaultDrawingSupplier",
                            "similarity_score": 0.5289901773311585
                        },
                        {
                            "class_name": "CombinedRangeCategoryPlot",
                            "similarity_score": 0.643218421545225
                        },
                        {
                            "class_name": "CombinedDomainCategoryPlot",
                            "similarity_score": 0.6266074030657748
                        },
                        {
                            "class_name": "AbstractPieLabelDistributor",
                            "similarity_score": 0.39618153916509696
                        },
                        {
                            "class_name": "Marker",
                            "similarity_score": 0.7157290787501822
                        },
                        {
                            "class_name": "XYPlot",
                            "similarity_score": 0.7424825365110702
                        },
                        {
                            "class_name": "PiePlot",
                            "similarity_score": 0.7013721689072462
                        },
                        {
                            "class_name": "Pannable",
                            "similarity_score": 0.1407134831114007
                        },
                        {
                            "class_name": "RingPlot",
                            "similarity_score": 0.6797299279286484
                        },
                        {
                            "class_name": "Zoomable",
                            "similarity_score": 0.055913868436912734
                        },
                        {
                            "class_name": "Crosshair",
                            "similarity_score": 0.6470191656804446
                        },
                        {
                            "class_name": "DialShape",
                            "similarity_score": 0.5921321351579465
                        },
                        {
                            "class_name": "MeterPlot",
                            "similarity_score": 0.6916889027653081
                        },
                        {
                            "class_name": "PiePlot3D",
                            "similarity_score": 0.6428788055300335
                        },
                        {
                            "class_name": "PlotState",
                            "similarity_score": 0.4466655699445155
                        },
                        {
                            "class_name": "PolarPlot",
                            "similarity_score": 0.6820210712310665
                        },
                        {
                            "class_name": "CompassPlot",
                            "similarity_score": 0.6363493023682512
                        },
                        {
                            "class_name": "ContourPlot",
                            "similarity_score": 0.6677832340339495
                        },
                        {
                            "class_name": "GreyPalette",
                            "similarity_score": 0.3898771833279879
                        },
                        {
                            "class_name": "ValueMarker",
                            "similarity_score": 0.5715928449798597
                        },
                        {
                            "class_name": "CategoryPlot",
                            "similarity_score": 0.7419798873412011
                        },
                        {
                            "class_name": "ColorPalette",
                            "similarity_score": 0.6408562307431287
                        },
                        {
                            "class_name": "JThermometer",
                            "similarity_score": 0.5552207137523107
                        },
                        {
                            "class_name": "PiePlotState",
                            "similarity_score": 0.46773720461775836
                        },
                        {
                            "class_name": "WaferMapPlot",
                            "similarity_score": 0.5845910777807217
                        },
                        {
                            "class_name": "MeterInterval",
                            "similarity_score": 0.6580446255677982
                        },
                        {
                            "class_name": "PlotUtilities",
                            "similarity_score": 0.5940507290862727
                        },
                        {
                            "class_name": "SpiderWebPlot",
                            "similarity_score": 0.7097371007397769
                        },
                        {
                            "class_name": "ValueAxisPlot",
                            "similarity_score": 0.301549106660018
                        },
                        {
                            "class_name": "CategoryMarker",
                            "similarity_score": 0.6363697376860368
                        },
                        {
                            "class_name": "CrosshairState",
                            "similarity_score": 0.5417078135395165
                        },
                        {
                            "class_name": "IntervalMarker",
                            "similarity_score": 0.5843052010544134
                        },
                        {
                            "class_name": "PieLabelRecord",
                            "similarity_score": 0.602360881239274
                        },
                        {
                            "class_name": "RainbowPalette",
                            "similarity_score": 0.012962122684176325
                        },
                        {
                            "class_name": "DrawingSupplier",
                            "similarity_score": 0.1705819345440354
                        },
                        {
                            "class_name": "FastScatterPlot",
                            "similarity_score": 0.7199869571509768
                        },
                        {
                            "class_name": "MultiplePiePlot",
                            "similarity_score": 0.7356594429938904
                        },
                        {
                            "class_name": "PlotOrientation",
                            "similarity_score": 0.6478800723013955
                        },
                        {
                            "class_name": "ThermometerPlot",
                            "similarity_score": 0.6695690511079776
                        },
                        {
                            "class_name": "ContourValuePlot",
                            "similarity_score": 0.2860600065044208
                        },
                        {
                            "class_name": "XYCrosshairState",
                            "similarity_score": 0.4137219611454446
                        },
                        {
                            "class_name": "PieLabelLinkStyle",
                            "similarity_score": 0.6625745574719523
                        },
                        {
                            "class_name": "PlotRenderingInfo",
                            "similarity_score": 0.646522083585666
                        },
                        {
                            "class_name": "CombinedRangeXYPlot",
                            "similarity_score": 0.7238061222757176
                        },
                        {
                            "class_name": "PieLabelDistributor",
                            "similarity_score": 0.5498519846013624
                        },
                        {
                            "class_name": "CombinedDomainXYPlot",
                            "similarity_score": 0.7319804317915517
                        },
                        {
                            "class_name": "ContourPlotUtilities",
                            "similarity_score": 0.3440402760580283
                        },
                        {
                            "class_name": "SeriesRenderingOrder",
                            "similarity_score": 0.5873658478783188
                        },
                        {
                            "class_name": "DatasetRenderingOrder",
                            "similarity_score": 0.5873658478783188
                        },
                        {
                            "class_name": "CategoryCrosshairState",
                            "similarity_score": 0.5924445929637052
                        },
                        {
                            "class_name": "DefaultDrawingSupplier",
                            "similarity_score": 0.5834899643032392
                        },
                        {
                            "class_name": "CombinedRangeCategoryPlot",
                            "similarity_score": 0.7286583488150699
                        },
                        {
                            "class_name": "CombinedDomainCategoryPlot",
                            "similarity_score": 0.7324632623651359
                        },
                        {
                            "class_name": "AbstractPieLabelDistributor",
                            "similarity_score": 0.553680071066559
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "XYPlot",
                        "CategoryPlot",
                        "MultiplePiePlot",
                        "CombinedDomainCategoryPlot",
                        "CombinedDomainXYPlot",
                        "CombinedRangeCategoryPlot",
                        "CombinedRangeXYPlot",
                        "FastScatterPlot",
                        "Marker",
                        "SpiderWebPlot",
                        "PiePlot",
                        "MeterPlot",
                        "PolarPlot",
                        "RingPlot",
                        "ThermometerPlot",
                        "ContourPlot",
                        "PieLabelLinkStyle",
                        "MeterInterval",
                        "PlotOrientation",
                        "Crosshair",
                        "PlotRenderingInfo",
                        "PiePlot3D",
                        "ColorPalette",
                        "CategoryMarker",
                        "CompassPlot",
                        "PieLabelRecord",
                        "PlotUtilities",
                        "CategoryCrosshairState",
                        "DialShape",
                        "SeriesRenderingOrder",
                        "DatasetRenderingOrder",
                        "WaferMapPlot",
                        "IntervalMarker",
                        "DefaultDrawingSupplier",
                        "ValueMarker",
                        "JThermometer",
                        "AbstractPieLabelDistributor",
                        "PieLabelDistributor",
                        "CrosshairState",
                        "PiePlotState",
                        "PlotState",
                        "GreyPalette",
                        "XYCrosshairState",
                        "ContourPlotUtilities",
                        "ValueAxisPlot",
                        "ContourValuePlot",
                        "Pannable",
                        "Zoomable",
                        "DrawingSupplier",
                        "RainbowPalette"
                    ],
                    "llm_response_time": 1722,
                    "similarity_computation_time": 2824,
                    "similarity_metric": "cosine"
                },
                "resolveRangeAxisLocation": {
                    "target_classes": [
                        {
                            "class_name": "Marker",
                            "similarity_score": 0.4785138856641858
                        },
                        {
                            "class_name": "XYPlot",
                            "similarity_score": 0.5803139108978642
                        },
                        {
                            "class_name": "PiePlot",
                            "similarity_score": 0.4881928147067651
                        },
                        {
                            "class_name": "Pannable",
                            "similarity_score": 0.26727513003265696
                        },
                        {
                            "class_name": "RingPlot",
                            "similarity_score": 0.5226553958704689
                        },
                        {
                            "class_name": "Zoomable",
                            "similarity_score": 0.2194778504077857
                        },
                        {
                            "class_name": "Crosshair",
                            "similarity_score": 0.5024206450660912
                        },
                        {
                            "class_name": "DialShape",
                            "similarity_score": 0.5315821174422418
                        },
                        {
                            "class_name": "MeterPlot",
                            "similarity_score": 0.5399552099349219
                        },
                        {
                            "class_name": "PiePlot3D",
                            "similarity_score": 0.6155356749740766
                        },
                        {
                            "class_name": "PlotState",
                            "similarity_score": 0.3667214959416494
                        },
                        {
                            "class_name": "PolarPlot",
                            "similarity_score": 0.5131787620060123
                        },
                        {
                            "class_name": "CompassPlot",
                            "similarity_score": 0.5264998133982739
                        },
                        {
                            "class_name": "ContourPlot",
                            "similarity_score": 0.570350985145686
                        },
                        {
                            "class_name": "GreyPalette",
                            "similarity_score": 0.41740616176967626
                        },
                        {
                            "class_name": "ValueMarker",
                            "similarity_score": 0.4032103490560142
                        },
                        {
                            "class_name": "CategoryPlot",
                            "similarity_score": 0.5546340808337997
                        },
                        {
                            "class_name": "ColorPalette",
                            "similarity_score": 0.54672204467499
                        },
                        {
                            "class_name": "JThermometer",
                            "similarity_score": 0.4526897252146329
                        },
                        {
                            "class_name": "PiePlotState",
                            "similarity_score": 0.3499802943997173
                        },
                        {
                            "class_name": "WaferMapPlot",
                            "similarity_score": 0.5582707921250727
                        },
                        {
                            "class_name": "MeterInterval",
                            "similarity_score": 0.5216013574789425
                        },
                        {
                            "class_name": "PlotUtilities",
                            "similarity_score": 0.5139548244560364
                        },
                        {
                            "class_name": "SpiderWebPlot",
                            "similarity_score": 0.5303866320441787
                        },
                        {
                            "class_name": "ValueAxisPlot",
                            "similarity_score": 0.24608576248477007
                        },
                        {
                            "class_name": "CategoryMarker",
                            "similarity_score": 0.44833795280906485
                        },
                        {
                            "class_name": "CrosshairState",
                            "similarity_score": 0.33828080768310004
                        },
                        {
                            "class_name": "IntervalMarker",
                            "similarity_score": 0.4167008610154202
                        },
                        {
                            "class_name": "PieLabelRecord",
                            "similarity_score": 0.481069919469396
                        },
                        {
                            "class_name": "RainbowPalette",
                            "similarity_score": 0.020376463333621225
                        },
                        {
                            "class_name": "DrawingSupplier",
                            "similarity_score": 0.20733932525187604
                        },
                        {
                            "class_name": "FastScatterPlot",
                            "similarity_score": 0.5294434065981173
                        },
                        {
                            "class_name": "MultiplePiePlot",
                            "similarity_score": 0.6253214542437218
                        },
                        {
                            "class_name": "PlotOrientation",
                            "similarity_score": 0.5534399675685474
                        },
                        {
                            "class_name": "ThermometerPlot",
                            "similarity_score": 0.4997647804892573
                        },
                        {
                            "class_name": "ContourValuePlot",
                            "similarity_score": 0.24057379637650902
                        },
                        {
                            "class_name": "XYCrosshairState",
                            "similarity_score": 0.3582937284554735
                        },
                        {
                            "class_name": "PieLabelLinkStyle",
                            "similarity_score": 0.5705162250513179
                        },
                        {
                            "class_name": "PlotRenderingInfo",
                            "similarity_score": 0.4897710105127554
                        },
                        {
                            "class_name": "CombinedRangeXYPlot",
                            "similarity_score": 0.617268147025854
                        },
                        {
                            "class_name": "PieLabelDistributor",
                            "similarity_score": 0.5522040772454879
                        },
                        {
                            "class_name": "CombinedDomainXYPlot",
                            "similarity_score": 0.6154269858065875
                        },
                        {
                            "class_name": "ContourPlotUtilities",
                            "similarity_score": 0.3172986307287003
                        },
                        {
                            "class_name": "SeriesRenderingOrder",
                            "similarity_score": 0.4903943606595251
                        },
                        {
                            "class_name": "DatasetRenderingOrder",
                            "similarity_score": 0.4864154818159188
                        },
                        {
                            "class_name": "CategoryCrosshairState",
                            "similarity_score": 0.46493525599927293
                        },
                        {
                            "class_name": "DefaultDrawingSupplier",
                            "similarity_score": 0.5289901773311585
                        },
                        {
                            "class_name": "CombinedRangeCategoryPlot",
                            "similarity_score": 0.6444956622552036
                        },
                        {
                            "class_name": "CombinedDomainCategoryPlot",
                            "similarity_score": 0.6268072778354927
                        },
                        {
                            "class_name": "AbstractPieLabelDistributor",
                            "similarity_score": 0.39618153916509696
                        },
                        {
                            "class_name": "Marker",
                            "similarity_score": 0.7161094821935786
                        },
                        {
                            "class_name": "XYPlot",
                            "similarity_score": 0.7425613040524054
                        },
                        {
                            "class_name": "PiePlot",
                            "similarity_score": 0.7013721689072462
                        },
                        {
                            "class_name": "Pannable",
                            "similarity_score": 0.1407134831114007
                        },
                        {
                            "class_name": "RingPlot",
                            "similarity_score": 0.6797299279286484
                        },
                        {
                            "class_name": "Zoomable",
                            "similarity_score": 0.055913868436912734
                        },
                        {
                            "class_name": "Crosshair",
                            "similarity_score": 0.6470191656804446
                        },
                        {
                            "class_name": "DialShape",
                            "similarity_score": 0.5921321351579465
                        },
                        {
                            "class_name": "MeterPlot",
                            "similarity_score": 0.6918645697882327
                        },
                        {
                            "class_name": "PiePlot3D",
                            "similarity_score": 0.6428788055300335
                        },
                        {
                            "class_name": "PlotState",
                            "similarity_score": 0.4466655699445155
                        },
                        {
                            "class_name": "PolarPlot",
                            "similarity_score": 0.6822264064926142
                        },
                        {
                            "class_name": "CompassPlot",
                            "similarity_score": 0.6363493023682512
                        },
                        {
                            "class_name": "ContourPlot",
                            "similarity_score": 0.668875275299745
                        },
                        {
                            "class_name": "GreyPalette",
                            "similarity_score": 0.3898771833279879
                        },
                        {
                            "class_name": "ValueMarker",
                            "similarity_score": 0.5715928449798597
                        },
                        {
                            "class_name": "CategoryPlot",
                            "similarity_score": 0.7420725190374984
                        },
                        {
                            "class_name": "ColorPalette",
                            "similarity_score": 0.6408562307431287
                        },
                        {
                            "class_name": "JThermometer",
                            "similarity_score": 0.5552207137523107
                        },
                        {
                            "class_name": "PiePlotState",
                            "similarity_score": 0.46773720461775836
                        },
                        {
                            "class_name": "WaferMapPlot",
                            "similarity_score": 0.5845910777807217
                        },
                        {
                            "class_name": "MeterInterval",
                            "similarity_score": 0.660513836170304
                        },
                        {
                            "class_name": "PlotUtilities",
                            "similarity_score": 0.5940507290862727
                        },
                        {
                            "class_name": "SpiderWebPlot",
                            "similarity_score": 0.7097371007397769
                        },
                        {
                            "class_name": "ValueAxisPlot",
                            "similarity_score": 0.31068695837698823
                        },
                        {
                            "class_name": "CategoryMarker",
                            "similarity_score": 0.6363697376860368
                        },
                        {
                            "class_name": "CrosshairState",
                            "similarity_score": 0.5417078135395165
                        },
                        {
                            "class_name": "IntervalMarker",
                            "similarity_score": 0.5843052010544134
                        },
                        {
                            "class_name": "PieLabelRecord",
                            "similarity_score": 0.602360881239274
                        },
                        {
                            "class_name": "RainbowPalette",
                            "similarity_score": 0.012962122684176325
                        },
                        {
                            "class_name": "DrawingSupplier",
                            "similarity_score": 0.1705819345440354
                        },
                        {
                            "class_name": "FastScatterPlot",
                            "similarity_score": 0.720931202340683
                        },
                        {
                            "class_name": "MultiplePiePlot",
                            "similarity_score": 0.7356594429938904
                        },
                        {
                            "class_name": "PlotOrientation",
                            "similarity_score": 0.6478800723013955
                        },
                        {
                            "class_name": "ThermometerPlot",
                            "similarity_score": 0.6702163946959003
                        },
                        {
                            "class_name": "ContourValuePlot",
                            "similarity_score": 0.29423314954740426
                        },
                        {
                            "class_name": "XYCrosshairState",
                            "similarity_score": 0.4137219611454446
                        },
                        {
                            "class_name": "PieLabelLinkStyle",
                            "similarity_score": 0.6625745574719523
                        },
                        {
                            "class_name": "PlotRenderingInfo",
                            "similarity_score": 0.646522083585666
                        },
                        {
                            "class_name": "CombinedRangeXYPlot",
                            "similarity_score": 0.7241512849472844
                        },
                        {
                            "class_name": "PieLabelDistributor",
                            "similarity_score": 0.5498519846013624
                        },
                        {
                            "class_name": "CombinedDomainXYPlot",
                            "similarity_score": 0.7321460382240838
                        },
                        {
                            "class_name": "ContourPlotUtilities",
                            "similarity_score": 0.36096028963465265
                        },
                        {
                            "class_name": "SeriesRenderingOrder",
                            "similarity_score": 0.5873658478783188
                        },
                        {
                            "class_name": "DatasetRenderingOrder",
                            "similarity_score": 0.5873658478783188
                        },
                        {
                            "class_name": "CategoryCrosshairState",
                            "similarity_score": 0.5924445929637052
                        },
                        {
                            "class_name": "DefaultDrawingSupplier",
                            "similarity_score": 0.5834899643032392
                        },
                        {
                            "class_name": "CombinedRangeCategoryPlot",
                            "similarity_score": 0.7292391073290032
                        },
                        {
                            "class_name": "CombinedDomainCategoryPlot",
                            "similarity_score": 0.7324632623651359
                        },
                        {
                            "class_name": "AbstractPieLabelDistributor",
                            "similarity_score": 0.553680071066559
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "XYPlot",
                        "CategoryPlot",
                        "PlotOrientation",
                        "MultiplePiePlot",
                        "CombinedDomainCategoryPlot",
                        "CombinedDomainXYPlot",
                        "CombinedRangeCategoryPlot",
                        "CombinedRangeXYPlot",
                        "FastScatterPlot",
                        "Marker",
                        "SpiderWebPlot",
                        "PiePlot",
                        "MeterPlot",
                        "PolarPlot",
                        "RingPlot",
                        "ThermometerPlot",
                        "ContourPlot",
                        "PieLabelLinkStyle",
                        "MeterInterval",
                        "Crosshair",
                        "PlotRenderingInfo",
                        "PiePlot3D",
                        "ColorPalette",
                        "CategoryMarker",
                        "CompassPlot",
                        "PieLabelRecord",
                        "PlotUtilities",
                        "CategoryCrosshairState",
                        "DialShape",
                        "SeriesRenderingOrder",
                        "DatasetRenderingOrder",
                        "WaferMapPlot",
                        "IntervalMarker",
                        "DefaultDrawingSupplier",
                        "ValueMarker",
                        "JThermometer",
                        "AbstractPieLabelDistributor",
                        "PieLabelDistributor",
                        "CrosshairState",
                        "PiePlotState",
                        "PlotState",
                        "GreyPalette",
                        "XYCrosshairState",
                        "ContourPlotUtilities",
                        "ValueAxisPlot",
                        "ContourValuePlot",
                        "Pannable",
                        "Zoomable",
                        "DrawingSupplier",
                        "RainbowPalette"
                    ],
                    "llm_response_time": 1438,
                    "similarity_computation_time": 58,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.axis.ValueAxis::setRangeGridlinesVisible(boolean):void need move org.jfree.chart.plot.FastScatterPlot",
        "class_name": "org.jfree.chart.axis.ValueAxis",
        "telemetry": {
            "id": "8ca7e772-4388-444c-9599-bf2286b5d3f1",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1640,
                "lineStart": 141,
                "lineEnd": 1780,
                "bodyLineStart": 141,
                "language": "java",
                "sourceCode": "/**\n * The base class for axes that display value data, where values are measured\n * using the <code>double</code> primitive.  The two key subclasses are\n * {@link DateAxis} and {@link NumberAxis}.\n */\npublic abstract class ValueAxis extends Axis\n        implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 3698345477322391456L;\n\n    /** The default axis range. */\n    public static final Range DEFAULT_RANGE = new Range(0.0, 1.0);\n\n    /** The default auto-range value. */\n    public static final boolean DEFAULT_AUTO_RANGE = true;\n\n    /** The default inverted flag setting. */\n    public static final boolean DEFAULT_INVERTED = false;\n\n    /** The default minimum auto range. */\n    public static final double DEFAULT_AUTO_RANGE_MINIMUM_SIZE = 0.00000001;\n\n    /** The default value for the lower margin (0.05 = 5%). */\n    public static final double DEFAULT_LOWER_MARGIN = 0.05;\n\n    /** The default value for the upper margin (0.05 = 5%). */\n    public static final double DEFAULT_UPPER_MARGIN = 0.05;\n\n    /**\n     * The default lower bound for the axis.\n     *\n     * @deprecated From 1.0.5 onwards, the axis defines a defaultRange\n     *     attribute (see {@link #getDefaultAutoRange()}).\n     */\n    public static final double DEFAULT_LOWER_BOUND = 0.0;\n\n    /**\n     * The default upper bound for the axis.\n     *\n     * @deprecated From 1.0.5 onwards, the axis defines a defaultRange\n     *     attribute (see {@link #getDefaultAutoRange()}).\n     */\n    public static final double DEFAULT_UPPER_BOUND = 1.0;\n\n    /** The default auto-tick-unit-selection value. */\n    public static final boolean DEFAULT_AUTO_TICK_UNIT_SELECTION = true;\n\n    /** The maximum tick count. */\n    public static final int MAXIMUM_TICK_COUNT = 500;\n\n    /**\n     * A flag that controls whether an arrow is drawn at the positive end of\n     * the axis line.\n     */\n    private boolean positiveArrowVisible;\n\n    /**\n     * A flag that controls whether an arrow is drawn at the negative end of\n     * the axis line.\n     */\n    private boolean negativeArrowVisible;\n\n    /** The shape used for an up arrow. */\n    private transient Shape upArrow;\n\n    /** The shape used for a down arrow. */\n    private transient Shape downArrow;\n\n    /** The shape used for a left arrow. */\n    private transient Shape leftArrow;\n\n    /** The shape used for a right arrow. */\n    private transient Shape rightArrow;\n\n    /** A flag that affects the orientation of the values on the axis. */\n    private boolean inverted;\n\n    /** The axis range. */\n    private Range range;\n\n    /**\n     * Flag that indicates whether the axis automatically scales to fit the\n     * chart data.\n     */\n    private boolean autoRange;\n\n    /** The minimum size for the 'auto' axis range (excluding margins). */\n    private double autoRangeMinimumSize;\n\n    /**\n     * The default range is used when the dataset is empty and the axis needs\n     * to determine the auto range.\n     *\n     * @since 1.0.5\n     */\n    private Range defaultAutoRange;\n\n    /**\n     * The upper margin percentage.  This indicates the amount by which the\n     * maximum axis value exceeds the maximum data value (as a percentage of\n     * the range on the axis) when the axis range is determined automatically.\n     */\n    private double upperMargin;\n\n    /**\n     * The lower margin.  This is a percentage that indicates the amount by\n     * which the minimum axis value is \"less than\" the minimum data value when\n     * the axis range is determined automatically.\n     */\n    private double lowerMargin;\n\n    /**\n     * If this value is positive, the amount is subtracted from the maximum\n     * data value to determine the lower axis range.  This can be used to\n     * provide a fixed \"window\" on dynamic data.\n     */\n    private double fixedAutoRange;\n\n    /**\n     * Flag that indicates whether or not the tick unit is selected\n     * automatically.\n     */\n    private boolean autoTickUnitSelection;\n\n    /** The standard tick units for the axis. */\n    private TickUnitSource standardTickUnits;\n\n    /** An index into an array of standard tick values. */\n    private int autoTickIndex;\n\n    /**\n     * The number of minor ticks per major tick unit.  This is an override\n     * field, if the value is > 0 it is used, otherwise the axis refers to the\n     * minorTickCount in the current tickUnit.\n     */\n    private int minorTickCount;\n\n    /** A flag indicating whether or not tick labels are rotated to vertical. */\n    private boolean verticalTickLabels;\n\n    /**\n     * Constructs a value axis.\n     *\n     * @param label  the axis label (<code>null</code> permitted).\n     * @param standardTickUnits  the source for standard tick units\n     *                           (<code>null</code> permitted).\n     */\n    protected ValueAxis(String label, TickUnitSource standardTickUnits) {\n\n        super(label);\n\n        this.positiveArrowVisible = false;\n        this.negativeArrowVisible = false;\n\n        this.range = DEFAULT_RANGE;\n        this.autoRange = DEFAULT_AUTO_RANGE;\n        this.defaultAutoRange = DEFAULT_RANGE;\n\n        this.inverted = DEFAULT_INVERTED;\n        this.autoRangeMinimumSize = DEFAULT_AUTO_RANGE_MINIMUM_SIZE;\n\n        this.lowerMargin = DEFAULT_LOWER_MARGIN;\n        this.upperMargin = DEFAULT_UPPER_MARGIN;\n\n        this.fixedAutoRange = 0.0;\n\n        this.autoTickUnitSelection = DEFAULT_AUTO_TICK_UNIT_SELECTION;\n        this.standardTickUnits = standardTickUnits;\n\n        Polygon p1 = new Polygon();\n        p1.addPoint(0, 0);\n        p1.addPoint(-2, 2);\n        p1.addPoint(2, 2);\n\n        this.upArrow = p1;\n\n        Polygon p2 = new Polygon();\n        p2.addPoint(0, 0);\n        p2.addPoint(-2, -2);\n        p2.addPoint(2, -2);\n\n        this.downArrow = p2;\n\n        Polygon p3 = new Polygon();\n        p3.addPoint(0, 0);\n        p3.addPoint(-2, -2);\n        p3.addPoint(-2, 2);\n\n        this.rightArrow = p3;\n\n        Polygon p4 = new Polygon();\n        p4.addPoint(0, 0);\n        p4.addPoint(2, -2);\n        p4.addPoint(2, 2);\n\n        this.leftArrow = p4;\n\n        this.verticalTickLabels = false;\n        this.minorTickCount = 0;\n\n    }\n\n    /**\n     * Returns <code>true</code> if the tick labels should be rotated (to\n     * vertical), and <code>false</code> otherwise.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     *\n     * @see #setVerticalTickLabels(boolean)\n     */\n    public boolean isVerticalTickLabels() {\n        return this.verticalTickLabels;\n    }\n\n    /**\n     * Sets the flag that controls whether the tick labels are displayed\n     * vertically (that is, rotated 90 degrees from horizontal).  If the flag\n     * is changed, an {@link AxisChangeEvent} is sent to all registered\n     * listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isVerticalTickLabels()\n     */\n    public void setVerticalTickLabels(boolean flag) {\n        if (this.verticalTickLabels != flag) {\n            this.verticalTickLabels = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns a flag that controls whether or not the axis line has an arrow\n     * drawn that points in the positive direction for the axis.\n     *\n     * @return A boolean.\n     *\n     * @see #setPositiveArrowVisible(boolean)\n     */\n    public boolean isPositiveArrowVisible() {\n        return this.positiveArrowVisible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not the axis lines has an arrow\n     * drawn that points in the positive direction for the axis, and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isPositiveArrowVisible()\n     */\n    public void setPositiveArrowVisible(boolean visible) {\n        this.positiveArrowVisible = visible;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns a flag that controls whether or not the axis line has an arrow\n     * drawn that points in the negative direction for the axis.\n     *\n     * @return A boolean.\n     *\n     * @see #setNegativeArrowVisible(boolean)\n     */\n    public boolean isNegativeArrowVisible() {\n        return this.negativeArrowVisible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not the axis lines has an arrow\n     * drawn that points in the negative direction for the axis, and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @see #setNegativeArrowVisible(boolean)\n     */\n    public void setNegativeArrowVisible(boolean visible) {\n        this.negativeArrowVisible = visible;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns a shape that can be displayed as an arrow pointing upwards at\n     * the end of an axis line.\n     *\n     * @return A shape (never <code>null</code>).\n     *\n     * @see #setUpArrow(Shape)\n     */\n    public Shape getUpArrow() {\n        return this.upArrow;\n    }\n\n    /**\n     * Sets the shape that can be displayed as an arrow pointing upwards at\n     * the end of an axis line and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param arrow  the arrow shape (<code>null</code> not permitted).\n     *\n     * @see #getUpArrow()\n     */\n    public void setUpArrow(Shape arrow) {\n        if (arrow == null) {\n            throw new IllegalArgumentException(\"Null 'arrow' argument.\");\n        }\n        this.upArrow = arrow;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns a shape that can be displayed as an arrow pointing downwards at\n     * the end of an axis line.\n     *\n     * @return A shape (never <code>null</code>).\n     *\n     * @see #setDownArrow(Shape)\n     */\n    public Shape getDownArrow() {\n        return this.downArrow;\n    }\n\n    /**\n     * Sets the shape that can be displayed as an arrow pointing downwards at\n     * the end of an axis line and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param arrow  the arrow shape (<code>null</code> not permitted).\n     *\n     * @see #getDownArrow()\n     */\n    public void setDownArrow(Shape arrow) {\n        if (arrow == null) {\n            throw new IllegalArgumentException(\"Null 'arrow' argument.\");\n        }\n        this.downArrow = arrow;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns a shape that can be displayed as an arrow pointing left at the\n     * end of an axis line.\n     *\n     * @return A shape (never <code>null</code>).\n     *\n     * @see #setLeftArrow(Shape)\n     */\n    public Shape getLeftArrow() {\n        return this.leftArrow;\n    }\n\n    /**\n     * Sets the shape that can be displayed as an arrow pointing left at the\n     * end of an axis line and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param arrow  the arrow shape (<code>null</code> not permitted).\n     *\n     * @see #getLeftArrow()\n     */\n    public void setLeftArrow(Shape arrow) {\n        if (arrow == null) {\n            throw new IllegalArgumentException(\"Null 'arrow' argument.\");\n        }\n        this.leftArrow = arrow;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns a shape that can be displayed as an arrow pointing right at the\n     * end of an axis line.\n     *\n     * @return A shape (never <code>null</code>).\n     *\n     * @see #setRightArrow(Shape)\n     */\n    public Shape getRightArrow() {\n        return this.rightArrow;\n    }\n\n    /**\n     * Sets the shape that can be displayed as an arrow pointing rightwards at\n     * the end of an axis line and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param arrow  the arrow shape (<code>null</code> not permitted).\n     *\n     * @see #getRightArrow()\n     */\n    public void setRightArrow(Shape arrow) {\n        if (arrow == null) {\n            throw new IllegalArgumentException(\"Null 'arrow' argument.\");\n        }\n        this.rightArrow = arrow;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Draws an axis line at the current cursor position and edge.\n     *\n     * @param g2  the graphics device.\n     * @param cursor  the cursor position.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     */\n    protected void drawAxisLine(Graphics2D g2, double cursor,\n                                Rectangle2D dataArea, RectangleEdge edge) {\n        Line2D axisLine = null;\n        if (edge == RectangleEdge.TOP) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor,\n                    dataArea.getMaxX(), cursor);\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor,\n                    dataArea.getMaxX(), cursor);\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor,\n                    dataArea.getMaxY());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor,\n                    dataArea.getMaxY());\n        }\n        g2.setPaint(getAxisLinePaint());\n        g2.setStroke(getAxisLineStroke());\n        g2.draw(axisLine);\n\n        boolean drawUpOrRight = false;\n        boolean drawDownOrLeft = false;\n        if (this.positiveArrowVisible) {\n            if (this.inverted) {\n                drawDownOrLeft = true;\n            }\n            else {\n                drawUpOrRight = true;\n            }\n        }\n        if (this.negativeArrowVisible) {\n            if (this.inverted) {\n                drawUpOrRight = true;\n            }\n            else {\n                drawDownOrLeft = true;\n            }\n        }\n        if (drawUpOrRight) {\n            double x = 0.0;\n            double y = 0.0;\n            Shape arrow = null;\n            if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n                x = dataArea.getMaxX();\n                y = cursor;\n                arrow = this.rightArrow;\n            }\n            else if (edge == RectangleEdge.LEFT\n                    || edge == RectangleEdge.RIGHT) {\n                x = cursor;\n                y = dataArea.getMinY();\n                arrow = this.upArrow;\n            }\n\n            // draw the arrow...\n            AffineTransform transformer = new AffineTransform();\n            transformer.setToTranslation(x, y);\n            Shape shape = transformer.createTransformedShape(arrow);\n            g2.fill(shape);\n            g2.draw(shape);\n        }\n\n        if (drawDownOrLeft) {\n            double x = 0.0;\n            double y = 0.0;\n            Shape arrow = null;\n            if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n                x = dataArea.getMinX();\n                y = cursor;\n                arrow = this.leftArrow;\n            }\n            else if (edge == RectangleEdge.LEFT\n                    || edge == RectangleEdge.RIGHT) {\n                x = cursor;\n                y = dataArea.getMaxY();\n                arrow = this.downArrow;\n            }\n\n            // draw the arrow...\n            AffineTransform transformer = new AffineTransform();\n            transformer.setToTranslation(x, y);\n            Shape shape = transformer.createTransformedShape(arrow);\n            g2.fill(shape);\n            g2.draw(shape);\n        }\n\n    }\n\n    /**\n     * Calculates the anchor point for a tick label.\n     *\n     * @param tick  the tick.\n     * @param cursor  the cursor.\n     * @param dataArea  the data area.\n     * @param edge  the edge on which the axis is drawn.\n     *\n     * @return The x and y coordinates of the anchor point.\n     */\n    protected float[] calculateAnchorPoint(ValueTick tick,\n                                           double cursor,\n                                           Rectangle2D dataArea,\n                                           RectangleEdge edge) {\n\n        RectangleInsets insets = getTickLabelInsets();\n        float[] result = new float[2];\n        if (edge == RectangleEdge.TOP) {\n            result[0] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n            result[1] = (float) (cursor - insets.getBottom() - 2.0);\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            result[0] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n            result[1] = (float) (cursor + insets.getTop() + 2.0);\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            result[0] = (float) (cursor - insets.getLeft() - 2.0);\n            result[1] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            result[0] = (float) (cursor + insets.getRight() + 2.0);\n            result[1] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n        }\n        return result;\n    }\n\n    /**\n     * Draws the axis line, tick marks and tick mark labels.\n     *\n     * @param g2  the graphics device.\n     * @param cursor  the cursor.\n     * @param plotArea  the plot area.\n     * @param dataArea  the data area.\n     * @param edge  the edge that the axis is aligned with.\n     *\n     * @return The width or height used to draw the axis.\n     */\n    protected AxisState drawTickMarksAndLabels(Graphics2D g2,\n            double cursor, Rectangle2D plotArea, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        AxisState state = new AxisState(cursor);\n\n        if (isAxisLineVisible()) {\n            drawAxisLine(g2, cursor, dataArea, edge);\n        }\n\n        List ticks = refreshTicks(g2, state, dataArea, edge);\n        state.setTicks(ticks);\n        g2.setFont(getTickLabelFont());\n        Iterator iterator = ticks.iterator();\n        while (iterator.hasNext()) {\n            ValueTick tick = (ValueTick) iterator.next();\n            if (isTickLabelsVisible()) {\n                g2.setPaint(getTickLabelPaint());\n                float[] anchorPoint = calculateAnchorPoint(tick, cursor,\n                        dataArea, edge);\n                TextUtilities.drawRotatedString(tick.getText(), g2,\n                        anchorPoint[0], anchorPoint[1], tick.getTextAnchor(),\n                        tick.getAngle(), tick.getRotationAnchor());\n            }\n\n            if ((isTickMarksVisible() && tick.getTickType().equals(\n                    TickType.MAJOR)) || (isMinorTickMarksVisible()\n                    && tick.getTickType().equals(TickType.MINOR))) {\n\n                double ol = (tick.getTickType().equals(TickType.MINOR)) ?\n                    getMinorTickMarkOutsideLength() : getTickMarkOutsideLength();\n\n                double il = (tick.getTickType().equals(TickType.MINOR)) ?\n                    getMinorTickMarkInsideLength() : getTickMarkInsideLength();\n\n                float xx = (float) valueToJava2D(tick.getValue(), dataArea,\n                        edge);\n                Line2D mark = null;\n                g2.setStroke(getTickMarkStroke());\n                g2.setPaint(getTickMarkPaint());\n                if (edge == RectangleEdge.LEFT) {\n                    mark = new Line2D.Double(cursor - ol, xx, cursor + il, xx);\n                }\n                else if (edge == RectangleEdge.RIGHT) {\n                    mark = new Line2D.Double(cursor + ol, xx, cursor - il, xx);\n                }\n                else if (edge == RectangleEdge.TOP) {\n                    mark = new Line2D.Double(xx, cursor - ol, xx, cursor + il);\n                }\n                else if (edge == RectangleEdge.BOTTOM) {\n                    mark = new Line2D.Double(xx, cursor + ol, xx, cursor - il);\n                }\n                g2.draw(mark);\n            }\n        }\n\n        // need to work out the space used by the tick labels...\n        // so we can update the cursor...\n        double used = 0.0;\n        if (isTickLabelsVisible()) {\n            if (edge == RectangleEdge.LEFT) {\n                used += findMaximumTickLabelWidth(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n                state.cursorLeft(used);\n            }\n            else if (edge == RectangleEdge.RIGHT) {\n                used = findMaximumTickLabelWidth(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n                state.cursorRight(used);\n            }\n            else if (edge == RectangleEdge.TOP) {\n                used = findMaximumTickLabelHeight(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n                state.cursorUp(used);\n            }\n            else if (edge == RectangleEdge.BOTTOM) {\n                used = findMaximumTickLabelHeight(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n                state.cursorDown(used);\n            }\n        }\n\n        return state;\n    }\n\n    /**\n     * Returns the space required to draw the axis.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot that the axis belongs to.\n     * @param plotArea  the area within which the plot should be drawn.\n     * @param edge  the axis location.\n     * @param space  the space already reserved (for other axes).\n     *\n     * @return The space required to draw the axis (including pre-reserved\n     *         space).\n     */\n    public AxisSpace reserveSpace(Graphics2D g2, Plot plot,\n                                  Rectangle2D plotArea,\n                                  RectangleEdge edge, AxisSpace space) {\n\n        // create a new space object if one wasn't supplied...\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // if the axis is not visible, no additional space is required...\n        if (!isVisible()) {\n            return space;\n        }\n\n        // if the axis has a fixed dimension, return it...\n        double dimension = getFixedDimension();\n        if (dimension > 0.0) {\n            space.ensureAtLeast(dimension, edge);\n        }\n\n        // calculate the max size of the tick labels (if visible)...\n        double tickLabelHeight = 0.0;\n        double tickLabelWidth = 0.0;\n        if (isTickLabelsVisible()) {\n            g2.setFont(getTickLabelFont());\n            List ticks = refreshTicks(g2, new AxisState(), plotArea, edge);\n            if (RectangleEdge.isTopOrBottom(edge)) {\n                tickLabelHeight = findMaximumTickLabelHeight(ticks, g2,\n                        plotArea, isVerticalTickLabels());\n            }\n            else if (RectangleEdge.isLeftOrRight(edge)) {\n                tickLabelWidth = findMaximumTickLabelWidth(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n            }\n        }\n\n        // get the axis label size and update the space object...\n        Rectangle2D labelEnclosure = getLabelEnclosure(g2, edge);\n        double labelHeight = 0.0;\n        double labelWidth = 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            labelHeight = labelEnclosure.getHeight();\n            space.add(labelHeight + tickLabelHeight, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            labelWidth = labelEnclosure.getWidth();\n            space.add(labelWidth + tickLabelWidth, edge);\n        }\n\n        return space;\n\n    }\n\n    /**\n     * A utility method for determining the height of the tallest tick label.\n     *\n     * @param ticks  the ticks.\n     * @param g2  the graphics device.\n     * @param drawArea  the area within which the plot and axes should be drawn.\n     * @param vertical  a flag that indicates whether or not the tick labels\n     *                  are 'vertical'.\n     *\n     * @return The height of the tallest tick label.\n     */\n    protected double findMaximumTickLabelHeight(List ticks,\n                                                Graphics2D g2,\n                                                Rectangle2D drawArea,\n                                                boolean vertical) {\n\n        RectangleInsets insets = getTickLabelInsets();\n        Font font = getTickLabelFont();\n        double maxHeight = 0.0;\n        if (vertical) {\n            FontMetrics fm = g2.getFontMetrics(font);\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                Tick tick = (Tick) iterator.next();\n                Rectangle2D labelBounds = TextUtilities.getTextBounds(\n                        tick.getText(), g2, fm);\n                if (labelBounds.getWidth() + insets.getTop()\n                        + insets.getBottom() > maxHeight) {\n                    maxHeight = labelBounds.getWidth()\n                                + insets.getTop() + insets.getBottom();\n                }\n            }\n        }\n        else {\n            LineMetrics metrics = font.getLineMetrics(\"ABCxyz\",\n                    g2.getFontRenderContext());\n            maxHeight = metrics.getHeight()\n                        + insets.getTop() + insets.getBottom();\n        }\n        return maxHeight;\n\n    }\n\n    /**\n     * A utility method for determining the width of the widest tick label.\n     *\n     * @param ticks  the ticks.\n     * @param g2  the graphics device.\n     * @param drawArea  the area within which the plot and axes should be drawn.\n     * @param vertical  a flag that indicates whether or not the tick labels\n     *                  are 'vertical'.\n     *\n     * @return The width of the tallest tick label.\n     */\n    protected double findMaximumTickLabelWidth(List ticks,\n                                               Graphics2D g2,\n                                               Rectangle2D drawArea,\n                                               boolean vertical) {\n\n        RectangleInsets insets = getTickLabelInsets();\n        Font font = getTickLabelFont();\n        double maxWidth = 0.0;\n        if (!vertical) {\n            FontMetrics fm = g2.getFontMetrics(font);\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                Tick tick = (Tick) iterator.next();\n                Rectangle2D labelBounds = TextUtilities.getTextBounds(\n                        tick.getText(), g2, fm);\n                if (labelBounds.getWidth() + insets.getLeft()\n                        + insets.getRight() > maxWidth) {\n                    maxWidth = labelBounds.getWidth()\n                               + insets.getLeft() + insets.getRight();\n                }\n            }\n        }\n        else {\n            LineMetrics metrics = font.getLineMetrics(\"ABCxyz\",\n                    g2.getFontRenderContext());\n            maxWidth = metrics.getHeight()\n                       + insets.getTop() + insets.getBottom();\n        }\n        return maxWidth;\n\n    }\n\n    /**\n     * Returns a flag that controls the direction of values on the axis.\n     * <P>\n     * For a regular axis, values increase from left to right (for a horizontal\n     * axis) and bottom to top (for a vertical axis).  When the axis is\n     * 'inverted', the values increase in the opposite direction.\n     *\n     * @return The flag.\n     *\n     * @see #setInverted(boolean)\n     */\n    public boolean isInverted() {\n        return this.inverted;\n    }\n\n    /**\n     * Sets a flag that controls the direction of values on the axis, and\n     * notifies registered listeners that the axis has changed.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isInverted()\n     */\n    public void setInverted(boolean flag) {\n\n        if (this.inverted != flag) {\n            this.inverted = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns the flag that controls whether or not the axis range is\n     * automatically adjusted to fit the data values.\n     *\n     * @return The flag.\n     *\n     * @see #setAutoRange(boolean)\n     */\n    public boolean isAutoRange() {\n        return this.autoRange;\n    }\n\n    /**\n     * Sets a flag that determines whether or not the axis range is\n     * automatically adjusted to fit the data, and notifies registered\n     * listeners that the axis has been modified.\n     *\n     * @param auto  the new value of the flag.\n     *\n     * @see #isAutoRange()\n     */\n    public void setAutoRange(boolean auto) {\n        setAutoRange(auto, true);\n    }\n\n    /**\n     * Sets the auto range attribute.  If the <code>notify</code> flag is set,\n     * an {@link AxisChangeEvent} is sent to registered listeners.\n     *\n     * @param auto  the flag.\n     * @param notify  notify listeners?\n     *\n     * @see #isAutoRange()\n     */\n    protected void setAutoRange(boolean auto, boolean notify) {\n        if (this.autoRange != auto) {\n            this.autoRange = auto;\n            if (this.autoRange) {\n                autoAdjustRange();\n            }\n            if (notify) {\n                notifyListeners(new AxisChangeEvent(this));\n            }\n        }\n    }\n\n    /**\n     * Returns the minimum size allowed for the axis range when it is\n     * automatically calculated.\n     *\n     * @return The minimum range.\n     *\n     * @see #setAutoRangeMinimumSize(double)\n     */\n    public double getAutoRangeMinimumSize() {\n        return this.autoRangeMinimumSize;\n    }\n\n    /**\n     * Sets the auto range minimum size and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param size  the size.\n     *\n     * @see #getAutoRangeMinimumSize()\n     */\n    public void setAutoRangeMinimumSize(double size) {\n        setAutoRangeMinimumSize(size, true);\n    }\n\n    /**\n     * Sets the minimum size allowed for the axis range when it is\n     * automatically calculated.\n     * <p>\n     * If requested, an {@link AxisChangeEvent} is forwarded to all registered\n     * listeners.\n     *\n     * @param size  the new minimum.\n     * @param notify  notify listeners?\n     */\n    public void setAutoRangeMinimumSize(double size, boolean notify) {\n        if (size <= 0.0) {\n            throw new IllegalArgumentException(\n                \"NumberAxis.setAutoRangeMinimumSize(double): must be > 0.0.\");\n        }\n        if (this.autoRangeMinimumSize != size) {\n            this.autoRangeMinimumSize = size;\n            if (this.autoRange) {\n                autoAdjustRange();\n            }\n            if (notify) {\n                notifyListeners(new AxisChangeEvent(this));\n            }\n        }\n\n    }\n\n    /**\n     * Returns the default auto range.\n     *\n     * @return The default auto range (never <code>null</code>).\n     *\n     * @see #setDefaultAutoRange(Range)\n     *\n     * @since 1.0.5\n     */\n    public Range getDefaultAutoRange() {\n        return this.defaultAutoRange;\n    }\n\n    /**\n     * Sets the default auto range and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param range  the range (<code>null</code> not permitted).\n     *\n     * @see #getDefaultAutoRange()\n     *\n     * @since 1.0.5\n     */\n    public void setDefaultAutoRange(Range range) {\n        if (range == null) {\n            throw new IllegalArgumentException(\"Null 'range' argument.\");\n        }\n        this.defaultAutoRange = range;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the lower margin for the axis, expressed as a percentage of the\n     * axis range.  This controls the space added to the lower end of the axis\n     * when the axis range is automatically calculated (it is ignored when the\n     * axis range is set explicitly). The default value is 0.05 (five percent).\n     *\n     * @return The lower margin.\n     *\n     * @see #setLowerMargin(double)\n     */\n    public double getLowerMargin() {\n        return this.lowerMargin;\n    }\n\n    /**\n     * Sets the lower margin for the axis (as a percentage of the axis range)\n     * and sends an {@link AxisChangeEvent} to all registered listeners.  This\n     * margin is added only when the axis range is auto-calculated - if you set\n     * the axis range manually, the margin is ignored.\n     *\n     * @param margin  the margin percentage (for example, 0.05 is five percent).\n     *\n     * @see #getLowerMargin()\n     * @see #setUpperMargin(double)\n     */\n    public void setLowerMargin(double margin) {\n        this.lowerMargin = margin;\n        if (isAutoRange()) {\n            autoAdjustRange();\n        }\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the upper margin for the axis, expressed as a percentage of the\n     * axis range.  This controls the space added to the lower end of the axis\n     * when the axis range is automatically calculated (it is ignored when the\n     * axis range is set explicitly). The default value is 0.05 (five percent).\n     *\n     * @return The upper margin.\n     *\n     * @see #setUpperMargin(double)\n     */\n    public double getUpperMargin() {\n        return this.upperMargin;\n    }\n\n    /**\n     * Sets the upper margin for the axis (as a percentage of the axis range)\n     * and sends an {@link AxisChangeEvent} to all registered listeners.  This\n     * margin is added only when the axis range is auto-calculated - if you set\n     * the axis range manually, the margin is ignored.\n     *\n     * @param margin  the margin percentage (for example, 0.05 is five percent).\n     *\n     * @see #getLowerMargin()\n     * @see #setLowerMargin(double)\n     */\n    public void setUpperMargin(double margin) {\n        this.upperMargin = margin;\n        if (isAutoRange()) {\n            autoAdjustRange();\n        }\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the fixed auto range.\n     *\n     * @return The length.\n     *\n     * @see #setFixedAutoRange(double)\n     */\n    public double getFixedAutoRange() {\n        return this.fixedAutoRange;\n    }\n\n    /**\n     * Sets the fixed auto range for the axis.\n     *\n     * @param length  the range length.\n     *\n     * @see #getFixedAutoRange()\n     */\n    public void setFixedAutoRange(double length) {\n        this.fixedAutoRange = length;\n        if (isAutoRange()) {\n            autoAdjustRange();\n        }\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the lower bound of the axis range.\n     *\n     * @return The lower bound.\n     *\n     * @see #setLowerBound(double)\n     */\n    public double getLowerBound() {\n        return this.range.getLowerBound();\n    }\n\n    /**\n     * Sets the lower bound for the axis range.  An {@link AxisChangeEvent} is\n     * sent to all registered listeners.\n     *\n     * @param min  the new minimum.\n     *\n     * @see #getLowerBound()\n     */\n    public void setLowerBound(double min) {\n        if (this.range.getUpperBound() > min) {\n            setRange(new Range(min, this.range.getUpperBound()));\n        }\n        else {\n            setRange(new Range(min, min + 1.0));\n        }\n    }\n\n    /**\n     * Returns the upper bound for the axis range.\n     *\n     * @return The upper bound.\n     *\n     * @see #setUpperBound(double)\n     */\n    public double getUpperBound() {\n        return this.range.getUpperBound();\n    }\n\n    /**\n     * Sets the upper bound for the axis range, and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param max  the new maximum.\n     *\n     * @see #getUpperBound()\n     */\n    public void setUpperBound(double max) {\n        if (this.range.getLowerBound() < max) {\n            setRange(new Range(this.range.getLowerBound(), max));\n        }\n        else {\n            setRange(max - 1.0, max);\n        }\n    }\n\n    /**\n     * Returns the range for the axis.\n     *\n     * @return The axis range (never <code>null</code>).\n     *\n     * @see #setRange(Range)\n     */\n    public Range getRange() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range attribute and sends an {@link AxisChangeEvent} to all\n     * registered listeners.  As a side-effect, the auto-range flag is set to\n     * <code>false</code>.\n     *\n     * @param range  the range (<code>null</code> not permitted).\n     *\n     * @see #getRange()\n     */\n    public void setRange(Range range) {\n        // defer argument checking\n        setRange(range, true, true);\n    }\n\n    /**\n     * Sets the range for the axis, if requested, sends an\n     * {@link AxisChangeEvent} to all registered listeners.  As a side-effect,\n     * the auto-range flag is set to <code>false</code> (optional).\n     *\n     * @param range  the range (<code>null</code> not permitted).\n     * @param turnOffAutoRange  a flag that controls whether or not the auto\n     *                          range is turned off.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     *\n     * @see #getRange()\n     */\n    public void setRange(Range range, boolean turnOffAutoRange,\n                         boolean notify) {\n        if (range == null) {\n            throw new IllegalArgumentException(\"Null 'range' argument.\");\n        }\n        if (turnOffAutoRange) {\n            this.autoRange = false;\n        }\n        this.range = range;\n        if (notify) {\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Sets the axis range and sends an {@link AxisChangeEvent} to all\n     * registered listeners.  As a side-effect, the auto-range flag is set to\n     * <code>false</code>.\n     *\n     * @param lower  the lower axis limit.\n     * @param upper  the upper axis limit.\n     *\n     * @see #getRange()\n     * @see #setRange(Range)\n     */\n    public void setRange(double lower, double upper) {\n        setRange(new Range(lower, upper));\n    }\n\n    /**\n     * Sets the range for the axis (after first adding the current margins to\n     * the specified range) and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param range  the range (<code>null</code> not permitted).\n     */\n    public void setRangeWithMargins(Range range) {\n        setRangeWithMargins(range, true, true);\n    }\n\n    /**\n     * Sets the range for the axis after first adding the current margins to\n     * the range and, if requested, sends an {@link AxisChangeEvent} to all\n     * registered listeners.  As a side-effect, the auto-range flag is set to\n     * <code>false</code> (optional).\n     *\n     * @param range  the range (excluding margins, <code>null</code> not\n     *               permitted).\n     * @param turnOffAutoRange  a flag that controls whether or not the auto\n     *                          range is turned off.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     */\n    public void setRangeWithMargins(Range range, boolean turnOffAutoRange,\n                                    boolean notify) {\n        if (range == null) {\n            throw new IllegalArgumentException(\"Null 'range' argument.\");\n        }\n        setRange(Range.expand(range, getLowerMargin(), getUpperMargin()),\n                turnOffAutoRange, notify);\n    }\n\n    /**\n     * Sets the axis range (after first adding the current margins to the\n     * range) and sends an {@link AxisChangeEvent} to all registered listeners.\n     * As a side-effect, the auto-range flag is set to <code>false</code>.\n     *\n     * @param lower  the lower axis limit.\n     * @param upper  the upper axis limit.\n     */\n    public void setRangeWithMargins(double lower, double upper) {\n        setRangeWithMargins(new Range(lower, upper));\n    }\n\n    /**\n     * Sets the axis range, where the new range is 'size' in length, and\n     * centered on 'value'.\n     *\n     * @param value  the central value.\n     * @param length  the range length.\n     */\n    public void setRangeAboutValue(double value, double length) {\n        setRange(new Range(value - length / 2, value + length / 2));\n    }\n\n    /**\n     * Returns a flag indicating whether or not the tick unit is automatically\n     * selected from a range of standard tick units.\n     *\n     * @return A flag indicating whether or not the tick unit is automatically\n     *         selected.\n     *\n     * @see #setAutoTickUnitSelection(boolean)\n     */\n    public boolean isAutoTickUnitSelection() {\n        return this.autoTickUnitSelection;\n    }\n\n    /**\n     * Sets a flag indicating whether or not the tick unit is automatically\n     * selected from a range of standard tick units.  If the flag is changed,\n     * registered listeners are notified that the chart has changed.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @see #isAutoTickUnitSelection()\n     */\n    public void setAutoTickUnitSelection(boolean flag) {\n        setAutoTickUnitSelection(flag, true);\n    }\n\n    /**\n     * Sets a flag indicating whether or not the tick unit is automatically\n     * selected from a range of standard tick units.\n     *\n     * @param flag  the new value of the flag.\n     * @param notify  notify listeners?\n     *\n     * @see #isAutoTickUnitSelection()\n     */\n    public void setAutoTickUnitSelection(boolean flag, boolean notify) {\n\n        if (this.autoTickUnitSelection != flag) {\n            this.autoTickUnitSelection = flag;\n            if (notify) {\n                notifyListeners(new AxisChangeEvent(this));\n            }\n        }\n    }\n\n    /**\n     * Returns the source for obtaining standard tick units for the axis.\n     *\n     * @return The source (possibly <code>null</code>).\n     *\n     * @see #setStandardTickUnits(TickUnitSource)\n     */\n    public TickUnitSource getStandardTickUnits() {\n        return this.standardTickUnits;\n    }\n\n    /**\n     * Sets the source for obtaining standard tick units for the axis and sends\n     * an {@link AxisChangeEvent} to all registered listeners.  The axis will\n     * try to select the smallest tick unit from the source that does not cause\n     * the tick labels to overlap (see also the\n     * {@link #setAutoTickUnitSelection(boolean)} method.\n     *\n     * @param source  the source for standard tick units (<code>null</code>\n     *                permitted).\n     *\n     * @see #getStandardTickUnits()\n     */\n    public void setStandardTickUnits(TickUnitSource source) {\n        this.standardTickUnits = source;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the number of minor tick marks to display.\n     *\n     * @return The number of minor tick marks to display.\n     *\n     * @see #setMinorTickCount(int)\n     *\n     * @since 1.0.12\n     */\n    public int getMinorTickCount() {\n        return this.minorTickCount;\n    }\n\n    /**\n     * Sets the number of minor tick marks to display, and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param count  the count.\n     *\n     * @see #getMinorTickCount()\n     *\n     * @since 1.0.12\n     */\n    public void setMinorTickCount(int count) {\n        this.minorTickCount = count;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Converts a data value to a coordinate in Java2D space, assuming that the\n     * axis runs along one edge of the specified dataArea.\n     * <p>\n     * Note that it is possible for the coordinate to fall outside the area.\n     *\n     * @param value  the data value.\n     * @param area  the area for plotting the data.\n     * @param edge  the edge along which the axis lies.\n     *\n     * @return The Java2D coordinate.\n     *\n     * @see #java2DToValue(double, Rectangle2D, RectangleEdge)\n     */\n    public abstract double valueToJava2D(double value, Rectangle2D area,\n                                         RectangleEdge edge);\n\n    /**\n     * Converts a length in data coordinates into the corresponding length in\n     * Java2D coordinates.\n     *\n     * @param length  the length.\n     * @param area  the plot area.\n     * @param edge  the edge along which the axis lies.\n     *\n     * @return The length in Java2D coordinates.\n     */\n    public double lengthToJava2D(double length, Rectangle2D area,\n                                 RectangleEdge edge) {\n        double zero = valueToJava2D(0.0, area, edge);\n        double l = valueToJava2D(length, area, edge);\n        return Math.abs(l - zero);\n    }\n\n    /**\n     * Converts a coordinate in Java2D space to the corresponding data value,\n     * assuming that the axis runs along one edge of the specified dataArea.\n     *\n     * @param java2DValue  the coordinate in Java2D space.\n     * @param area  the area in which the data is plotted.\n     * @param edge  the edge along which the axis lies.\n     *\n     * @return The data value.\n     *\n     * @see #valueToJava2D(double, Rectangle2D, RectangleEdge)\n     */\n    public abstract double java2DToValue(double java2DValue,\n                                         Rectangle2D area,\n                                         RectangleEdge edge);\n\n    /**\n     * Automatically sets the axis range to fit the range of values in the\n     * dataset.  Sometimes this can depend on the renderer used as well (for\n     * example, the renderer may \"stack\" values, requiring an axis range\n     * greater than otherwise necessary).\n     */\n    protected abstract void autoAdjustRange();\n\n    /**\n     * Centers the axis range about the specified value and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param value  the center value.\n     */\n    public void centerRange(double value) {\n\n        double central = this.range.getCentralValue();\n        Range adjusted = new Range(this.range.getLowerBound() + value - central,\n                this.range.getUpperBound() + value - central);\n        setRange(adjusted);\n\n    }\n\n    /**\n     * Increases or decreases the axis range by the specified percentage about\n     * the central value and sends an {@link AxisChangeEvent} to all registered\n     * listeners.\n     * <P>\n     * To double the length of the axis range, use 200% (2.0).\n     * To halve the length of the axis range, use 50% (0.5).\n     *\n     * @param percent  the resize factor.\n     *\n     * @see #resizeRange(double, double)\n     */\n    public void resizeRange(double percent) {\n        resizeRange(percent, this.range.getCentralValue());\n    }\n\n    /**\n     * Increases or decreases the axis range by the specified percentage about\n     * the specified anchor value and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     * <P>\n     * To double the length of the axis range, use 200% (2.0).\n     * To halve the length of the axis range, use 50% (0.5).\n     *\n     * @param percent  the resize factor.\n     * @param anchorValue  the new central value after the resize.\n     *\n     * @see #resizeRange(double)\n     */\n    public void resizeRange(double percent, double anchorValue) {\n        if (percent > 0.0) {\n            double halfLength = this.range.getLength() * percent / 2;\n            Range adjusted = new Range(anchorValue - halfLength,\n                    anchorValue + halfLength);\n            setRange(adjusted);\n        }\n        else {\n            setAutoRange(true);\n        }\n    }\n\n    /**\n     * Increases or decreases the axis range by the specified percentage about\n     * the specified anchor value and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     * <P>\n     * To double the length of the axis range, use 200% (2.0).\n     * To halve the length of the axis range, use 50% (0.5).\n     *\n     * @param percent  the resize factor.\n     * @param anchorValue  the new central value after the resize.\n     *\n     * @see #resizeRange(double)\n     *\n     * @since 1.0.13\n     */\n    public void resizeRange2(double percent, double anchorValue) {\n        if (percent > 0.0) {\n            double left = anchorValue - getLowerBound();\n            double right = getUpperBound() - anchorValue;\n            Range adjusted = new Range(anchorValue - left * percent,\n                    anchorValue + right * percent);\n            setRange(adjusted);\n        }\n        else {\n            setAutoRange(true);\n        }\n    }\n\n    /**\n     * Zooms in on the current range.\n     *\n     * @param lowerPercent  the new lower bound.\n     * @param upperPercent  the new upper bound.\n     */\n    public void zoomRange(double lowerPercent, double upperPercent) {\n        double start = this.range.getLowerBound();\n        double length = this.range.getLength();\n        Range adjusted = null;\n        if (isInverted()) {\n            adjusted = new Range(start + (length * (1 - upperPercent)),\n                                 start + (length * (1 - lowerPercent)));\n        }\n        else {\n            adjusted = new Range(start + length * lowerPercent,\n                    start + length * upperPercent);\n        }\n        setRange(adjusted);\n    }\n\n    /**\n     * Slides the axis range by the specified percentage.\n     *\n     * @param percent  the percentage.\n     *\n     * @since 1.0.13\n     */\n    public void pan(double percent) {\n        Range range = getRange();\n        double length = range.getLength();\n        double adj = length * percent;\n        double lower = range.getLowerBound() + adj;\n        double upper = range.getUpperBound() + adj;\n        setRange(lower, upper);\n    }\n\n    /**\n     * Returns the auto tick index.\n     *\n     * @return The auto tick index.\n     *\n     * @see #setAutoTickIndex(int)\n     */\n    protected int getAutoTickIndex() {\n        return this.autoTickIndex;\n    }\n\n    /**\n     * Sets the auto tick index.\n     *\n     * @param index  the new value.\n     *\n     * @see #getAutoTickIndex()\n     */\n    protected void setAutoTickIndex(int index) {\n        this.autoTickIndex = index;\n    }\n\n    /**\n     * Tests the axis for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ValueAxis)) {\n            return false;\n        }\n        ValueAxis that = (ValueAxis) obj;\n        if (this.positiveArrowVisible != that.positiveArrowVisible) {\n            return false;\n        }\n        if (this.negativeArrowVisible != that.negativeArrowVisible) {\n            return false;\n        }\n        if (this.inverted != that.inverted) {\n            return false;\n        }\n        // if autoRange is true, then the current range is irrelevant\n        if (!this.autoRange && !ObjectUtilities.equal(this.range, that.range)) {\n            return false;\n        }\n        if (this.autoRange != that.autoRange) {\n            return false;\n        }\n        if (this.autoRangeMinimumSize != that.autoRangeMinimumSize) {\n            return false;\n        }\n        if (!this.defaultAutoRange.equals(that.defaultAutoRange)) {\n            return false;\n        }\n        if (this.upperMargin != that.upperMargin) {\n            return false;\n        }\n        if (this.lowerMargin != that.lowerMargin) {\n            return false;\n        }\n        if (this.fixedAutoRange != that.fixedAutoRange) {\n            return false;\n        }\n        if (this.autoTickUnitSelection != that.autoTickUnitSelection) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.standardTickUnits,\n                that.standardTickUnits)) {\n            return false;\n        }\n        if (this.verticalTickLabels != that.verticalTickLabels) {\n            return false;\n        }\n        if (this.minorTickCount != that.minorTickCount) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a clone of the object.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the axis does\n     *         not support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        ValueAxis clone = (ValueAxis) super.clone();\n        return clone;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeShape(this.upArrow, stream);\n        SerialUtilities.writeShape(this.downArrow, stream);\n        SerialUtilities.writeShape(this.leftArrow, stream);\n        SerialUtilities.writeShape(this.rightArrow, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n            throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.upArrow = SerialUtilities.readShape(stream);\n        this.downArrow = SerialUtilities.readShape(stream);\n        this.leftArrow = SerialUtilities.readShape(stream);\n        this.rightArrow = SerialUtilities.readShape(stream);\n    }\n\n\t/**\n\t * Sets the flag that controls whether or not the range axis grid lines are\n\t * visible.  If the flag value is changed, a {@link PlotChangeEvent} is\n\t * sent to all registered listeners.\n\t *\n\t * @param fastScatterPlot TODO\n\t * @param visible  the new value of the flag.\n\t * @see #isRangeGridlinesVisible()\n\t */\n\tpublic void setRangeGridlinesVisible(FastScatterPlot fastScatterPlot, boolean visible) {\n\t    if (fastScatterPlot.rangeGridlinesVisible != visible) {\n\t        fastScatterPlot.rangeGridlinesVisible = visible;\n\t        fastScatterPlot.fireChangeEvent();\n\t    }\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 1763,
                        "lineEnd": 1777,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.FastScatterPlot\nRationale: The method directly manipulates the 'rangeGridlinesVisible' property of the FastScatterPlot instance and is responsible for changing its visibility state, making it most appropriate to reside within the FastScatterPlot class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 7881
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setRangeGridlinesVisible",
                            "method_signature": "public void setRangeGridlinesVisible(FastScatterPlot fastScatterPlot, boolean visible)",
                            "target_class": "FastScatterPlot",
                            "rationale": "The method setRangeGridlinesVisible() directly manipulates the properties of the FastScatterPlot class, indicating that it is more appropriate for this method to reside within the FastScatterPlot class."
                        }
                    ],
                    "llm_response_time": 2497
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setRangeGridlinesVisible",
                            "method_signature": "public void setRangeGridlinesVisible(FastScatterPlot fastScatterPlot, boolean visible)",
                            "target_class": "FastScatterPlot",
                            "rationale": "The method setRangeGridlinesVisible() directly manipulates the properties of the FastScatterPlot class, indicating that it is more appropriate for this method to reside within the FastScatterPlot class."
                        }
                    ],
                    "llm_response_time": 1992
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setRangeGridlinesVisible",
                            "method_signature": "public void setRangeGridlinesVisible(FastScatterPlot fastScatterPlot, boolean visible)",
                            "target_class": "FastScatterPlot",
                            "rationale": "The method setRangeGridlinesVisible directly manipulates the properties of FastScatterPlot, indicating it is more appropriate for that class."
                        }
                    ],
                    "llm_response_time": 1825
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setRangeGridlinesVisible",
                            "method_signature": "public void setRangeGridlinesVisible(FastScatterPlot fastScatterPlot, boolean visible)",
                            "target_class": "FastScatterPlot",
                            "rationale": "The method setRangeGridlinesVisible() directly manipulates the properties of the FastScatterPlot class, indicating that it is more appropriate for this method to reside within the FastScatterPlot class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setRangeGridlinesVisible"
                ],
                "llm_response_time": 1497
            },
            "targetClassMap": {
                "setRangeGridlinesVisible": {
                    "target_classes": [
                        {
                            "class_name": "FastScatterPlot",
                            "similarity_score": 0.8209363427002099
                        },
                        {
                            "class_name": "Range",
                            "similarity_score": 0.765678939528933
                        },
                        {
                            "class_name": "Range",
                            "similarity_score": 0.765678939528933
                        },
                        {
                            "class_name": "Range",
                            "similarity_score": 0.765678939528933
                        },
                        {
                            "class_name": "TickUnitSource",
                            "similarity_score": 0.68159627667371
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "FastScatterPlot",
                        "Range",
                        "Range",
                        "Range",
                        "TickUnitSource"
                    ],
                    "llm_response_time": 1618,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.event.TitleChangeEvent::notifyListeners(TitleChangeEvent):void need move org.jfree.chart.title.Title",
        "class_name": "org.jfree.chart.event.TitleChangeEvent",
        "telemetry": {
            "id": "060c21d9-2dd8-4c3e-bf4a-7b6be046af13",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 46,
                "lineStart": 50,
                "lineEnd": 95,
                "bodyLineStart": 50,
                "language": "java",
                "sourceCode": "/**\n * A change event that encapsulates information about a change to a chart title.\n */\npublic class TitleChangeEvent extends ChartChangeEvent {\n\n    /** The chart title that generated the event. */\n    private Title title;\n\n    /**\n     * Default constructor.\n     *\n     * @param title  the chart title that generated the event.\n     */\n    public TitleChangeEvent(Title title) {\n        super(title);\n        this.title = title;\n    }\n\n    /**\n     * Returns the title that generated the event.\n     *\n     * @return The title that generated the event.\n     */\n    public Title getTitle() {\n        return this.title;\n    }\n\n\t/**\n\t * Notifies all registered listeners that the chart title has changed in\n\t * some way.\n\t *\n\t * @param title TODO\n\t */\n\tpublic void notifyListeners(Title title) {\n\t    if (title.notify) {\n\t        Object[] listeners = title.listenerList.getListenerList();\n\t        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n\t            if (listeners[i] == TitleChangeListener.class) {\n\t                ((TitleChangeListener) listeners[i + 1]).titleChanged(\n\t                        this);\n\t            }\n\t        }\n\t    }\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 76,
                        "lineEnd": 92,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.title.Title\nRationale: The method notifyListeners(Title title) directly interacts with the Title object, specifically its properties like notify and listenerList, making it logical for this method to reside within the Title class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 8577
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "notifyListeners",
                            "method_signature": "public void notifyListeners(Title title)",
                            "target_class": "Title",
                            "rationale": "The notifyListeners() method is closely tied to the Title class and its listeners. It would be more appropriate for this method to reside within the Title class, where it can directly manage its own listeners."
                        }
                    ],
                    "llm_response_time": 1187
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "notifyListeners",
                            "method_signature": "public void notifyListeners(Title title)",
                            "target_class": "Title",
                            "rationale": "The notifyListeners() method is closely tied to the Title class and its listeners. It would be more appropriate for this method to reside within the Title class, where it can directly manage its own listeners."
                        }
                    ],
                    "llm_response_time": 1132
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "notifyListeners",
                            "method_signature": "public void notifyListeners(Title title)",
                            "target_class": "Title",
                            "rationale": "The notifyListeners() method is closely tied to the Title class and its listeners. It would be more appropriate for this method to reside within the Title class, where it can directly manage its own listeners."
                        }
                    ],
                    "llm_response_time": 1014
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "notifyListeners",
                            "method_signature": "public void notifyListeners(Title title)",
                            "target_class": "Title",
                            "rationale": "The notifyListeners() method is closely tied to the Title class and its listeners. It would be more appropriate for this method to reside within the Title class, where it can directly manage its own listeners."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "notifyListeners"
                ],
                "llm_response_time": 5156
            },
            "targetClassMap": {
                "notifyListeners": {
                    "target_classes": [
                        {
                            "class_name": "Title",
                            "similarity_score": 0.6079759336890354
                        },
                        {
                            "class_name": "Title",
                            "similarity_score": 0.6079759336890354
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Title",
                        "Title"
                    ],
                    "llm_response_time": 1010,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.data.general.DatasetGroup::setDatasetGroup(DatasetGroup):void need move org.jfree.chart.plot.Plot",
        "class_name": "org.jfree.data.general.DatasetGroup",
        "telemetry": {
            "id": "feeb3cd6-90d7-4104-bf3d-92eda938c7d1",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 84,
                "lineStart": 49,
                "lineEnd": 132,
                "bodyLineStart": 49,
                "language": "java",
                "sourceCode": "/**\n * A class that is used to group datasets (currently not used for any specific\n * purpose).\n */\npublic class DatasetGroup implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -3640642179674185688L;\n\n    /** The group id. */\n    private String id;\n\n    /**\n     * Constructs a new group.\n     */\n    public DatasetGroup() {\n        super();\n        this.id = \"NOID\";\n    }\n\n    /**\n     * Creates a new group with the specified id.\n     *\n     * @param id  the identification for the group.\n     */\n    public DatasetGroup(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Null 'id' argument.\");\n        }\n        this.id = id;\n    }\n\n    /**\n     * Returns the identification string for this group.\n     *\n     * @return The identification string.\n     */\n    public String getID() {\n        return this.id;\n    }\n\n    /**\n     * Clones the group.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException not by this class.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Tests this instance for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof DatasetGroup)) {\n            return false;\n        }\n        DatasetGroup that = (DatasetGroup) obj;\n        if (!this.id.equals(that.id)) {\n            return false;\n        }\n        return true;\n    }\n\n\t/**\n\t * Sets the dataset group (not currently used).\n\t *\n\t * @param plot TODO\n\t * @see #getDatasetGroup()\n\t */\n\tpublic void setDatasetGroup(Plot plot) {\n\t    plot.datasetGroup = this;\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 121,
                        "lineEnd": 129,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.Plot\nRationale: The method setDatasetGroup(Plot plot) directly modifies the datasetGroup property of the Plot instance, indicating that it is closely related to the Plot class and should be moved there.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 3611
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setDatasetGroup",
                            "method_signature": "public void setDatasetGroup(Plot plot)",
                            "target_class": "Plot",
                            "rationale": "The setDatasetGroup method directly modifies the Plot class's datasetGroup property, indicating that it is more appropriate for this method to reside within the Plot class."
                        }
                    ],
                    "llm_response_time": 1175
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setDatasetGroup",
                            "method_signature": "public void setDatasetGroup(Plot plot)",
                            "target_class": "Plot",
                            "rationale": "The setDatasetGroup method directly modifies the Plot class's datasetGroup property, indicating that it is more appropriate for this method to reside within the Plot class."
                        }
                    ],
                    "llm_response_time": 972
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setDatasetGroup",
                            "method_signature": "public void setDatasetGroup(Plot plot)",
                            "target_class": "Plot",
                            "rationale": "The setDatasetGroup method directly modifies the Plot class's datasetGroup property, indicating that it is more appropriate for this method to reside within the Plot class."
                        }
                    ],
                    "llm_response_time": 972
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setDatasetGroup",
                            "method_signature": "public void setDatasetGroup(Plot plot)",
                            "target_class": "Plot",
                            "rationale": "The setDatasetGroup method directly modifies the Plot class's datasetGroup property, indicating that it is more appropriate for this method to reside within the Plot class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setDatasetGroup"
                ],
                "llm_response_time": 405
            },
            "targetClassMap": {
                "setDatasetGroup": {
                    "target_classes": [
                        {
                            "class_name": "Plot",
                            "similarity_score": 0.7400768636266801
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Plot"
                    ],
                    "llm_response_time": 789,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.jfree.chart.PaintMap::setIgnoreNullValues(boolean):void need move org.jfree.chart.plot.PiePlot",
        "class_name": "org.jfree.chart.PaintMap",
        "telemetry": {
            "id": "73d70607-2ff9-4f77-867f-9ee0d6ecb0cc",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 181,
                "lineStart": 60,
                "lineEnd": 240,
                "bodyLineStart": 60,
                "language": "java",
                "sourceCode": "/**\n * A storage structure that maps <code>Comparable</code> instances with\n * <code>Paint</code> instances.\n * <br><br>\n * To support cloning and serialization, you should only use keys that are\n * cloneable and serializable.  Special handling for the <code>Paint</code>\n * instances is included in this class.\n *\n * @since 1.0.3\n */\npublic class PaintMap implements Cloneable, Serializable {\n\n    /** For serialization. */\n    static final long serialVersionUID = -4639833772123069274L;\n\n    /** Storage for the keys and values. */\n    private transient Map store;\n\n    /**\n     * Creates a new (empty) map.\n     */\n    public PaintMap() {\n        this.store = new HashMap();\n    }\n\n    /**\n     * Returns the paint associated with the specified key, or\n     * <code>null</code>.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The paint, or <code>null</code>.\n     *\n     * @throws IllegalArgumentException if <code>key</code> is\n     *     <code>null</code>.\n     */\n    public Paint getPaint(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        return (Paint) this.store.get(key);\n    }\n\n    /**\n     * Returns <code>true</code> if the map contains the specified key, and\n     * <code>false</code> otherwise.\n     *\n     * @param key  the key.\n     *\n     * @return <code>true</code> if the map contains the specified key, and\n     * <code>false</code> otherwise.\n     */\n    public boolean containsKey(Comparable key) {\n        return this.store.containsKey(key);\n    }\n\n    /**\n     * Adds a mapping between the specified <code>key</code> and\n     * <code>paint</code> values.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     * @param paint  the paint.\n     *\n     * @throws IllegalArgumentException if <code>key</code> is\n     *     <code>null</code>.\n     */\n    public void put(Comparable key, Paint paint) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        this.store.put(key, paint);\n    }\n\n    /**\n     * Resets the map to empty.\n     */\n    public void clear() {\n        this.store.clear();\n    }\n\n    /**\n     * Tests this map for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof PaintMap)) {\n            return false;\n        }\n        PaintMap that = (PaintMap) obj;\n        if (this.store.size() != that.store.size()) {\n            return false;\n        }\n        Set keys = this.store.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Paint p1 = getPaint(key);\n            Paint p2 = that.getPaint(key);\n            if (!PaintUtilities.equal(p1, p2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a clone of this <code>PaintMap</code>.\n     *\n     * @return A clone of this instance.\n     *\n     * @throws CloneNotSupportedException if any key is not cloneable.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        // TODO: I think we need to make sure the keys are actually cloned,\n        // whereas the paint instances are always immutable so they're OK\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        stream.writeInt(this.store.size());\n        Set keys = this.store.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            stream.writeObject(key);\n            Paint paint = getPaint(key);\n            SerialUtilities.writePaint(paint, stream);\n        }\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n            throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.store = new HashMap();\n        int keyCount = stream.readInt();\n        for (int i = 0; i < keyCount; i++) {\n            Comparable key = (Comparable) stream.readObject();\n            Paint paint = SerialUtilities.readPaint(stream);\n            this.store.put(key, paint);\n        }\n    }\n\n\t/**\n\t * Sets a flag that controls whether <code>null</code> values are ignored,\n\t * and sends a {@link PlotChangeEvent} to all registered listeners.  At\n\t * present, this only affects whether or not the key is presented in the\n\t * legend.\n\t *\n\t * @param piePlot TODO\n\t * @param flag  the flag.\n\t * @see #getIgnoreNullValues()\n\t * @see #setIgnoreZeroValues(boolean)\n\t */\n\tpublic void setIgnoreNullValues(PiePlot piePlot, boolean flag) {\n\t    piePlot.ignoreNullValues = flag;\n\t    piePlot.fireChangeEvent();\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 223,
                        "lineEnd": 237,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.jfree.chart.plot.PiePlot\nRationale: The method directly manipulates the 'ignoreNullValues' property of the PiePlot instance and is responsible for sending a change event related to the PiePlot's state, making it most appropriate to reside within the PiePlot class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 6500
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setIgnoreNullValues",
                            "method_signature": "public void setIgnoreNullValues(PiePlot piePlot, boolean flag)",
                            "target_class": "PiePlot",
                            "rationale": "The method setIgnoreNullValues() directly manipulates the PiePlot instance, which suggests that it is more appropriate for this method to reside within the PiePlot class itself."
                        }
                    ],
                    "llm_response_time": 1436
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setIgnoreNullValues",
                            "method_signature": "public void setIgnoreNullValues(PiePlot piePlot, boolean flag)",
                            "target_class": "PiePlot",
                            "rationale": "The method setIgnoreNullValues() directly manipulates the PiePlot instance, which suggests that it is more appropriate for this method to reside within the PiePlot class itself."
                        }
                    ],
                    "llm_response_time": 1195
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setIgnoreNullValues",
                            "method_signature": "public void setIgnoreNullValues(PiePlot piePlot, boolean flag)",
                            "target_class": "PiePlot",
                            "rationale": "The method setIgnoreNullValues() directly manipulates the PiePlot instance, which suggests that it is more appropriate for this method to reside within the PiePlot class itself."
                        }
                    ],
                    "llm_response_time": 1330
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setIgnoreNullValues",
                            "method_signature": "public void setIgnoreNullValues(PiePlot piePlot, boolean flag)",
                            "target_class": "PiePlot",
                            "rationale": "The method setIgnoreNullValues() directly manipulates the PiePlot instance, which suggests that it is more appropriate for this method to reside within the PiePlot class itself."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setIgnoreNullValues"
                ],
                "llm_response_time": 2465
            },
            "targetClassMap": {
                "setIgnoreNullValues": {
                    "target_classes": [
                        {
                            "class_name": "PiePlot",
                            "similarity_score": 0.8053144452417095
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PiePlot"
                    ],
                    "llm_response_time": 793,
                    "similarity_computation_time": 6,
                    "similarity_metric": "cosine"
                }
            }
        }
    }
]